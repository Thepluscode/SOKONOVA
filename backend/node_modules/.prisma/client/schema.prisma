// Consolidated Prisma Schema - Merge of Auth + Marketplace
// This replaces both /prisma/schema.prisma and /backend/prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String                @id @default(cuid())
  email                 String                @unique
  password              String? // For email/password authentication
  name                  String?
  role                  String                @default("BUYER")
  city                  String?
  country               String?
  phone                 String?
  sellerHandle          String?
  shopName              String?
  shopLogoUrl           String?
  shopBannerUrl         String?
  shopBio               String? // Added for seller storefront
  ratingAvg             Float?
  ratingCount           Int?
  bio                   String?
  // Notification preferences
  notifyEmail           Boolean               @default(true)
  notifySms             Boolean               @default(true)
  notifyPush            Boolean               @default(true)
  timezone              String?               @default("Africa/Lagos")
  quietHoursStart       Int? // Hour of day (0-23) when to pause notifications
  quietHoursEnd         Int? // Hour of day (0-23) when to resume notifications
  carts                 Cart[]
  orders                Order[]
  products              Product[]             @relation("SellerProducts")
  sessions              Session[]
  accounts              Account[]
  reviews               Review[]              @relation("BuyerReviews")
  notifications         Notification[]
  stories               CommunityStory[]
  sellerReviews         Review[]              @relation("SellerReviews")
  reportedProducts      CounterfeitReport[]   @relation("Reporter")
  sellerApplications    SellerApplication[]
  disputes              Dispute[]
  fulfillmentSettings   FulfillmentSettings[]
  kycDocuments          KYCDocument[]
  taxRegistrations      TaxRegistration[]
  productViews          ProductView[]
  sponsoredPlacements   SponsoredPlacement[]
  serviceOrdersAsBuyer  ServiceOrder[]        @relation("ServiceOrderBuyer")
  serviceOrdersAsSeller ServiceOrder[]        @relation("ServiceOrderSeller")
  sellerServices        SellerService[]
  subscriptions         UserSubscription[]
  wishlistItems         WishlistItem[]
  // Security & Access Control relations
  createdTeams          Team[]                @relation("TeamCreator")
  teamMemberships       TeamMember[]
  auditLogs             AuditLog[]
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
}

enum Role {
  BUYER
  SELLER
  ADMIN
  MANAGER
  OPERATOR
}

// ============================================
// NextAuth Models (from root /prisma/schema.prisma)
// ============================================

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================
// Marketplace Models (from backend/prisma/schema.prisma)
// ============================================

model Product {
  id                  String               @id @default(cuid())
  sellerId            String
  seller              User                 @relation("SellerProducts", fields: [sellerId], references: [id])
  title               String
  description         String
  price               Decimal              @db.Decimal(12, 2)
  currency            String               @default("USD")
  imageUrl            String?
  inventory           Inventory?
  category            String?
  ratingAvg           Float?
  ratingCount         Int?
  viewCount           Int                  @default(0) // Add this field to track view count
  views               ProductView[]
  cartItems           CartItem[]
  orderItems          OrderItem[]
  productReviews      Review[]             @relation("ProductReviews")
  stories             CommunityStory[]
  reportedIn          CounterfeitReport[]  @relation("ReportedProduct")
  sponsoredPlacements SponsoredPlacement[]
  wishlistItems       WishlistItem[]
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
}

model Inventory {
  id        String   @id @default(cuid())
  product   Product  @relation(fields: [productId], references: [id])
  productId String   @unique
  quantity  Int
  updatedAt DateTime @updatedAt
}

model Cart {
  id        String     @id @default(cuid())
  user      User?      @relation(fields: [userId], references: [id])
  userId    String?
  anonKey   String?    @unique
  version   Int        @default(0) // For optimistic locking
  items     CartItem[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  @@index([userId])
  @@index([anonKey])
}

model CartItem {
  id        String   @id @default(cuid())
  cart      Cart     @relation(fields: [cartId], references: [id])
  cartId    String
  product   Product  @relation(fields: [productId], references: [id])
  productId String
  qty       Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([cartId, productId])
  @@index([cartId])
  @@index([productId])
}

model Order {
  id          String      @id @default(cuid())
  user        User        @relation(fields: [userId], references: [id])
  userId      String
  total       Decimal     @db.Decimal(12, 2)
  currency    String      @default("USD")
  status      OrderStatus @default(PENDING)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  items       OrderItem[]
  paymentRef  String?
  shippingAdr String?
  payment     Payment?

  // Additional buyer info for fulfillment
  buyerName  String?
  buyerPhone String?
  buyerEmail String?

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

model OrderItem {
  id        String  @id @default(cuid())
  order     Order   @relation(fields: [orderId], references: [id])
  orderId   String
  product   Product @relation(fields: [productId], references: [id])
  productId String
  qty       Int
  price     Decimal @db.Decimal(12, 2)

  // --- SELLER EARNINGS & PAYOUT TRACKING ---
  sellerId      String // denormalized from product.sellerId at purchase time
  grossAmount   Decimal      @db.Decimal(12, 2) // price * qty (snapshot at order time)
  feeAmount     Decimal      @db.Decimal(12, 2) // SokoNova marketplace commission
  netAmount     Decimal      @db.Decimal(12, 2) // grossAmount - feeAmount (what seller receives)
  payoutStatus  PayoutStatus @default(PENDING)
  payoutBatchId String? // group payouts into batches for reconciliation
  paidAt        DateTime? // timestamp when seller was paid
  currency      String       @default("USD")

  // --- FULFILLMENT & SHIPPING TRACKING ---
  fulfillmentStatus FulfillmentStatus @default(PACKED)
  shippedAt         DateTime?
  deliveredAt       DateTime?
  trackingCode      String? // tracking number from carrier
  carrier           String? // DHL, FedEx, UPS, local courier
  deliveryProofUrl  String? // photo of package, signature, receipt
  notes             String? // seller note to buyer (e.g. "left with receptionist")

  // Exception tracking
  exceptionNotified Boolean? @default(false) // whether exception notification was sent

  // --- DISPUTES & REVIEWS ---
  disputes Dispute[]
  reviews  Review[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([sellerId, createdAt]) // For analytics queries
  @@index([payoutStatus])
  @@index([fulfillmentStatus])
}

model Payment {
  id          String        @id @default(cuid())
  order       Order         @relation(fields: [orderId], references: [id])
  orderId     String        @unique
  provider    String // "flutterwave" | "paystack" | "stripe"
  externalRef String? // PSP transaction / checkout ref
  amount      Decimal       @db.Decimal(12, 2)
  currency    String
  status      PaymentStatus @default(INITIATED)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@index([status])
}

// NEW MODEL FOR FULFILLMENT SETTINGS
model FulfillmentSettings {
  id                        String    @id @default(cuid())
  seller                    User      @relation(fields: [sellerId], references: [id])
  sellerId                  String    @unique
  usesMicroFulfillment      Boolean   @default(false)
  microFulfillmentPartnerId String?
  microFulfillmentOptInDate DateTime?
  createdAt                 DateTime  @default(now())
  updatedAt                 DateTime  @updatedAt

  @@index([sellerId])
}

// NEW MODELS FOR TRUST, SAFETY & COMPLIANCE

model KYCDocument {
  id             String    @id @default(cuid())
  seller         User      @relation(fields: [sellerId], references: [id])
  sellerId       String
  documentType   String
  documentNumber String
  documentUrl    String
  country        String
  status         KYCStatus @default(PENDING)
  notes          String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([sellerId])
  @@index([status])
}

enum KYCStatus {
  PENDING
  VERIFIED
  REJECTED
}

model TaxRegistration {
  id         String    @id @default(cuid())
  seller     User      @relation(fields: [sellerId], references: [id])
  sellerId   String
  taxId      String
  country    String
  status     TaxStatus @default(ACTIVE)
  expiryDate DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@index([sellerId])
  @@index([status])
}

enum TaxStatus {
  ACTIVE
  EXPIRED
  PENDING
}

model CounterfeitReport {
  id          String       @id @default(cuid())
  reporter    User         @relation("Reporter", fields: [reporterId], references: [id])
  reporterId  String
  product     Product      @relation("ReportedProduct", fields: [productId], references: [id])
  productId   String
  reason      String
  evidenceUrl String?
  status      ReportStatus @default(PENDING_REVIEW)
  resolution  String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@index([reporterId])
  @@index([productId])
  @@index([status])
}

enum ReportStatus {
  PENDING_REVIEW
  UNDER_INVESTIGATION
  RESOLVED
  DISMISSED
}

enum OrderStatus {
  PENDING
  PAID
  SHIPPED
  DELIVERED
  CANCELLED
}

enum PaymentStatus {
  INITIATED
  SUCCEEDED
  FAILED
}

enum PayoutStatus {
  PENDING
  PAID_OUT
}

enum FulfillmentStatus {
  PACKED // Seller prepared item, ready to ship
  SHIPPED // Handed off to carrier with tracking
  DELIVERED // Buyer received / confirmed delivery
  ISSUE // Dispute, lost, damaged, or other problem
}

model SellerApplication {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id])
  userId String @unique

  businessName   String
  phone          String
  country        String
  city           String
  storefrontDesc String // what they sell / category focus

  // Bank details for payouts
  bankName      String?
  accountNumber String?
  accountName   String?
  bankCode      String? // For routing/SWIFT codes

  status ApplicationStatus @default(PENDING)

  adminNote  String?
  reviewedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@index([status])
}

enum ApplicationStatus {
  PENDING
  APPROVED
  REJECTED
}

model Dispute {
  id          String    @id @default(cuid())
  orderItem   OrderItem @relation(fields: [orderItemId], references: [id])
  orderItemId String
  buyer       User      @relation(fields: [buyerId], references: [id])
  buyerId     String

  reasonCode    DisputeReason // e.g. DAMAGED / NOT_DELIVERED / COUNTERFEIT / OTHER
  description   String // buyer's description
  photoProofUrl String? // optional photo/video link from buyer

  status         DisputeStatus @default(OPEN)
  resolutionNote String?
  resolvedById   String? // admin or seller who closed it
  resolvedAt     DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([buyerId])
  @@index([orderItemId])
  @@index([status])
}

enum DisputeReason {
  NOT_DELIVERED
  DAMAGED
  COUNTERFEIT
  WRONG_ITEM
  OTHER
}

enum DisputeStatus {
  OPEN
  SELLER_RESPONDED
  RESOLVED_BUYER_COMPENSATED
  RESOLVED_REDELIVERED
  REJECTED
}

model Review {
  id          String    @id @default(cuid())
  orderItem   OrderItem @relation(fields: [orderItemId], references: [id])
  orderItemId String

  seller   User   @relation("SellerReviews", fields: [sellerId], references: [id])
  sellerId String

  buyer   User   @relation("BuyerReviews", fields: [buyerId], references: [id])
  buyerId String

  product   Product @relation("ProductReviews", fields: [productId], references: [id])
  productId String

  rating    Int // 1-5
  comment   String
  isVisible Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sellerId, isVisible, createdAt]) // For analytics rating trend
  @@index([orderItemId])
  @@index([productId])
}

model Notification {
  id        String    @id @default(cuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id])
  title     String
  body      String // Changed from 'message' to 'body'
  message   String // Keep for backwards compatibility
  data      Json?
  type      String
  isRead    Boolean   @default(false)
  readAt    DateTime? // When notification was marked as read
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([userId])
  @@index([isRead])
}

model CommunityStory {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  content   String
  imageUrl  String?
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([productId])
  @@index([createdAt])
}

model ProductView {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  timestamp DateTime @default(now())

  @@index([userId])
  @@index([productId])
  @@index([timestamp])
}

model SponsoredPlacement {
  id           String                   @id @default(cuid())
  sellerId     String
  seller       User                     @relation(fields: [sellerId], references: [id])
  productId    String
  product      Product                  @relation(fields: [productId], references: [id])
  categorySlug String?
  searchTerm   String?
  bidAmount    Decimal                  @db.Decimal(12, 2)
  startDate    DateTime
  endDate      DateTime
  status       SponsoredPlacementStatus @default(PENDING)
  createdAt    DateTime                 @default(now())
  updatedAt    DateTime                 @updatedAt

  @@index([categorySlug])
  @@index([searchTerm])
  @@index([startDate, endDate])
  @@index([status])
}

enum SponsoredPlacementStatus {
  PENDING
  ACTIVE
  EXPIRED
  CANCELLED
}

// NEW MODELS FOR SELLER SERVICES MARKETPLACE

model SellerService {
  id           String         @id @default(cuid())
  sellerId     String
  seller       User           @relation(fields: [sellerId], references: [id])
  title        String
  description  String
  price        Decimal        @db.Decimal(12, 2)
  currency     String         @default("USD")
  category     String
  deliveryTime Int // in days
  active       Boolean        @default(true)
  orders       ServiceOrder[]
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  @@index([sellerId])
  @@index([category])
  @@index([active])
}

model ServiceOrder {
  id        String             @id @default(cuid())
  serviceId String
  service   SellerService      @relation(fields: [serviceId], references: [id])
  buyerId   String
  buyer     User               @relation("ServiceOrderBuyer", fields: [buyerId], references: [id])
  sellerId  String
  seller    User               @relation("ServiceOrderSeller", fields: [sellerId], references: [id])
  message   String
  price     Decimal            @db.Decimal(12, 2)
  currency  String             @default("USD")
  status    ServiceOrderStatus @default(PENDING)
  note      String?
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt

  @@index([serviceId])
  @@index([buyerId])
  @@index([sellerId])
  @@index([status])
}

enum ServiceOrderStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// NEW MODELS FOR SUBSCRIPTIONS & MEMBERSHIP LAYERS

model SubscriptionPlan {
  id            String             @id @default(cuid())
  name          String
  description   String
  price         Decimal            @db.Decimal(12, 2)
  currency      String             @default("USD")
  features      String[]
  active        Boolean            @default(true)
  subscriptions UserSubscription[]
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt

  @@index([active])
}

model UserSubscription {
  id            String             @id @default(cuid())
  userId        String
  user          User               @relation(fields: [userId], references: [id])
  planId        String
  plan          SubscriptionPlan   @relation(fields: [planId], references: [id])
  planPrice     Decimal            @db.Decimal(12, 2) // Snapshot of plan price at subscription time
  status        SubscriptionStatus @default(ACTIVE)
  startDate     DateTime
  endDate       DateTime
  autoRenew     Boolean            @default(true)
  paymentMethod String
  cancelledAt   DateTime?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt

  @@index([userId])
  @@index([planId])
  @@index([status])
  @@index([startDate, endDate])
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
}

// NEW MODEL FOR API PARTNER PLATFORM

model ApiPartner {
  id                  String        @id @default(cuid())
  companyName         String
  contactEmail        String        @unique
  apiKeyName          String
  apiKey              String?       @unique
  status              PartnerStatus @default(PENDING)
  permissions         String[]      @default(["read_products"])
  apiKeyLastGenerated DateTime?
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt

  @@index([status])
}

enum PartnerStatus {
  PENDING
  ACTIVE
  SUSPENDED
  REVOKED
}

// ============================================
// Wishlist Model
// ============================================

model WishlistItem {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  productId String
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  addedAt   DateTime @default(now())

  @@unique([userId, productId])
  @@index([userId])
  @@index([productId])
}

// ============================================
// Security & Access Control Models
// ============================================

model Team {
  id          String       @id @default(cuid())
  name        String
  description String?
  createdById String
  createdBy   User         @relation("TeamCreator", fields: [createdById], references: [id])
  members     TeamMember[]
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@index([createdById])
}

model TeamMember {
  id        String   @id @default(cuid())
  teamId    String
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role      String   @default("MEMBER") // OWNER, ADMIN, MEMBER
  invitedBy String?
  joinedAt  DateTime @default(now())

  @@unique([teamId, userId])
  @@index([teamId])
  @@index([userId])
}

model AuditLog {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id])
  action     String // CREATE_TEAM, DELETE_USER, APPROVE_SELLER, etc.
  entityType String // TEAM, USER, SELLER_APPLICATION, etc.
  entityId   String?
  metadata   Json? // Additional context
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())

  @@index([userId])
  @@index([action])
  @@index([entityType])
  @@index([createdAt])
}

// ============================================
// Admin Settings Models
// ============================================

model AdminSettings {
  id        String   @id @default(cuid())
  key       String   @unique // payment, shipping, branding, commissions, loyalty, referral
  value     Json // Settings stored as JSON
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([key])
}

model FlashSale {
  id         String          @id @default(cuid())
  name       String
  startDate  DateTime
  endDate    DateTime
  discount   Int // Percentage discount
  productIds String[] // Array of product IDs included in sale
  status     FlashSaleStatus @default(SCHEDULED)
  revenue    Decimal         @default(0) @db.Decimal(12, 2)
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt

  @@index([status])
  @@index([startDate, endDate])
}

enum FlashSaleStatus {
  SCHEDULED
  ACTIVE
  ENDED
}
