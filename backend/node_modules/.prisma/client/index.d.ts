
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model Cart
 * 
 */
export type Cart = $Result.DefaultSelection<Prisma.$CartPayload>
/**
 * Model CartItem
 * 
 */
export type CartItem = $Result.DefaultSelection<Prisma.$CartItemPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model FulfillmentSettings
 * 
 */
export type FulfillmentSettings = $Result.DefaultSelection<Prisma.$FulfillmentSettingsPayload>
/**
 * Model KYCDocument
 * 
 */
export type KYCDocument = $Result.DefaultSelection<Prisma.$KYCDocumentPayload>
/**
 * Model TaxRegistration
 * 
 */
export type TaxRegistration = $Result.DefaultSelection<Prisma.$TaxRegistrationPayload>
/**
 * Model CounterfeitReport
 * 
 */
export type CounterfeitReport = $Result.DefaultSelection<Prisma.$CounterfeitReportPayload>
/**
 * Model SellerApplication
 * 
 */
export type SellerApplication = $Result.DefaultSelection<Prisma.$SellerApplicationPayload>
/**
 * Model Dispute
 * 
 */
export type Dispute = $Result.DefaultSelection<Prisma.$DisputePayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model CommunityStory
 * 
 */
export type CommunityStory = $Result.DefaultSelection<Prisma.$CommunityStoryPayload>
/**
 * Model ProductView
 * 
 */
export type ProductView = $Result.DefaultSelection<Prisma.$ProductViewPayload>
/**
 * Model SponsoredPlacement
 * 
 */
export type SponsoredPlacement = $Result.DefaultSelection<Prisma.$SponsoredPlacementPayload>
/**
 * Model SellerService
 * 
 */
export type SellerService = $Result.DefaultSelection<Prisma.$SellerServicePayload>
/**
 * Model ServiceOrder
 * 
 */
export type ServiceOrder = $Result.DefaultSelection<Prisma.$ServiceOrderPayload>
/**
 * Model SubscriptionPlan
 * 
 */
export type SubscriptionPlan = $Result.DefaultSelection<Prisma.$SubscriptionPlanPayload>
/**
 * Model UserSubscription
 * 
 */
export type UserSubscription = $Result.DefaultSelection<Prisma.$UserSubscriptionPayload>
/**
 * Model ApiPartner
 * 
 */
export type ApiPartner = $Result.DefaultSelection<Prisma.$ApiPartnerPayload>
/**
 * Model WishlistItem
 * 
 */
export type WishlistItem = $Result.DefaultSelection<Prisma.$WishlistItemPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  BUYER: 'BUYER',
  SELLER: 'SELLER',
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  OPERATOR: 'OPERATOR'
};

export type Role = (typeof Role)[keyof typeof Role]


export const KYCStatus: {
  PENDING: 'PENDING',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED'
};

export type KYCStatus = (typeof KYCStatus)[keyof typeof KYCStatus]


export const TaxStatus: {
  ACTIVE: 'ACTIVE',
  EXPIRED: 'EXPIRED',
  PENDING: 'PENDING'
};

export type TaxStatus = (typeof TaxStatus)[keyof typeof TaxStatus]


export const ReportStatus: {
  PENDING_REVIEW: 'PENDING_REVIEW',
  UNDER_INVESTIGATION: 'UNDER_INVESTIGATION',
  RESOLVED: 'RESOLVED',
  DISMISSED: 'DISMISSED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]


export const OrderStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  SHIPPED: 'SHIPPED',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentStatus: {
  INITIATED: 'INITIATED',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const PayoutStatus: {
  PENDING: 'PENDING',
  PAID_OUT: 'PAID_OUT'
};

export type PayoutStatus = (typeof PayoutStatus)[keyof typeof PayoutStatus]


export const FulfillmentStatus: {
  PACKED: 'PACKED',
  SHIPPED: 'SHIPPED',
  DELIVERED: 'DELIVERED',
  ISSUE: 'ISSUE'
};

export type FulfillmentStatus = (typeof FulfillmentStatus)[keyof typeof FulfillmentStatus]


export const ApplicationStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ApplicationStatus = (typeof ApplicationStatus)[keyof typeof ApplicationStatus]


export const DisputeReason: {
  NOT_DELIVERED: 'NOT_DELIVERED',
  DAMAGED: 'DAMAGED',
  COUNTERFEIT: 'COUNTERFEIT',
  WRONG_ITEM: 'WRONG_ITEM',
  OTHER: 'OTHER'
};

export type DisputeReason = (typeof DisputeReason)[keyof typeof DisputeReason]


export const DisputeStatus: {
  OPEN: 'OPEN',
  SELLER_RESPONDED: 'SELLER_RESPONDED',
  RESOLVED_BUYER_COMPENSATED: 'RESOLVED_BUYER_COMPENSATED',
  RESOLVED_REDELIVERED: 'RESOLVED_REDELIVERED',
  REJECTED: 'REJECTED'
};

export type DisputeStatus = (typeof DisputeStatus)[keyof typeof DisputeStatus]


export const SponsoredPlacementStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  EXPIRED: 'EXPIRED',
  CANCELLED: 'CANCELLED'
};

export type SponsoredPlacementStatus = (typeof SponsoredPlacementStatus)[keyof typeof SponsoredPlacementStatus]


export const ServiceOrderStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type ServiceOrderStatus = (typeof ServiceOrderStatus)[keyof typeof ServiceOrderStatus]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const PartnerStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  REVOKED: 'REVOKED'
};

export type PartnerStatus = (typeof PartnerStatus)[keyof typeof PartnerStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type KYCStatus = $Enums.KYCStatus

export const KYCStatus: typeof $Enums.KYCStatus

export type TaxStatus = $Enums.TaxStatus

export const TaxStatus: typeof $Enums.TaxStatus

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type PayoutStatus = $Enums.PayoutStatus

export const PayoutStatus: typeof $Enums.PayoutStatus

export type FulfillmentStatus = $Enums.FulfillmentStatus

export const FulfillmentStatus: typeof $Enums.FulfillmentStatus

export type ApplicationStatus = $Enums.ApplicationStatus

export const ApplicationStatus: typeof $Enums.ApplicationStatus

export type DisputeReason = $Enums.DisputeReason

export const DisputeReason: typeof $Enums.DisputeReason

export type DisputeStatus = $Enums.DisputeStatus

export const DisputeStatus: typeof $Enums.DisputeStatus

export type SponsoredPlacementStatus = $Enums.SponsoredPlacementStatus

export const SponsoredPlacementStatus: typeof $Enums.SponsoredPlacementStatus

export type ServiceOrderStatus = $Enums.ServiceOrderStatus

export const ServiceOrderStatus: typeof $Enums.ServiceOrderStatus

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type PartnerStatus = $Enums.PartnerStatus

export const PartnerStatus: typeof $Enums.PartnerStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **Cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.cart.findMany()
    * ```
    */
  get cart(): Prisma.CartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cartItem`: Exposes CRUD operations for the **CartItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CartItems
    * const cartItems = await prisma.cartItem.findMany()
    * ```
    */
  get cartItem(): Prisma.CartItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fulfillmentSettings`: Exposes CRUD operations for the **FulfillmentSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FulfillmentSettings
    * const fulfillmentSettings = await prisma.fulfillmentSettings.findMany()
    * ```
    */
  get fulfillmentSettings(): Prisma.FulfillmentSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kYCDocument`: Exposes CRUD operations for the **KYCDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KYCDocuments
    * const kYCDocuments = await prisma.kYCDocument.findMany()
    * ```
    */
  get kYCDocument(): Prisma.KYCDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taxRegistration`: Exposes CRUD operations for the **TaxRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxRegistrations
    * const taxRegistrations = await prisma.taxRegistration.findMany()
    * ```
    */
  get taxRegistration(): Prisma.TaxRegistrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.counterfeitReport`: Exposes CRUD operations for the **CounterfeitReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CounterfeitReports
    * const counterfeitReports = await prisma.counterfeitReport.findMany()
    * ```
    */
  get counterfeitReport(): Prisma.CounterfeitReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sellerApplication`: Exposes CRUD operations for the **SellerApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellerApplications
    * const sellerApplications = await prisma.sellerApplication.findMany()
    * ```
    */
  get sellerApplication(): Prisma.SellerApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dispute`: Exposes CRUD operations for the **Dispute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Disputes
    * const disputes = await prisma.dispute.findMany()
    * ```
    */
  get dispute(): Prisma.DisputeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.communityStory`: Exposes CRUD operations for the **CommunityStory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityStories
    * const communityStories = await prisma.communityStory.findMany()
    * ```
    */
  get communityStory(): Prisma.CommunityStoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productView`: Exposes CRUD operations for the **ProductView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductViews
    * const productViews = await prisma.productView.findMany()
    * ```
    */
  get productView(): Prisma.ProductViewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sponsoredPlacement`: Exposes CRUD operations for the **SponsoredPlacement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SponsoredPlacements
    * const sponsoredPlacements = await prisma.sponsoredPlacement.findMany()
    * ```
    */
  get sponsoredPlacement(): Prisma.SponsoredPlacementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sellerService`: Exposes CRUD operations for the **SellerService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellerServices
    * const sellerServices = await prisma.sellerService.findMany()
    * ```
    */
  get sellerService(): Prisma.SellerServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceOrder`: Exposes CRUD operations for the **ServiceOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceOrders
    * const serviceOrders = await prisma.serviceOrder.findMany()
    * ```
    */
  get serviceOrder(): Prisma.ServiceOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptionPlan`: Exposes CRUD operations for the **SubscriptionPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionPlans
    * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
    * ```
    */
  get subscriptionPlan(): Prisma.SubscriptionPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSubscription`: Exposes CRUD operations for the **UserSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSubscriptions
    * const userSubscriptions = await prisma.userSubscription.findMany()
    * ```
    */
  get userSubscription(): Prisma.UserSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiPartner`: Exposes CRUD operations for the **ApiPartner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiPartners
    * const apiPartners = await prisma.apiPartner.findMany()
    * ```
    */
  get apiPartner(): Prisma.ApiPartnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wishlistItem`: Exposes CRUD operations for the **WishlistItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WishlistItems
    * const wishlistItems = await prisma.wishlistItem.findMany()
    * ```
    */
  get wishlistItem(): Prisma.WishlistItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Product: 'Product',
    Inventory: 'Inventory',
    Cart: 'Cart',
    CartItem: 'CartItem',
    Order: 'Order',
    OrderItem: 'OrderItem',
    Payment: 'Payment',
    FulfillmentSettings: 'FulfillmentSettings',
    KYCDocument: 'KYCDocument',
    TaxRegistration: 'TaxRegistration',
    CounterfeitReport: 'CounterfeitReport',
    SellerApplication: 'SellerApplication',
    Dispute: 'Dispute',
    Review: 'Review',
    Notification: 'Notification',
    CommunityStory: 'CommunityStory',
    ProductView: 'ProductView',
    SponsoredPlacement: 'SponsoredPlacement',
    SellerService: 'SellerService',
    ServiceOrder: 'ServiceOrder',
    SubscriptionPlan: 'SubscriptionPlan',
    UserSubscription: 'UserSubscription',
    ApiPartner: 'ApiPartner',
    WishlistItem: 'WishlistItem',
    Team: 'Team',
    TeamMember: 'TeamMember',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "verificationToken" | "product" | "inventory" | "cart" | "cartItem" | "order" | "orderItem" | "payment" | "fulfillmentSettings" | "kYCDocument" | "taxRegistration" | "counterfeitReport" | "sellerApplication" | "dispute" | "review" | "notification" | "communityStory" | "productView" | "sponsoredPlacement" | "sellerService" | "serviceOrder" | "subscriptionPlan" | "userSubscription" | "apiPartner" | "wishlistItem" | "team" | "teamMember" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      Cart: {
        payload: Prisma.$CartPayload<ExtArgs>
        fields: Prisma.CartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findFirst: {
            args: Prisma.CartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findMany: {
            args: Prisma.CartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          create: {
            args: Prisma.CartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          createMany: {
            args: Prisma.CartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          delete: {
            args: Prisma.CartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          update: {
            args: Prisma.CartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          deleteMany: {
            args: Prisma.CartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          upsert: {
            args: Prisma.CartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCart>
          }
          groupBy: {
            args: Prisma.CartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartCountArgs<ExtArgs>
            result: $Utils.Optional<CartCountAggregateOutputType> | number
          }
        }
      }
      CartItem: {
        payload: Prisma.$CartItemPayload<ExtArgs>
        fields: Prisma.CartItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findFirst: {
            args: Prisma.CartItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findMany: {
            args: Prisma.CartItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          create: {
            args: Prisma.CartItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          createMany: {
            args: Prisma.CartItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          delete: {
            args: Prisma.CartItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          update: {
            args: Prisma.CartItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          deleteMany: {
            args: Prisma.CartItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          upsert: {
            args: Prisma.CartItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          aggregate: {
            args: Prisma.CartItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCartItem>
          }
          groupBy: {
            args: Prisma.CartItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartItemCountArgs<ExtArgs>
            result: $Utils.Optional<CartItemCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      FulfillmentSettings: {
        payload: Prisma.$FulfillmentSettingsPayload<ExtArgs>
        fields: Prisma.FulfillmentSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FulfillmentSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FulfillmentSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentSettingsPayload>
          }
          findFirst: {
            args: Prisma.FulfillmentSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FulfillmentSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentSettingsPayload>
          }
          findMany: {
            args: Prisma.FulfillmentSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentSettingsPayload>[]
          }
          create: {
            args: Prisma.FulfillmentSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentSettingsPayload>
          }
          createMany: {
            args: Prisma.FulfillmentSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FulfillmentSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentSettingsPayload>[]
          }
          delete: {
            args: Prisma.FulfillmentSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentSettingsPayload>
          }
          update: {
            args: Prisma.FulfillmentSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentSettingsPayload>
          }
          deleteMany: {
            args: Prisma.FulfillmentSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FulfillmentSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FulfillmentSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentSettingsPayload>[]
          }
          upsert: {
            args: Prisma.FulfillmentSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentSettingsPayload>
          }
          aggregate: {
            args: Prisma.FulfillmentSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFulfillmentSettings>
          }
          groupBy: {
            args: Prisma.FulfillmentSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FulfillmentSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FulfillmentSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<FulfillmentSettingsCountAggregateOutputType> | number
          }
        }
      }
      KYCDocument: {
        payload: Prisma.$KYCDocumentPayload<ExtArgs>
        fields: Prisma.KYCDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KYCDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KYCDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload>
          }
          findFirst: {
            args: Prisma.KYCDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KYCDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload>
          }
          findMany: {
            args: Prisma.KYCDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload>[]
          }
          create: {
            args: Prisma.KYCDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload>
          }
          createMany: {
            args: Prisma.KYCDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KYCDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload>[]
          }
          delete: {
            args: Prisma.KYCDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload>
          }
          update: {
            args: Prisma.KYCDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload>
          }
          deleteMany: {
            args: Prisma.KYCDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KYCDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KYCDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload>[]
          }
          upsert: {
            args: Prisma.KYCDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCDocumentPayload>
          }
          aggregate: {
            args: Prisma.KYCDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKYCDocument>
          }
          groupBy: {
            args: Prisma.KYCDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<KYCDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.KYCDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<KYCDocumentCountAggregateOutputType> | number
          }
        }
      }
      TaxRegistration: {
        payload: Prisma.$TaxRegistrationPayload<ExtArgs>
        fields: Prisma.TaxRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRegistrationPayload>
          }
          findFirst: {
            args: Prisma.TaxRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRegistrationPayload>
          }
          findMany: {
            args: Prisma.TaxRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRegistrationPayload>[]
          }
          create: {
            args: Prisma.TaxRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRegistrationPayload>
          }
          createMany: {
            args: Prisma.TaxRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxRegistrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRegistrationPayload>[]
          }
          delete: {
            args: Prisma.TaxRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRegistrationPayload>
          }
          update: {
            args: Prisma.TaxRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.TaxRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaxRegistrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRegistrationPayload>[]
          }
          upsert: {
            args: Prisma.TaxRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRegistrationPayload>
          }
          aggregate: {
            args: Prisma.TaxRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxRegistration>
          }
          groupBy: {
            args: Prisma.TaxRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<TaxRegistrationCountAggregateOutputType> | number
          }
        }
      }
      CounterfeitReport: {
        payload: Prisma.$CounterfeitReportPayload<ExtArgs>
        fields: Prisma.CounterfeitReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CounterfeitReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterfeitReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CounterfeitReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterfeitReportPayload>
          }
          findFirst: {
            args: Prisma.CounterfeitReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterfeitReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CounterfeitReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterfeitReportPayload>
          }
          findMany: {
            args: Prisma.CounterfeitReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterfeitReportPayload>[]
          }
          create: {
            args: Prisma.CounterfeitReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterfeitReportPayload>
          }
          createMany: {
            args: Prisma.CounterfeitReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CounterfeitReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterfeitReportPayload>[]
          }
          delete: {
            args: Prisma.CounterfeitReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterfeitReportPayload>
          }
          update: {
            args: Prisma.CounterfeitReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterfeitReportPayload>
          }
          deleteMany: {
            args: Prisma.CounterfeitReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CounterfeitReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CounterfeitReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterfeitReportPayload>[]
          }
          upsert: {
            args: Prisma.CounterfeitReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterfeitReportPayload>
          }
          aggregate: {
            args: Prisma.CounterfeitReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCounterfeitReport>
          }
          groupBy: {
            args: Prisma.CounterfeitReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<CounterfeitReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.CounterfeitReportCountArgs<ExtArgs>
            result: $Utils.Optional<CounterfeitReportCountAggregateOutputType> | number
          }
        }
      }
      SellerApplication: {
        payload: Prisma.$SellerApplicationPayload<ExtArgs>
        fields: Prisma.SellerApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellerApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellerApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerApplicationPayload>
          }
          findFirst: {
            args: Prisma.SellerApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellerApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerApplicationPayload>
          }
          findMany: {
            args: Prisma.SellerApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerApplicationPayload>[]
          }
          create: {
            args: Prisma.SellerApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerApplicationPayload>
          }
          createMany: {
            args: Prisma.SellerApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SellerApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerApplicationPayload>[]
          }
          delete: {
            args: Prisma.SellerApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerApplicationPayload>
          }
          update: {
            args: Prisma.SellerApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerApplicationPayload>
          }
          deleteMany: {
            args: Prisma.SellerApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellerApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SellerApplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerApplicationPayload>[]
          }
          upsert: {
            args: Prisma.SellerApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerApplicationPayload>
          }
          aggregate: {
            args: Prisma.SellerApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellerApplication>
          }
          groupBy: {
            args: Prisma.SellerApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellerApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellerApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<SellerApplicationCountAggregateOutputType> | number
          }
        }
      }
      Dispute: {
        payload: Prisma.$DisputePayload<ExtArgs>
        fields: Prisma.DisputeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisputeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisputeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          findFirst: {
            args: Prisma.DisputeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisputeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          findMany: {
            args: Prisma.DisputeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>[]
          }
          create: {
            args: Prisma.DisputeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          createMany: {
            args: Prisma.DisputeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisputeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>[]
          }
          delete: {
            args: Prisma.DisputeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          update: {
            args: Prisma.DisputeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          deleteMany: {
            args: Prisma.DisputeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisputeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DisputeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>[]
          }
          upsert: {
            args: Prisma.DisputeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          aggregate: {
            args: Prisma.DisputeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDispute>
          }
          groupBy: {
            args: Prisma.DisputeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisputeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisputeCountArgs<ExtArgs>
            result: $Utils.Optional<DisputeCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      CommunityStory: {
        payload: Prisma.$CommunityStoryPayload<ExtArgs>
        fields: Prisma.CommunityStoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityStoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityStoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityStoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityStoryPayload>
          }
          findFirst: {
            args: Prisma.CommunityStoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityStoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityStoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityStoryPayload>
          }
          findMany: {
            args: Prisma.CommunityStoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityStoryPayload>[]
          }
          create: {
            args: Prisma.CommunityStoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityStoryPayload>
          }
          createMany: {
            args: Prisma.CommunityStoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunityStoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityStoryPayload>[]
          }
          delete: {
            args: Prisma.CommunityStoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityStoryPayload>
          }
          update: {
            args: Prisma.CommunityStoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityStoryPayload>
          }
          deleteMany: {
            args: Prisma.CommunityStoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityStoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommunityStoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityStoryPayload>[]
          }
          upsert: {
            args: Prisma.CommunityStoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityStoryPayload>
          }
          aggregate: {
            args: Prisma.CommunityStoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunityStory>
          }
          groupBy: {
            args: Prisma.CommunityStoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityStoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityStoryCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityStoryCountAggregateOutputType> | number
          }
        }
      }
      ProductView: {
        payload: Prisma.$ProductViewPayload<ExtArgs>
        fields: Prisma.ProductViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload>
          }
          findFirst: {
            args: Prisma.ProductViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload>
          }
          findMany: {
            args: Prisma.ProductViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload>[]
          }
          create: {
            args: Prisma.ProductViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload>
          }
          createMany: {
            args: Prisma.ProductViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload>[]
          }
          delete: {
            args: Prisma.ProductViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload>
          }
          update: {
            args: Prisma.ProductViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload>
          }
          deleteMany: {
            args: Prisma.ProductViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductViewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload>[]
          }
          upsert: {
            args: Prisma.ProductViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload>
          }
          aggregate: {
            args: Prisma.ProductViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductView>
          }
          groupBy: {
            args: Prisma.ProductViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductViewCountArgs<ExtArgs>
            result: $Utils.Optional<ProductViewCountAggregateOutputType> | number
          }
        }
      }
      SponsoredPlacement: {
        payload: Prisma.$SponsoredPlacementPayload<ExtArgs>
        fields: Prisma.SponsoredPlacementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SponsoredPlacementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsoredPlacementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SponsoredPlacementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsoredPlacementPayload>
          }
          findFirst: {
            args: Prisma.SponsoredPlacementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsoredPlacementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SponsoredPlacementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsoredPlacementPayload>
          }
          findMany: {
            args: Prisma.SponsoredPlacementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsoredPlacementPayload>[]
          }
          create: {
            args: Prisma.SponsoredPlacementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsoredPlacementPayload>
          }
          createMany: {
            args: Prisma.SponsoredPlacementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SponsoredPlacementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsoredPlacementPayload>[]
          }
          delete: {
            args: Prisma.SponsoredPlacementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsoredPlacementPayload>
          }
          update: {
            args: Prisma.SponsoredPlacementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsoredPlacementPayload>
          }
          deleteMany: {
            args: Prisma.SponsoredPlacementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SponsoredPlacementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SponsoredPlacementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsoredPlacementPayload>[]
          }
          upsert: {
            args: Prisma.SponsoredPlacementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsoredPlacementPayload>
          }
          aggregate: {
            args: Prisma.SponsoredPlacementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSponsoredPlacement>
          }
          groupBy: {
            args: Prisma.SponsoredPlacementGroupByArgs<ExtArgs>
            result: $Utils.Optional<SponsoredPlacementGroupByOutputType>[]
          }
          count: {
            args: Prisma.SponsoredPlacementCountArgs<ExtArgs>
            result: $Utils.Optional<SponsoredPlacementCountAggregateOutputType> | number
          }
        }
      }
      SellerService: {
        payload: Prisma.$SellerServicePayload<ExtArgs>
        fields: Prisma.SellerServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellerServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellerServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerServicePayload>
          }
          findFirst: {
            args: Prisma.SellerServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellerServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerServicePayload>
          }
          findMany: {
            args: Prisma.SellerServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerServicePayload>[]
          }
          create: {
            args: Prisma.SellerServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerServicePayload>
          }
          createMany: {
            args: Prisma.SellerServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SellerServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerServicePayload>[]
          }
          delete: {
            args: Prisma.SellerServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerServicePayload>
          }
          update: {
            args: Prisma.SellerServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerServicePayload>
          }
          deleteMany: {
            args: Prisma.SellerServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellerServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SellerServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerServicePayload>[]
          }
          upsert: {
            args: Prisma.SellerServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerServicePayload>
          }
          aggregate: {
            args: Prisma.SellerServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellerService>
          }
          groupBy: {
            args: Prisma.SellerServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellerServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellerServiceCountArgs<ExtArgs>
            result: $Utils.Optional<SellerServiceCountAggregateOutputType> | number
          }
        }
      }
      ServiceOrder: {
        payload: Prisma.$ServiceOrderPayload<ExtArgs>
        fields: Prisma.ServiceOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload>
          }
          findFirst: {
            args: Prisma.ServiceOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload>
          }
          findMany: {
            args: Prisma.ServiceOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload>[]
          }
          create: {
            args: Prisma.ServiceOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload>
          }
          createMany: {
            args: Prisma.ServiceOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload>[]
          }
          delete: {
            args: Prisma.ServiceOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload>
          }
          update: {
            args: Prisma.ServiceOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload>
          }
          deleteMany: {
            args: Prisma.ServiceOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload>[]
          }
          upsert: {
            args: Prisma.ServiceOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload>
          }
          aggregate: {
            args: Prisma.ServiceOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceOrder>
          }
          groupBy: {
            args: Prisma.ServiceOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceOrderCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceOrderCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionPlan: {
        payload: Prisma.$SubscriptionPlanPayload<ExtArgs>
        fields: Prisma.SubscriptionPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findMany: {
            args: Prisma.SubscriptionPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          create: {
            args: Prisma.SubscriptionPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          createMany: {
            args: Prisma.SubscriptionPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          update: {
            args: Prisma.SubscriptionPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionPlan>
          }
          groupBy: {
            args: Prisma.SubscriptionPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionPlanCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanCountAggregateOutputType> | number
          }
        }
      }
      UserSubscription: {
        payload: Prisma.$UserSubscriptionPayload<ExtArgs>
        fields: Prisma.UserSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.UserSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          findMany: {
            args: Prisma.UserSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          create: {
            args: Prisma.UserSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          createMany: {
            args: Prisma.UserSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.UserSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          update: {
            args: Prisma.UserSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.UserSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.UserSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.UserSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSubscription>
          }
          groupBy: {
            args: Prisma.UserSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      ApiPartner: {
        payload: Prisma.$ApiPartnerPayload<ExtArgs>
        fields: Prisma.ApiPartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiPartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiPartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiPartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiPartnerPayload>
          }
          findFirst: {
            args: Prisma.ApiPartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiPartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiPartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiPartnerPayload>
          }
          findMany: {
            args: Prisma.ApiPartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiPartnerPayload>[]
          }
          create: {
            args: Prisma.ApiPartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiPartnerPayload>
          }
          createMany: {
            args: Prisma.ApiPartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiPartnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiPartnerPayload>[]
          }
          delete: {
            args: Prisma.ApiPartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiPartnerPayload>
          }
          update: {
            args: Prisma.ApiPartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiPartnerPayload>
          }
          deleteMany: {
            args: Prisma.ApiPartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiPartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiPartnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiPartnerPayload>[]
          }
          upsert: {
            args: Prisma.ApiPartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiPartnerPayload>
          }
          aggregate: {
            args: Prisma.ApiPartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiPartner>
          }
          groupBy: {
            args: Prisma.ApiPartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiPartnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiPartnerCountArgs<ExtArgs>
            result: $Utils.Optional<ApiPartnerCountAggregateOutputType> | number
          }
        }
      }
      WishlistItem: {
        payload: Prisma.$WishlistItemPayload<ExtArgs>
        fields: Prisma.WishlistItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WishlistItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WishlistItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          findFirst: {
            args: Prisma.WishlistItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WishlistItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          findMany: {
            args: Prisma.WishlistItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>[]
          }
          create: {
            args: Prisma.WishlistItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          createMany: {
            args: Prisma.WishlistItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WishlistItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>[]
          }
          delete: {
            args: Prisma.WishlistItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          update: {
            args: Prisma.WishlistItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          deleteMany: {
            args: Prisma.WishlistItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WishlistItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WishlistItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>[]
          }
          upsert: {
            args: Prisma.WishlistItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          aggregate: {
            args: Prisma.WishlistItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWishlistItem>
          }
          groupBy: {
            args: Prisma.WishlistItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<WishlistItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.WishlistItemCountArgs<ExtArgs>
            result: $Utils.Optional<WishlistItemCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    product?: ProductOmit
    inventory?: InventoryOmit
    cart?: CartOmit
    cartItem?: CartItemOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    payment?: PaymentOmit
    fulfillmentSettings?: FulfillmentSettingsOmit
    kYCDocument?: KYCDocumentOmit
    taxRegistration?: TaxRegistrationOmit
    counterfeitReport?: CounterfeitReportOmit
    sellerApplication?: SellerApplicationOmit
    dispute?: DisputeOmit
    review?: ReviewOmit
    notification?: NotificationOmit
    communityStory?: CommunityStoryOmit
    productView?: ProductViewOmit
    sponsoredPlacement?: SponsoredPlacementOmit
    sellerService?: SellerServiceOmit
    serviceOrder?: ServiceOrderOmit
    subscriptionPlan?: SubscriptionPlanOmit
    userSubscription?: UserSubscriptionOmit
    apiPartner?: ApiPartnerOmit
    wishlistItem?: WishlistItemOmit
    team?: TeamOmit
    teamMember?: TeamMemberOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    carts: number
    orders: number
    products: number
    sessions: number
    accounts: number
    reviews: number
    notifications: number
    stories: number
    sellerReviews: number
    reportedProducts: number
    sellerApplications: number
    disputes: number
    fulfillmentSettings: number
    kycDocuments: number
    taxRegistrations: number
    productViews: number
    sponsoredPlacements: number
    serviceOrdersAsBuyer: number
    serviceOrdersAsSeller: number
    sellerServices: number
    subscriptions: number
    wishlistItems: number
    createdTeams: number
    teamMemberships: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carts?: boolean | UserCountOutputTypeCountCartsArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    products?: boolean | UserCountOutputTypeCountProductsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    stories?: boolean | UserCountOutputTypeCountStoriesArgs
    sellerReviews?: boolean | UserCountOutputTypeCountSellerReviewsArgs
    reportedProducts?: boolean | UserCountOutputTypeCountReportedProductsArgs
    sellerApplications?: boolean | UserCountOutputTypeCountSellerApplicationsArgs
    disputes?: boolean | UserCountOutputTypeCountDisputesArgs
    fulfillmentSettings?: boolean | UserCountOutputTypeCountFulfillmentSettingsArgs
    kycDocuments?: boolean | UserCountOutputTypeCountKycDocumentsArgs
    taxRegistrations?: boolean | UserCountOutputTypeCountTaxRegistrationsArgs
    productViews?: boolean | UserCountOutputTypeCountProductViewsArgs
    sponsoredPlacements?: boolean | UserCountOutputTypeCountSponsoredPlacementsArgs
    serviceOrdersAsBuyer?: boolean | UserCountOutputTypeCountServiceOrdersAsBuyerArgs
    serviceOrdersAsSeller?: boolean | UserCountOutputTypeCountServiceOrdersAsSellerArgs
    sellerServices?: boolean | UserCountOutputTypeCountSellerServicesArgs
    subscriptions?: boolean | UserCountOutputTypeCountSubscriptionsArgs
    wishlistItems?: boolean | UserCountOutputTypeCountWishlistItemsArgs
    createdTeams?: boolean | UserCountOutputTypeCountCreatedTeamsArgs
    teamMemberships?: boolean | UserCountOutputTypeCountTeamMembershipsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityStoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSellerReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportedProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CounterfeitReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSellerApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellerApplicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDisputesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisputeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFulfillmentSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FulfillmentSettingsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountKycDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KYCDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaxRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxRegistrationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductViewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSponsoredPlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SponsoredPlacementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServiceOrdersAsBuyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServiceOrdersAsSellerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSellerServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellerServiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWishlistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    views: number
    cartItems: number
    orderItems: number
    productReviews: number
    stories: number
    reportedIn: number
    sponsoredPlacements: number
    wishlistItems: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    views?: boolean | ProductCountOutputTypeCountViewsArgs
    cartItems?: boolean | ProductCountOutputTypeCountCartItemsArgs
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    productReviews?: boolean | ProductCountOutputTypeCountProductReviewsArgs
    stories?: boolean | ProductCountOutputTypeCountStoriesArgs
    reportedIn?: boolean | ProductCountOutputTypeCountReportedInArgs
    sponsoredPlacements?: boolean | ProductCountOutputTypeCountSponsoredPlacementsArgs
    wishlistItems?: boolean | ProductCountOutputTypeCountWishlistItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductViewWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityStoryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountReportedInArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CounterfeitReportWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSponsoredPlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SponsoredPlacementWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountWishlistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput
  }


  /**
   * Count Type CartCountOutputType
   */

  export type CartCountOutputType = {
    items: number
  }

  export type CartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | CartCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartCountOutputType
     */
    select?: CartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type OrderItemCountOutputType
   */

  export type OrderItemCountOutputType = {
    disputes: number
    reviews: number
  }

  export type OrderItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disputes?: boolean | OrderItemCountOutputTypeCountDisputesArgs
    reviews?: boolean | OrderItemCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemCountOutputType
     */
    select?: OrderItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeCountDisputesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisputeWhereInput
  }

  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type SellerServiceCountOutputType
   */

  export type SellerServiceCountOutputType = {
    orders: number
  }

  export type SellerServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | SellerServiceCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * SellerServiceCountOutputType without action
   */
  export type SellerServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerServiceCountOutputType
     */
    select?: SellerServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SellerServiceCountOutputType without action
   */
  export type SellerServiceCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceOrderWhereInput
  }


  /**
   * Count Type SubscriptionPlanCountOutputType
   */

  export type SubscriptionPlanCountOutputType = {
    subscriptions: number
  }

  export type SubscriptionPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlanCountOutputType
     */
    select?: SubscriptionPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubscriptionWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    members: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | TeamCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    ratingAvg: number | null
    ratingCount: number | null
    quietHoursStart: number | null
    quietHoursEnd: number | null
  }

  export type UserSumAggregateOutputType = {
    ratingAvg: number | null
    ratingCount: number | null
    quietHoursStart: number | null
    quietHoursEnd: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: string | null
    city: string | null
    country: string | null
    phone: string | null
    sellerHandle: string | null
    shopName: string | null
    shopLogoUrl: string | null
    shopBannerUrl: string | null
    shopBio: string | null
    ratingAvg: number | null
    ratingCount: number | null
    bio: string | null
    notifyEmail: boolean | null
    notifySms: boolean | null
    notifyPush: boolean | null
    timezone: string | null
    quietHoursStart: number | null
    quietHoursEnd: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: string | null
    city: string | null
    country: string | null
    phone: string | null
    sellerHandle: string | null
    shopName: string | null
    shopLogoUrl: string | null
    shopBannerUrl: string | null
    shopBio: string | null
    ratingAvg: number | null
    ratingCount: number | null
    bio: string | null
    notifyEmail: boolean | null
    notifySms: boolean | null
    notifyPush: boolean | null
    timezone: string | null
    quietHoursStart: number | null
    quietHoursEnd: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    city: number
    country: number
    phone: number
    sellerHandle: number
    shopName: number
    shopLogoUrl: number
    shopBannerUrl: number
    shopBio: number
    ratingAvg: number
    ratingCount: number
    bio: number
    notifyEmail: number
    notifySms: number
    notifyPush: number
    timezone: number
    quietHoursStart: number
    quietHoursEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    ratingAvg?: true
    ratingCount?: true
    quietHoursStart?: true
    quietHoursEnd?: true
  }

  export type UserSumAggregateInputType = {
    ratingAvg?: true
    ratingCount?: true
    quietHoursStart?: true
    quietHoursEnd?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    city?: true
    country?: true
    phone?: true
    sellerHandle?: true
    shopName?: true
    shopLogoUrl?: true
    shopBannerUrl?: true
    shopBio?: true
    ratingAvg?: true
    ratingCount?: true
    bio?: true
    notifyEmail?: true
    notifySms?: true
    notifyPush?: true
    timezone?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    city?: true
    country?: true
    phone?: true
    sellerHandle?: true
    shopName?: true
    shopLogoUrl?: true
    shopBannerUrl?: true
    shopBio?: true
    ratingAvg?: true
    ratingCount?: true
    bio?: true
    notifyEmail?: true
    notifySms?: true
    notifyPush?: true
    timezone?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    city?: true
    country?: true
    phone?: true
    sellerHandle?: true
    shopName?: true
    shopLogoUrl?: true
    shopBannerUrl?: true
    shopBio?: true
    ratingAvg?: true
    ratingCount?: true
    bio?: true
    notifyEmail?: true
    notifySms?: true
    notifyPush?: true
    timezone?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string | null
    name: string | null
    role: string
    city: string | null
    country: string | null
    phone: string | null
    sellerHandle: string | null
    shopName: string | null
    shopLogoUrl: string | null
    shopBannerUrl: string | null
    shopBio: string | null
    ratingAvg: number | null
    ratingCount: number | null
    bio: string | null
    notifyEmail: boolean
    notifySms: boolean
    notifyPush: boolean
    timezone: string | null
    quietHoursStart: number | null
    quietHoursEnd: number | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    city?: boolean
    country?: boolean
    phone?: boolean
    sellerHandle?: boolean
    shopName?: boolean
    shopLogoUrl?: boolean
    shopBannerUrl?: boolean
    shopBio?: boolean
    ratingAvg?: boolean
    ratingCount?: boolean
    bio?: boolean
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    carts?: boolean | User$cartsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    products?: boolean | User$productsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    stories?: boolean | User$storiesArgs<ExtArgs>
    sellerReviews?: boolean | User$sellerReviewsArgs<ExtArgs>
    reportedProducts?: boolean | User$reportedProductsArgs<ExtArgs>
    sellerApplications?: boolean | User$sellerApplicationsArgs<ExtArgs>
    disputes?: boolean | User$disputesArgs<ExtArgs>
    fulfillmentSettings?: boolean | User$fulfillmentSettingsArgs<ExtArgs>
    kycDocuments?: boolean | User$kycDocumentsArgs<ExtArgs>
    taxRegistrations?: boolean | User$taxRegistrationsArgs<ExtArgs>
    productViews?: boolean | User$productViewsArgs<ExtArgs>
    sponsoredPlacements?: boolean | User$sponsoredPlacementsArgs<ExtArgs>
    serviceOrdersAsBuyer?: boolean | User$serviceOrdersAsBuyerArgs<ExtArgs>
    serviceOrdersAsSeller?: boolean | User$serviceOrdersAsSellerArgs<ExtArgs>
    sellerServices?: boolean | User$sellerServicesArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    wishlistItems?: boolean | User$wishlistItemsArgs<ExtArgs>
    createdTeams?: boolean | User$createdTeamsArgs<ExtArgs>
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    city?: boolean
    country?: boolean
    phone?: boolean
    sellerHandle?: boolean
    shopName?: boolean
    shopLogoUrl?: boolean
    shopBannerUrl?: boolean
    shopBio?: boolean
    ratingAvg?: boolean
    ratingCount?: boolean
    bio?: boolean
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    city?: boolean
    country?: boolean
    phone?: boolean
    sellerHandle?: boolean
    shopName?: boolean
    shopLogoUrl?: boolean
    shopBannerUrl?: boolean
    shopBio?: boolean
    ratingAvg?: boolean
    ratingCount?: boolean
    bio?: boolean
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    city?: boolean
    country?: boolean
    phone?: boolean
    sellerHandle?: boolean
    shopName?: boolean
    shopLogoUrl?: boolean
    shopBannerUrl?: boolean
    shopBio?: boolean
    ratingAvg?: boolean
    ratingCount?: boolean
    bio?: boolean
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "role" | "city" | "country" | "phone" | "sellerHandle" | "shopName" | "shopLogoUrl" | "shopBannerUrl" | "shopBio" | "ratingAvg" | "ratingCount" | "bio" | "notifyEmail" | "notifySms" | "notifyPush" | "timezone" | "quietHoursStart" | "quietHoursEnd" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carts?: boolean | User$cartsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    products?: boolean | User$productsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    stories?: boolean | User$storiesArgs<ExtArgs>
    sellerReviews?: boolean | User$sellerReviewsArgs<ExtArgs>
    reportedProducts?: boolean | User$reportedProductsArgs<ExtArgs>
    sellerApplications?: boolean | User$sellerApplicationsArgs<ExtArgs>
    disputes?: boolean | User$disputesArgs<ExtArgs>
    fulfillmentSettings?: boolean | User$fulfillmentSettingsArgs<ExtArgs>
    kycDocuments?: boolean | User$kycDocumentsArgs<ExtArgs>
    taxRegistrations?: boolean | User$taxRegistrationsArgs<ExtArgs>
    productViews?: boolean | User$productViewsArgs<ExtArgs>
    sponsoredPlacements?: boolean | User$sponsoredPlacementsArgs<ExtArgs>
    serviceOrdersAsBuyer?: boolean | User$serviceOrdersAsBuyerArgs<ExtArgs>
    serviceOrdersAsSeller?: boolean | User$serviceOrdersAsSellerArgs<ExtArgs>
    sellerServices?: boolean | User$sellerServicesArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    wishlistItems?: boolean | User$wishlistItemsArgs<ExtArgs>
    createdTeams?: boolean | User$createdTeamsArgs<ExtArgs>
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      carts: Prisma.$CartPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      stories: Prisma.$CommunityStoryPayload<ExtArgs>[]
      sellerReviews: Prisma.$ReviewPayload<ExtArgs>[]
      reportedProducts: Prisma.$CounterfeitReportPayload<ExtArgs>[]
      sellerApplications: Prisma.$SellerApplicationPayload<ExtArgs>[]
      disputes: Prisma.$DisputePayload<ExtArgs>[]
      fulfillmentSettings: Prisma.$FulfillmentSettingsPayload<ExtArgs>[]
      kycDocuments: Prisma.$KYCDocumentPayload<ExtArgs>[]
      taxRegistrations: Prisma.$TaxRegistrationPayload<ExtArgs>[]
      productViews: Prisma.$ProductViewPayload<ExtArgs>[]
      sponsoredPlacements: Prisma.$SponsoredPlacementPayload<ExtArgs>[]
      serviceOrdersAsBuyer: Prisma.$ServiceOrderPayload<ExtArgs>[]
      serviceOrdersAsSeller: Prisma.$ServiceOrderPayload<ExtArgs>[]
      sellerServices: Prisma.$SellerServicePayload<ExtArgs>[]
      subscriptions: Prisma.$UserSubscriptionPayload<ExtArgs>[]
      wishlistItems: Prisma.$WishlistItemPayload<ExtArgs>[]
      createdTeams: Prisma.$TeamPayload<ExtArgs>[]
      teamMemberships: Prisma.$TeamMemberPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string | null
      name: string | null
      role: string
      city: string | null
      country: string | null
      phone: string | null
      sellerHandle: string | null
      shopName: string | null
      shopLogoUrl: string | null
      shopBannerUrl: string | null
      shopBio: string | null
      ratingAvg: number | null
      ratingCount: number | null
      bio: string | null
      notifyEmail: boolean
      notifySms: boolean
      notifyPush: boolean
      timezone: string | null
      quietHoursStart: number | null
      quietHoursEnd: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    carts<T extends User$cartsArgs<ExtArgs> = {}>(args?: Subset<T, User$cartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends User$productsArgs<ExtArgs> = {}>(args?: Subset<T, User$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stories<T extends User$storiesArgs<ExtArgs> = {}>(args?: Subset<T, User$storiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sellerReviews<T extends User$sellerReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$sellerReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportedProducts<T extends User$reportedProductsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportedProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CounterfeitReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sellerApplications<T extends User$sellerApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$sellerApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disputes<T extends User$disputesArgs<ExtArgs> = {}>(args?: Subset<T, User$disputesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fulfillmentSettings<T extends User$fulfillmentSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$fulfillmentSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FulfillmentSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kycDocuments<T extends User$kycDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$kycDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taxRegistrations<T extends User$taxRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, User$taxRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productViews<T extends User$productViewsArgs<ExtArgs> = {}>(args?: Subset<T, User$productViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sponsoredPlacements<T extends User$sponsoredPlacementsArgs<ExtArgs> = {}>(args?: Subset<T, User$sponsoredPlacementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsoredPlacementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceOrdersAsBuyer<T extends User$serviceOrdersAsBuyerArgs<ExtArgs> = {}>(args?: Subset<T, User$serviceOrdersAsBuyerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceOrdersAsSeller<T extends User$serviceOrdersAsSellerArgs<ExtArgs> = {}>(args?: Subset<T, User$serviceOrdersAsSellerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sellerServices<T extends User$sellerServicesArgs<ExtArgs> = {}>(args?: Subset<T, User$sellerServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends User$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wishlistItems<T extends User$wishlistItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$wishlistItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdTeams<T extends User$createdTeamsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTeamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamMemberships<T extends User$teamMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly sellerHandle: FieldRef<"User", 'String'>
    readonly shopName: FieldRef<"User", 'String'>
    readonly shopLogoUrl: FieldRef<"User", 'String'>
    readonly shopBannerUrl: FieldRef<"User", 'String'>
    readonly shopBio: FieldRef<"User", 'String'>
    readonly ratingAvg: FieldRef<"User", 'Float'>
    readonly ratingCount: FieldRef<"User", 'Int'>
    readonly bio: FieldRef<"User", 'String'>
    readonly notifyEmail: FieldRef<"User", 'Boolean'>
    readonly notifySms: FieldRef<"User", 'Boolean'>
    readonly notifyPush: FieldRef<"User", 'Boolean'>
    readonly timezone: FieldRef<"User", 'String'>
    readonly quietHoursStart: FieldRef<"User", 'Int'>
    readonly quietHoursEnd: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.carts
   */
  export type User$cartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    where?: CartWhereInput
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    cursor?: CartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.products
   */
  export type User$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.stories
   */
  export type User$storiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityStory
     */
    select?: CommunityStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityStory
     */
    omit?: CommunityStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityStoryInclude<ExtArgs> | null
    where?: CommunityStoryWhereInput
    orderBy?: CommunityStoryOrderByWithRelationInput | CommunityStoryOrderByWithRelationInput[]
    cursor?: CommunityStoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityStoryScalarFieldEnum | CommunityStoryScalarFieldEnum[]
  }

  /**
   * User.sellerReviews
   */
  export type User$sellerReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.reportedProducts
   */
  export type User$reportedProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterfeitReport
     */
    select?: CounterfeitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CounterfeitReport
     */
    omit?: CounterfeitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterfeitReportInclude<ExtArgs> | null
    where?: CounterfeitReportWhereInput
    orderBy?: CounterfeitReportOrderByWithRelationInput | CounterfeitReportOrderByWithRelationInput[]
    cursor?: CounterfeitReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CounterfeitReportScalarFieldEnum | CounterfeitReportScalarFieldEnum[]
  }

  /**
   * User.sellerApplications
   */
  export type User$sellerApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerApplication
     */
    select?: SellerApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerApplication
     */
    omit?: SellerApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerApplicationInclude<ExtArgs> | null
    where?: SellerApplicationWhereInput
    orderBy?: SellerApplicationOrderByWithRelationInput | SellerApplicationOrderByWithRelationInput[]
    cursor?: SellerApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellerApplicationScalarFieldEnum | SellerApplicationScalarFieldEnum[]
  }

  /**
   * User.disputes
   */
  export type User$disputesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    where?: DisputeWhereInput
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    cursor?: DisputeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisputeScalarFieldEnum | DisputeScalarFieldEnum[]
  }

  /**
   * User.fulfillmentSettings
   */
  export type User$fulfillmentSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentSettings
     */
    select?: FulfillmentSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentSettings
     */
    omit?: FulfillmentSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentSettingsInclude<ExtArgs> | null
    where?: FulfillmentSettingsWhereInput
    orderBy?: FulfillmentSettingsOrderByWithRelationInput | FulfillmentSettingsOrderByWithRelationInput[]
    cursor?: FulfillmentSettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FulfillmentSettingsScalarFieldEnum | FulfillmentSettingsScalarFieldEnum[]
  }

  /**
   * User.kycDocuments
   */
  export type User$kycDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    where?: KYCDocumentWhereInput
    orderBy?: KYCDocumentOrderByWithRelationInput | KYCDocumentOrderByWithRelationInput[]
    cursor?: KYCDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KYCDocumentScalarFieldEnum | KYCDocumentScalarFieldEnum[]
  }

  /**
   * User.taxRegistrations
   */
  export type User$taxRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRegistration
     */
    select?: TaxRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRegistration
     */
    omit?: TaxRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRegistrationInclude<ExtArgs> | null
    where?: TaxRegistrationWhereInput
    orderBy?: TaxRegistrationOrderByWithRelationInput | TaxRegistrationOrderByWithRelationInput[]
    cursor?: TaxRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaxRegistrationScalarFieldEnum | TaxRegistrationScalarFieldEnum[]
  }

  /**
   * User.productViews
   */
  export type User$productViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductView
     */
    omit?: ProductViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    where?: ProductViewWhereInput
    orderBy?: ProductViewOrderByWithRelationInput | ProductViewOrderByWithRelationInput[]
    cursor?: ProductViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductViewScalarFieldEnum | ProductViewScalarFieldEnum[]
  }

  /**
   * User.sponsoredPlacements
   */
  export type User$sponsoredPlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsoredPlacement
     */
    select?: SponsoredPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsoredPlacement
     */
    omit?: SponsoredPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsoredPlacementInclude<ExtArgs> | null
    where?: SponsoredPlacementWhereInput
    orderBy?: SponsoredPlacementOrderByWithRelationInput | SponsoredPlacementOrderByWithRelationInput[]
    cursor?: SponsoredPlacementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SponsoredPlacementScalarFieldEnum | SponsoredPlacementScalarFieldEnum[]
  }

  /**
   * User.serviceOrdersAsBuyer
   */
  export type User$serviceOrdersAsBuyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    where?: ServiceOrderWhereInput
    orderBy?: ServiceOrderOrderByWithRelationInput | ServiceOrderOrderByWithRelationInput[]
    cursor?: ServiceOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceOrderScalarFieldEnum | ServiceOrderScalarFieldEnum[]
  }

  /**
   * User.serviceOrdersAsSeller
   */
  export type User$serviceOrdersAsSellerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    where?: ServiceOrderWhereInput
    orderBy?: ServiceOrderOrderByWithRelationInput | ServiceOrderOrderByWithRelationInput[]
    cursor?: ServiceOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceOrderScalarFieldEnum | ServiceOrderScalarFieldEnum[]
  }

  /**
   * User.sellerServices
   */
  export type User$sellerServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerService
     */
    select?: SellerServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerService
     */
    omit?: SellerServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerServiceInclude<ExtArgs> | null
    where?: SellerServiceWhereInput
    orderBy?: SellerServiceOrderByWithRelationInput | SellerServiceOrderByWithRelationInput[]
    cursor?: SellerServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellerServiceScalarFieldEnum | SellerServiceScalarFieldEnum[]
  }

  /**
   * User.subscriptions
   */
  export type User$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    where?: UserSubscriptionWhereInput
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    cursor?: UserSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * User.wishlistItems
   */
  export type User$wishlistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    where?: WishlistItemWhereInput
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    cursor?: WishlistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * User.createdTeams
   */
  export type User$createdTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * User.teamMemberships
   */
  export type User$teamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: Decimal | null
    ratingAvg: number | null
    ratingCount: number | null
    viewCount: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: Decimal | null
    ratingAvg: number | null
    ratingCount: number | null
    viewCount: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    sellerId: string | null
    title: string | null
    description: string | null
    price: Decimal | null
    currency: string | null
    imageUrl: string | null
    category: string | null
    ratingAvg: number | null
    ratingCount: number | null
    viewCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    sellerId: string | null
    title: string | null
    description: string | null
    price: Decimal | null
    currency: string | null
    imageUrl: string | null
    category: string | null
    ratingAvg: number | null
    ratingCount: number | null
    viewCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    sellerId: number
    title: number
    description: number
    price: number
    currency: number
    imageUrl: number
    category: number
    ratingAvg: number
    ratingCount: number
    viewCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    ratingAvg?: true
    ratingCount?: true
    viewCount?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    ratingAvg?: true
    ratingCount?: true
    viewCount?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    sellerId?: true
    title?: true
    description?: true
    price?: true
    currency?: true
    imageUrl?: true
    category?: true
    ratingAvg?: true
    ratingCount?: true
    viewCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    sellerId?: true
    title?: true
    description?: true
    price?: true
    currency?: true
    imageUrl?: true
    category?: true
    ratingAvg?: true
    ratingCount?: true
    viewCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    sellerId?: true
    title?: true
    description?: true
    price?: true
    currency?: true
    imageUrl?: true
    category?: true
    ratingAvg?: true
    ratingCount?: true
    viewCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    sellerId: string
    title: string
    description: string
    price: Decimal
    currency: string
    imageUrl: string | null
    category: string | null
    ratingAvg: number | null
    ratingCount: number | null
    viewCount: number
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    imageUrl?: boolean
    category?: boolean
    ratingAvg?: boolean
    ratingCount?: boolean
    viewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
    inventory?: boolean | Product$inventoryArgs<ExtArgs>
    views?: boolean | Product$viewsArgs<ExtArgs>
    cartItems?: boolean | Product$cartItemsArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    productReviews?: boolean | Product$productReviewsArgs<ExtArgs>
    stories?: boolean | Product$storiesArgs<ExtArgs>
    reportedIn?: boolean | Product$reportedInArgs<ExtArgs>
    sponsoredPlacements?: boolean | Product$sponsoredPlacementsArgs<ExtArgs>
    wishlistItems?: boolean | Product$wishlistItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    imageUrl?: boolean
    category?: boolean
    ratingAvg?: boolean
    ratingCount?: boolean
    viewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    imageUrl?: boolean
    category?: boolean
    ratingAvg?: boolean
    ratingCount?: boolean
    viewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    sellerId?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    imageUrl?: boolean
    category?: boolean
    ratingAvg?: boolean
    ratingCount?: boolean
    viewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sellerId" | "title" | "description" | "price" | "currency" | "imageUrl" | "category" | "ratingAvg" | "ratingCount" | "viewCount" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
    inventory?: boolean | Product$inventoryArgs<ExtArgs>
    views?: boolean | Product$viewsArgs<ExtArgs>
    cartItems?: boolean | Product$cartItemsArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    productReviews?: boolean | Product$productReviewsArgs<ExtArgs>
    stories?: boolean | Product$storiesArgs<ExtArgs>
    reportedIn?: boolean | Product$reportedInArgs<ExtArgs>
    sponsoredPlacements?: boolean | Product$sponsoredPlacementsArgs<ExtArgs>
    wishlistItems?: boolean | Product$wishlistItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      seller: Prisma.$UserPayload<ExtArgs>
      inventory: Prisma.$InventoryPayload<ExtArgs> | null
      views: Prisma.$ProductViewPayload<ExtArgs>[]
      cartItems: Prisma.$CartItemPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      productReviews: Prisma.$ReviewPayload<ExtArgs>[]
      stories: Prisma.$CommunityStoryPayload<ExtArgs>[]
      reportedIn: Prisma.$CounterfeitReportPayload<ExtArgs>[]
      sponsoredPlacements: Prisma.$SponsoredPlacementPayload<ExtArgs>[]
      wishlistItems: Prisma.$WishlistItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sellerId: string
      title: string
      description: string
      price: Prisma.Decimal
      currency: string
      imageUrl: string | null
      category: string | null
      ratingAvg: number | null
      ratingCount: number | null
      viewCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inventory<T extends Product$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$inventoryArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    views<T extends Product$viewsArgs<ExtArgs> = {}>(args?: Subset<T, Product$viewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cartItems<T extends Product$cartItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$cartItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productReviews<T extends Product$productReviewsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stories<T extends Product$storiesArgs<ExtArgs> = {}>(args?: Subset<T, Product$storiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportedIn<T extends Product$reportedInArgs<ExtArgs> = {}>(args?: Subset<T, Product$reportedInArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CounterfeitReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sponsoredPlacements<T extends Product$sponsoredPlacementsArgs<ExtArgs> = {}>(args?: Subset<T, Product$sponsoredPlacementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsoredPlacementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wishlistItems<T extends Product$wishlistItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$wishlistItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly sellerId: FieldRef<"Product", 'String'>
    readonly title: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Decimal'>
    readonly currency: FieldRef<"Product", 'String'>
    readonly imageUrl: FieldRef<"Product", 'String'>
    readonly category: FieldRef<"Product", 'String'>
    readonly ratingAvg: FieldRef<"Product", 'Float'>
    readonly ratingCount: FieldRef<"Product", 'Int'>
    readonly viewCount: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.inventory
   */
  export type Product$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
  }

  /**
   * Product.views
   */
  export type Product$viewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductView
     */
    omit?: ProductViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    where?: ProductViewWhereInput
    orderBy?: ProductViewOrderByWithRelationInput | ProductViewOrderByWithRelationInput[]
    cursor?: ProductViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductViewScalarFieldEnum | ProductViewScalarFieldEnum[]
  }

  /**
   * Product.cartItems
   */
  export type Product$cartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.productReviews
   */
  export type Product$productReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Product.stories
   */
  export type Product$storiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityStory
     */
    select?: CommunityStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityStory
     */
    omit?: CommunityStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityStoryInclude<ExtArgs> | null
    where?: CommunityStoryWhereInput
    orderBy?: CommunityStoryOrderByWithRelationInput | CommunityStoryOrderByWithRelationInput[]
    cursor?: CommunityStoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityStoryScalarFieldEnum | CommunityStoryScalarFieldEnum[]
  }

  /**
   * Product.reportedIn
   */
  export type Product$reportedInArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterfeitReport
     */
    select?: CounterfeitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CounterfeitReport
     */
    omit?: CounterfeitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterfeitReportInclude<ExtArgs> | null
    where?: CounterfeitReportWhereInput
    orderBy?: CounterfeitReportOrderByWithRelationInput | CounterfeitReportOrderByWithRelationInput[]
    cursor?: CounterfeitReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CounterfeitReportScalarFieldEnum | CounterfeitReportScalarFieldEnum[]
  }

  /**
   * Product.sponsoredPlacements
   */
  export type Product$sponsoredPlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsoredPlacement
     */
    select?: SponsoredPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsoredPlacement
     */
    omit?: SponsoredPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsoredPlacementInclude<ExtArgs> | null
    where?: SponsoredPlacementWhereInput
    orderBy?: SponsoredPlacementOrderByWithRelationInput | SponsoredPlacementOrderByWithRelationInput[]
    cursor?: SponsoredPlacementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SponsoredPlacementScalarFieldEnum | SponsoredPlacementScalarFieldEnum[]
  }

  /**
   * Product.wishlistItems
   */
  export type Product$wishlistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    where?: WishlistItemWhereInput
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    cursor?: WishlistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    quantity: number | null
  }

  export type InventorySumAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: string | null
    productId: string | null
    quantity: number | null
    updatedAt: Date | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    quantity: number | null
    updatedAt: Date | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    productId: number
    quantity: number
    updatedAt: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    quantity?: true
  }

  export type InventorySumAggregateInputType = {
    quantity?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    updatedAt?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    updatedAt?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: string
    productId: string
    quantity: number
    updatedAt: Date
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    quantity?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    quantity?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    quantity?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectScalar = {
    id?: boolean
    productId?: boolean
    quantity?: boolean
    updatedAt?: boolean
  }

  export type InventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "quantity" | "updatedAt", ExtArgs["result"]["inventory"]>
  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type InventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type InventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      quantity: number
      updatedAt: Date
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryFindManyArgs>(args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends InventoryCreateArgs>(args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCreateManyArgs>(args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventories and returns the data saved in the database.
     * @param {InventoryCreateManyAndReturnArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends InventoryDeleteArgs>(args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUpdateArgs>(args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryDeleteManyArgs>(args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUpdateManyArgs>(args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories and returns the data updated in the database.
     * @param {InventoryUpdateManyAndReturnArgs} args - Arguments to update many Inventories.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventory model
   */
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'String'>
    readonly productId: FieldRef<"Inventory", 'String'>
    readonly quantity: FieldRef<"Inventory", 'Int'>
    readonly updatedAt: FieldRef<"Inventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventory createManyAndReturn
   */
  export type InventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
  }

  /**
   * Inventory updateManyAndReturn
   */
  export type InventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to delete.
     */
    limit?: number
  }

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
  }


  /**
   * Model Cart
   */

  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  export type CartAvgAggregateOutputType = {
    version: number | null
  }

  export type CartSumAggregateOutputType = {
    version: number | null
  }

  export type CartMinAggregateOutputType = {
    id: string | null
    userId: string | null
    anonKey: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    anonKey: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartCountAggregateOutputType = {
    id: number
    userId: number
    anonKey: number
    version: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CartAvgAggregateInputType = {
    version?: true
  }

  export type CartSumAggregateInputType = {
    version?: true
  }

  export type CartMinAggregateInputType = {
    id?: true
    userId?: true
    anonKey?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartMaxAggregateInputType = {
    id?: true
    userId?: true
    anonKey?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartCountAggregateInputType = {
    id?: true
    userId?: true
    anonKey?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cart to aggregate.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carts
    **/
    _count?: true | CartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartMaxAggregateInputType
  }

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
        [P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>
  }




  export type CartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
    orderBy?: CartOrderByWithAggregationInput | CartOrderByWithAggregationInput[]
    by: CartScalarFieldEnum[] | CartScalarFieldEnum
    having?: CartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartCountAggregateInputType | true
    _avg?: CartAvgAggregateInputType
    _sum?: CartSumAggregateInputType
    _min?: CartMinAggregateInputType
    _max?: CartMaxAggregateInputType
  }

  export type CartGroupByOutputType = {
    id: string
    userId: string | null
    anonKey: string | null
    version: number
    createdAt: Date
    updatedAt: Date
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  type GetCartGroupByPayload<T extends CartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartGroupByOutputType[P]>
            : GetScalarType<T[P], CartGroupByOutputType[P]>
        }
      >
    >


  export type CartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    anonKey?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Cart$userArgs<ExtArgs>
    items?: boolean | Cart$itemsArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    anonKey?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Cart$userArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    anonKey?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Cart$userArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectScalar = {
    id?: boolean
    userId?: boolean
    anonKey?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "anonKey" | "version" | "createdAt" | "updatedAt", ExtArgs["result"]["cart"]>
  export type CartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Cart$userArgs<ExtArgs>
    items?: boolean | Cart$itemsArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Cart$userArgs<ExtArgs>
  }
  export type CartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Cart$userArgs<ExtArgs>
  }

  export type $CartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cart"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$CartItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      anonKey: string | null
      version: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cart"]>
    composites: {}
  }

  type CartGetPayload<S extends boolean | null | undefined | CartDefaultArgs> = $Result.GetResult<Prisma.$CartPayload, S>

  type CartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartCountAggregateInputType | true
    }

  export interface CartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cart'], meta: { name: 'Cart' } }
    /**
     * Find zero or one Cart that matches the filter.
     * @param {CartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartFindUniqueArgs>(args: SelectSubset<T, CartFindUniqueArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartFindUniqueOrThrowArgs>(args: SelectSubset<T, CartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartFindFirstArgs>(args?: SelectSubset<T, CartFindFirstArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartFindFirstOrThrowArgs>(args?: SelectSubset<T, CartFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     * 
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartWithIdOnly = await prisma.cart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartFindManyArgs>(args?: SelectSubset<T, CartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cart.
     * @param {CartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     * 
     */
    create<T extends CartCreateArgs>(args: SelectSubset<T, CartCreateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carts.
     * @param {CartCreateManyArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartCreateManyArgs>(args?: SelectSubset<T, CartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carts and returns the data saved in the database.
     * @param {CartCreateManyAndReturnArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartCreateManyAndReturnArgs>(args?: SelectSubset<T, CartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cart.
     * @param {CartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     * 
     */
    delete<T extends CartDeleteArgs>(args: SelectSubset<T, CartDeleteArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cart.
     * @param {CartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartUpdateArgs>(args: SelectSubset<T, CartUpdateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carts.
     * @param {CartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartDeleteManyArgs>(args?: SelectSubset<T, CartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartUpdateManyArgs>(args: SelectSubset<T, CartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts and returns the data updated in the database.
     * @param {CartUpdateManyAndReturnArgs} args - Arguments to update many Carts.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartUpdateManyAndReturnArgs>(args: SelectSubset<T, CartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cart.
     * @param {CartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
     */
    upsert<T extends CartUpsertArgs>(args: SelectSubset<T, CartUpsertArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
    **/
    count<T extends CartCountArgs>(
      args?: Subset<T, CartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartAggregateArgs>(args: Subset<T, CartAggregateArgs>): Prisma.PrismaPromise<GetCartAggregateType<T>>

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartGroupByArgs['orderBy'] }
        : { orderBy?: CartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cart model
   */
  readonly fields: CartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Cart$userArgs<ExtArgs> = {}>(args?: Subset<T, Cart$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Cart$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Cart$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cart model
   */
  interface CartFieldRefs {
    readonly id: FieldRef<"Cart", 'String'>
    readonly userId: FieldRef<"Cart", 'String'>
    readonly anonKey: FieldRef<"Cart", 'String'>
    readonly version: FieldRef<"Cart", 'Int'>
    readonly createdAt: FieldRef<"Cart", 'DateTime'>
    readonly updatedAt: FieldRef<"Cart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cart findUnique
   */
  export type CartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findUniqueOrThrow
   */
  export type CartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findFirst
   */
  export type CartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findFirstOrThrow
   */
  export type CartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findMany
   */
  export type CartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart create
   */
  export type CartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to create a Cart.
     */
    data: XOR<CartCreateInput, CartUncheckedCreateInput>
  }

  /**
   * Cart createMany
   */
  export type CartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cart createManyAndReturn
   */
  export type CartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart update
   */
  export type CartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to update a Cart.
     */
    data: XOR<CartUpdateInput, CartUncheckedUpdateInput>
    /**
     * Choose, which Cart to update.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart updateMany
   */
  export type CartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
  }

  /**
   * Cart updateManyAndReturn
   */
  export type CartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart upsert
   */
  export type CartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The filter to search for the Cart to update in case it exists.
     */
    where: CartWhereUniqueInput
    /**
     * In case the Cart found by the `where` argument doesn't exist, create a new Cart with this data.
     */
    create: XOR<CartCreateInput, CartUncheckedCreateInput>
    /**
     * In case the Cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartUpdateInput, CartUncheckedUpdateInput>
  }

  /**
   * Cart delete
   */
  export type CartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter which Cart to delete.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart deleteMany
   */
  export type CartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carts to delete
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to delete.
     */
    limit?: number
  }

  /**
   * Cart.user
   */
  export type Cart$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Cart.items
   */
  export type Cart$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Cart without action
   */
  export type CartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
  }


  /**
   * Model CartItem
   */

  export type AggregateCartItem = {
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  export type CartItemAvgAggregateOutputType = {
    qty: number | null
  }

  export type CartItemSumAggregateOutputType = {
    qty: number | null
  }

  export type CartItemMinAggregateOutputType = {
    id: string | null
    cartId: string | null
    productId: string | null
    qty: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartItemMaxAggregateOutputType = {
    id: string | null
    cartId: string | null
    productId: string | null
    qty: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartItemCountAggregateOutputType = {
    id: number
    cartId: number
    productId: number
    qty: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CartItemAvgAggregateInputType = {
    qty?: true
  }

  export type CartItemSumAggregateInputType = {
    qty?: true
  }

  export type CartItemMinAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    qty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartItemMaxAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    qty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartItemCountAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    qty?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CartItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItem to aggregate.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CartItems
    **/
    _count?: true | CartItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartItemMaxAggregateInputType
  }

  export type GetCartItemAggregateType<T extends CartItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCartItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartItem[P]>
      : GetScalarType<T[P], AggregateCartItem[P]>
  }




  export type CartItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithAggregationInput | CartItemOrderByWithAggregationInput[]
    by: CartItemScalarFieldEnum[] | CartItemScalarFieldEnum
    having?: CartItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartItemCountAggregateInputType | true
    _avg?: CartItemAvgAggregateInputType
    _sum?: CartItemSumAggregateInputType
    _min?: CartItemMinAggregateInputType
    _max?: CartItemMaxAggregateInputType
  }

  export type CartItemGroupByOutputType = {
    id: string
    cartId: string
    productId: string
    qty: number
    createdAt: Date
    updatedAt: Date
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  type GetCartItemGroupByPayload<T extends CartItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartItemGroupByOutputType[P]>
            : GetScalarType<T[P], CartItemGroupByOutputType[P]>
        }
      >
    >


  export type CartItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    qty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    qty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    qty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectScalar = {
    id?: boolean
    cartId?: boolean
    productId?: boolean
    qty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CartItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cartId" | "productId" | "qty" | "createdAt" | "updatedAt", ExtArgs["result"]["cartItem"]>
  export type CartItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CartItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CartItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $CartItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CartItem"
    objects: {
      cart: Prisma.$CartPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cartId: string
      productId: string
      qty: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cartItem"]>
    composites: {}
  }

  type CartItemGetPayload<S extends boolean | null | undefined | CartItemDefaultArgs> = $Result.GetResult<Prisma.$CartItemPayload, S>

  type CartItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartItemCountAggregateInputType | true
    }

  export interface CartItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CartItem'], meta: { name: 'CartItem' } }
    /**
     * Find zero or one CartItem that matches the filter.
     * @param {CartItemFindUniqueArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartItemFindUniqueArgs>(args: SelectSubset<T, CartItemFindUniqueArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CartItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartItemFindUniqueOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CartItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartItemFindFirstArgs>(args?: SelectSubset<T, CartItemFindFirstArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CartItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CartItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CartItems
     * const cartItems = await prisma.cartItem.findMany()
     * 
     * // Get first 10 CartItems
     * const cartItems = await prisma.cartItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartItemFindManyArgs>(args?: SelectSubset<T, CartItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CartItem.
     * @param {CartItemCreateArgs} args - Arguments to create a CartItem.
     * @example
     * // Create one CartItem
     * const CartItem = await prisma.cartItem.create({
     *   data: {
     *     // ... data to create a CartItem
     *   }
     * })
     * 
     */
    create<T extends CartItemCreateArgs>(args: SelectSubset<T, CartItemCreateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CartItems.
     * @param {CartItemCreateManyArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartItemCreateManyArgs>(args?: SelectSubset<T, CartItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CartItems and returns the data saved in the database.
     * @param {CartItemCreateManyAndReturnArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CartItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CartItem.
     * @param {CartItemDeleteArgs} args - Arguments to delete one CartItem.
     * @example
     * // Delete one CartItem
     * const CartItem = await prisma.cartItem.delete({
     *   where: {
     *     // ... filter to delete one CartItem
     *   }
     * })
     * 
     */
    delete<T extends CartItemDeleteArgs>(args: SelectSubset<T, CartItemDeleteArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CartItem.
     * @param {CartItemUpdateArgs} args - Arguments to update one CartItem.
     * @example
     * // Update one CartItem
     * const cartItem = await prisma.cartItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartItemUpdateArgs>(args: SelectSubset<T, CartItemUpdateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CartItems.
     * @param {CartItemDeleteManyArgs} args - Arguments to filter CartItems to delete.
     * @example
     * // Delete a few CartItems
     * const { count } = await prisma.cartItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartItemDeleteManyArgs>(args?: SelectSubset<T, CartItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartItemUpdateManyArgs>(args: SelectSubset<T, CartItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems and returns the data updated in the database.
     * @param {CartItemUpdateManyAndReturnArgs} args - Arguments to update many CartItems.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartItemUpdateManyAndReturnArgs>(args: SelectSubset<T, CartItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CartItem.
     * @param {CartItemUpsertArgs} args - Arguments to update or create a CartItem.
     * @example
     * // Update or create a CartItem
     * const cartItem = await prisma.cartItem.upsert({
     *   create: {
     *     // ... data to create a CartItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CartItem we want to update
     *   }
     * })
     */
    upsert<T extends CartItemUpsertArgs>(args: SelectSubset<T, CartItemUpsertArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemCountArgs} args - Arguments to filter CartItems to count.
     * @example
     * // Count the number of CartItems
     * const count = await prisma.cartItem.count({
     *   where: {
     *     // ... the filter for the CartItems we want to count
     *   }
     * })
    **/
    count<T extends CartItemCountArgs>(
      args?: Subset<T, CartItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartItemAggregateArgs>(args: Subset<T, CartItemAggregateArgs>): Prisma.PrismaPromise<GetCartItemAggregateType<T>>

    /**
     * Group by CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartItemGroupByArgs['orderBy'] }
        : { orderBy?: CartItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CartItem model
   */
  readonly fields: CartItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CartItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cart<T extends CartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CartDefaultArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CartItem model
   */
  interface CartItemFieldRefs {
    readonly id: FieldRef<"CartItem", 'String'>
    readonly cartId: FieldRef<"CartItem", 'String'>
    readonly productId: FieldRef<"CartItem", 'String'>
    readonly qty: FieldRef<"CartItem", 'Int'>
    readonly createdAt: FieldRef<"CartItem", 'DateTime'>
    readonly updatedAt: FieldRef<"CartItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CartItem findUnique
   */
  export type CartItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findUniqueOrThrow
   */
  export type CartItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findFirst
   */
  export type CartItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findFirstOrThrow
   */
  export type CartItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findMany
   */
  export type CartItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItems to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem create
   */
  export type CartItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CartItem.
     */
    data: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
  }

  /**
   * CartItem createMany
   */
  export type CartItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CartItem createManyAndReturn
   */
  export type CartItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItem update
   */
  export type CartItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CartItem.
     */
    data: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
    /**
     * Choose, which CartItem to update.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem updateMany
   */
  export type CartItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
  }

  /**
   * CartItem updateManyAndReturn
   */
  export type CartItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItem upsert
   */
  export type CartItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CartItem to update in case it exists.
     */
    where: CartItemWhereUniqueInput
    /**
     * In case the CartItem found by the `where` argument doesn't exist, create a new CartItem with this data.
     */
    create: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
    /**
     * In case the CartItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
  }

  /**
   * CartItem delete
   */
  export type CartItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter which CartItem to delete.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem deleteMany
   */
  export type CartItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItems to delete
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to delete.
     */
    limit?: number
  }

  /**
   * CartItem without action
   */
  export type CartItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    total: Decimal | null
  }

  export type OrderSumAggregateOutputType = {
    total: Decimal | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    userId: string | null
    total: Decimal | null
    currency: string | null
    status: $Enums.OrderStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    paymentRef: string | null
    shippingAdr: string | null
    buyerName: string | null
    buyerPhone: string | null
    buyerEmail: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    total: Decimal | null
    currency: string | null
    status: $Enums.OrderStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    paymentRef: string | null
    shippingAdr: string | null
    buyerName: string | null
    buyerPhone: string | null
    buyerEmail: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    userId: number
    total: number
    currency: number
    status: number
    createdAt: number
    updatedAt: number
    paymentRef: number
    shippingAdr: number
    buyerName: number
    buyerPhone: number
    buyerEmail: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    total?: true
  }

  export type OrderSumAggregateInputType = {
    total?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    userId?: true
    total?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paymentRef?: true
    shippingAdr?: true
    buyerName?: true
    buyerPhone?: true
    buyerEmail?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    userId?: true
    total?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paymentRef?: true
    shippingAdr?: true
    buyerName?: true
    buyerPhone?: true
    buyerEmail?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    userId?: true
    total?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paymentRef?: true
    shippingAdr?: true
    buyerName?: true
    buyerPhone?: true
    buyerEmail?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    userId: string
    total: Decimal
    currency: string
    status: $Enums.OrderStatus
    createdAt: Date
    updatedAt: Date
    paymentRef: string | null
    shippingAdr: string | null
    buyerName: string | null
    buyerPhone: string | null
    buyerEmail: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    total?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentRef?: boolean
    shippingAdr?: boolean
    buyerName?: boolean
    buyerPhone?: boolean
    buyerEmail?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    payment?: boolean | Order$paymentArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    total?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentRef?: boolean
    shippingAdr?: boolean
    buyerName?: boolean
    buyerPhone?: boolean
    buyerEmail?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    total?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentRef?: boolean
    shippingAdr?: boolean
    buyerName?: boolean
    buyerPhone?: boolean
    buyerEmail?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    userId?: boolean
    total?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentRef?: boolean
    shippingAdr?: boolean
    buyerName?: boolean
    buyerPhone?: boolean
    buyerEmail?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "total" | "currency" | "status" | "createdAt" | "updatedAt" | "paymentRef" | "shippingAdr" | "buyerName" | "buyerPhone" | "buyerEmail", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    payment?: boolean | Order$paymentArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      payment: Prisma.$PaymentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      total: Prisma.Decimal
      currency: string
      status: $Enums.OrderStatus
      createdAt: Date
      updatedAt: Date
      paymentRef: string | null
      shippingAdr: string | null
      buyerName: string | null
      buyerPhone: string | null
      buyerEmail: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment<T extends Order$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Order$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly userId: FieldRef<"Order", 'String'>
    readonly total: FieldRef<"Order", 'Decimal'>
    readonly currency: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly paymentRef: FieldRef<"Order", 'String'>
    readonly shippingAdr: FieldRef<"Order", 'String'>
    readonly buyerName: FieldRef<"Order", 'String'>
    readonly buyerPhone: FieldRef<"Order", 'String'>
    readonly buyerEmail: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.payment
   */
  export type Order$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    qty: number | null
    price: Decimal | null
    grossAmount: Decimal | null
    feeAmount: Decimal | null
    netAmount: Decimal | null
  }

  export type OrderItemSumAggregateOutputType = {
    qty: number | null
    price: Decimal | null
    grossAmount: Decimal | null
    feeAmount: Decimal | null
    netAmount: Decimal | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    qty: number | null
    price: Decimal | null
    sellerId: string | null
    grossAmount: Decimal | null
    feeAmount: Decimal | null
    netAmount: Decimal | null
    payoutStatus: $Enums.PayoutStatus | null
    payoutBatchId: string | null
    paidAt: Date | null
    currency: string | null
    fulfillmentStatus: $Enums.FulfillmentStatus | null
    shippedAt: Date | null
    deliveredAt: Date | null
    trackingCode: string | null
    carrier: string | null
    deliveryProofUrl: string | null
    notes: string | null
    exceptionNotified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    qty: number | null
    price: Decimal | null
    sellerId: string | null
    grossAmount: Decimal | null
    feeAmount: Decimal | null
    netAmount: Decimal | null
    payoutStatus: $Enums.PayoutStatus | null
    payoutBatchId: string | null
    paidAt: Date | null
    currency: string | null
    fulfillmentStatus: $Enums.FulfillmentStatus | null
    shippedAt: Date | null
    deliveredAt: Date | null
    trackingCode: string | null
    carrier: string | null
    deliveryProofUrl: string | null
    notes: string | null
    exceptionNotified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    qty: number
    price: number
    sellerId: number
    grossAmount: number
    feeAmount: number
    netAmount: number
    payoutStatus: number
    payoutBatchId: number
    paidAt: number
    currency: number
    fulfillmentStatus: number
    shippedAt: number
    deliveredAt: number
    trackingCode: number
    carrier: number
    deliveryProofUrl: number
    notes: number
    exceptionNotified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    qty?: true
    price?: true
    grossAmount?: true
    feeAmount?: true
    netAmount?: true
  }

  export type OrderItemSumAggregateInputType = {
    qty?: true
    price?: true
    grossAmount?: true
    feeAmount?: true
    netAmount?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    qty?: true
    price?: true
    sellerId?: true
    grossAmount?: true
    feeAmount?: true
    netAmount?: true
    payoutStatus?: true
    payoutBatchId?: true
    paidAt?: true
    currency?: true
    fulfillmentStatus?: true
    shippedAt?: true
    deliveredAt?: true
    trackingCode?: true
    carrier?: true
    deliveryProofUrl?: true
    notes?: true
    exceptionNotified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    qty?: true
    price?: true
    sellerId?: true
    grossAmount?: true
    feeAmount?: true
    netAmount?: true
    payoutStatus?: true
    payoutBatchId?: true
    paidAt?: true
    currency?: true
    fulfillmentStatus?: true
    shippedAt?: true
    deliveredAt?: true
    trackingCode?: true
    carrier?: true
    deliveryProofUrl?: true
    notes?: true
    exceptionNotified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    qty?: true
    price?: true
    sellerId?: true
    grossAmount?: true
    feeAmount?: true
    netAmount?: true
    payoutStatus?: true
    payoutBatchId?: true
    paidAt?: true
    currency?: true
    fulfillmentStatus?: true
    shippedAt?: true
    deliveredAt?: true
    trackingCode?: true
    carrier?: true
    deliveryProofUrl?: true
    notes?: true
    exceptionNotified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    productId: string
    qty: number
    price: Decimal
    sellerId: string
    grossAmount: Decimal
    feeAmount: Decimal
    netAmount: Decimal
    payoutStatus: $Enums.PayoutStatus
    payoutBatchId: string | null
    paidAt: Date | null
    currency: string
    fulfillmentStatus: $Enums.FulfillmentStatus
    shippedAt: Date | null
    deliveredAt: Date | null
    trackingCode: string | null
    carrier: string | null
    deliveryProofUrl: string | null
    notes: string | null
    exceptionNotified: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    qty?: boolean
    price?: boolean
    sellerId?: boolean
    grossAmount?: boolean
    feeAmount?: boolean
    netAmount?: boolean
    payoutStatus?: boolean
    payoutBatchId?: boolean
    paidAt?: boolean
    currency?: boolean
    fulfillmentStatus?: boolean
    shippedAt?: boolean
    deliveredAt?: boolean
    trackingCode?: boolean
    carrier?: boolean
    deliveryProofUrl?: boolean
    notes?: boolean
    exceptionNotified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    disputes?: boolean | OrderItem$disputesArgs<ExtArgs>
    reviews?: boolean | OrderItem$reviewsArgs<ExtArgs>
    _count?: boolean | OrderItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    qty?: boolean
    price?: boolean
    sellerId?: boolean
    grossAmount?: boolean
    feeAmount?: boolean
    netAmount?: boolean
    payoutStatus?: boolean
    payoutBatchId?: boolean
    paidAt?: boolean
    currency?: boolean
    fulfillmentStatus?: boolean
    shippedAt?: boolean
    deliveredAt?: boolean
    trackingCode?: boolean
    carrier?: boolean
    deliveryProofUrl?: boolean
    notes?: boolean
    exceptionNotified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    qty?: boolean
    price?: boolean
    sellerId?: boolean
    grossAmount?: boolean
    feeAmount?: boolean
    netAmount?: boolean
    payoutStatus?: boolean
    payoutBatchId?: boolean
    paidAt?: boolean
    currency?: boolean
    fulfillmentStatus?: boolean
    shippedAt?: boolean
    deliveredAt?: boolean
    trackingCode?: boolean
    carrier?: boolean
    deliveryProofUrl?: boolean
    notes?: boolean
    exceptionNotified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    qty?: boolean
    price?: boolean
    sellerId?: boolean
    grossAmount?: boolean
    feeAmount?: boolean
    netAmount?: boolean
    payoutStatus?: boolean
    payoutBatchId?: boolean
    paidAt?: boolean
    currency?: boolean
    fulfillmentStatus?: boolean
    shippedAt?: boolean
    deliveredAt?: boolean
    trackingCode?: boolean
    carrier?: boolean
    deliveryProofUrl?: boolean
    notes?: boolean
    exceptionNotified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "qty" | "price" | "sellerId" | "grossAmount" | "feeAmount" | "netAmount" | "payoutStatus" | "payoutBatchId" | "paidAt" | "currency" | "fulfillmentStatus" | "shippedAt" | "deliveredAt" | "trackingCode" | "carrier" | "deliveryProofUrl" | "notes" | "exceptionNotified" | "createdAt" | "updatedAt", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    disputes?: boolean | OrderItem$disputesArgs<ExtArgs>
    reviews?: boolean | OrderItem$reviewsArgs<ExtArgs>
    _count?: boolean | OrderItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      disputes: Prisma.$DisputePayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      productId: string
      qty: number
      price: Prisma.Decimal
      sellerId: string
      grossAmount: Prisma.Decimal
      feeAmount: Prisma.Decimal
      netAmount: Prisma.Decimal
      payoutStatus: $Enums.PayoutStatus
      payoutBatchId: string | null
      paidAt: Date | null
      currency: string
      fulfillmentStatus: $Enums.FulfillmentStatus
      shippedAt: Date | null
      deliveredAt: Date | null
      trackingCode: string | null
      carrier: string | null
      deliveryProofUrl: string | null
      notes: string | null
      exceptionNotified: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    disputes<T extends OrderItem$disputesArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$disputesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends OrderItem$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly productId: FieldRef<"OrderItem", 'String'>
    readonly qty: FieldRef<"OrderItem", 'Int'>
    readonly price: FieldRef<"OrderItem", 'Decimal'>
    readonly sellerId: FieldRef<"OrderItem", 'String'>
    readonly grossAmount: FieldRef<"OrderItem", 'Decimal'>
    readonly feeAmount: FieldRef<"OrderItem", 'Decimal'>
    readonly netAmount: FieldRef<"OrderItem", 'Decimal'>
    readonly payoutStatus: FieldRef<"OrderItem", 'PayoutStatus'>
    readonly payoutBatchId: FieldRef<"OrderItem", 'String'>
    readonly paidAt: FieldRef<"OrderItem", 'DateTime'>
    readonly currency: FieldRef<"OrderItem", 'String'>
    readonly fulfillmentStatus: FieldRef<"OrderItem", 'FulfillmentStatus'>
    readonly shippedAt: FieldRef<"OrderItem", 'DateTime'>
    readonly deliveredAt: FieldRef<"OrderItem", 'DateTime'>
    readonly trackingCode: FieldRef<"OrderItem", 'String'>
    readonly carrier: FieldRef<"OrderItem", 'String'>
    readonly deliveryProofUrl: FieldRef<"OrderItem", 'String'>
    readonly notes: FieldRef<"OrderItem", 'String'>
    readonly exceptionNotified: FieldRef<"OrderItem", 'Boolean'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem.disputes
   */
  export type OrderItem$disputesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    where?: DisputeWhereInput
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    cursor?: DisputeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisputeScalarFieldEnum | DisputeScalarFieldEnum[]
  }

  /**
   * OrderItem.reviews
   */
  export type OrderItem$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    provider: string | null
    externalRef: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    provider: string | null
    externalRef: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    orderId: number
    provider: number
    externalRef: number
    amount: number
    currency: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    orderId?: true
    provider?: true
    externalRef?: true
    amount?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    orderId?: true
    provider?: true
    externalRef?: true
    amount?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    orderId?: true
    provider?: true
    externalRef?: true
    amount?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    orderId: string
    provider: string
    externalRef: string | null
    amount: Decimal
    currency: string
    status: $Enums.PaymentStatus
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    provider?: boolean
    externalRef?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    provider?: boolean
    externalRef?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    provider?: boolean
    externalRef?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    orderId?: boolean
    provider?: boolean
    externalRef?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "provider" | "externalRef" | "amount" | "currency" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      provider: string
      externalRef: string | null
      amount: Prisma.Decimal
      currency: string
      status: $Enums.PaymentStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly orderId: FieldRef<"Payment", 'String'>
    readonly provider: FieldRef<"Payment", 'String'>
    readonly externalRef: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model FulfillmentSettings
   */

  export type AggregateFulfillmentSettings = {
    _count: FulfillmentSettingsCountAggregateOutputType | null
    _min: FulfillmentSettingsMinAggregateOutputType | null
    _max: FulfillmentSettingsMaxAggregateOutputType | null
  }

  export type FulfillmentSettingsMinAggregateOutputType = {
    id: string | null
    sellerId: string | null
    usesMicroFulfillment: boolean | null
    microFulfillmentPartnerId: string | null
    microFulfillmentOptInDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FulfillmentSettingsMaxAggregateOutputType = {
    id: string | null
    sellerId: string | null
    usesMicroFulfillment: boolean | null
    microFulfillmentPartnerId: string | null
    microFulfillmentOptInDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FulfillmentSettingsCountAggregateOutputType = {
    id: number
    sellerId: number
    usesMicroFulfillment: number
    microFulfillmentPartnerId: number
    microFulfillmentOptInDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FulfillmentSettingsMinAggregateInputType = {
    id?: true
    sellerId?: true
    usesMicroFulfillment?: true
    microFulfillmentPartnerId?: true
    microFulfillmentOptInDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FulfillmentSettingsMaxAggregateInputType = {
    id?: true
    sellerId?: true
    usesMicroFulfillment?: true
    microFulfillmentPartnerId?: true
    microFulfillmentOptInDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FulfillmentSettingsCountAggregateInputType = {
    id?: true
    sellerId?: true
    usesMicroFulfillment?: true
    microFulfillmentPartnerId?: true
    microFulfillmentOptInDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FulfillmentSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FulfillmentSettings to aggregate.
     */
    where?: FulfillmentSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FulfillmentSettings to fetch.
     */
    orderBy?: FulfillmentSettingsOrderByWithRelationInput | FulfillmentSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FulfillmentSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FulfillmentSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FulfillmentSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FulfillmentSettings
    **/
    _count?: true | FulfillmentSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FulfillmentSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FulfillmentSettingsMaxAggregateInputType
  }

  export type GetFulfillmentSettingsAggregateType<T extends FulfillmentSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateFulfillmentSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFulfillmentSettings[P]>
      : GetScalarType<T[P], AggregateFulfillmentSettings[P]>
  }




  export type FulfillmentSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FulfillmentSettingsWhereInput
    orderBy?: FulfillmentSettingsOrderByWithAggregationInput | FulfillmentSettingsOrderByWithAggregationInput[]
    by: FulfillmentSettingsScalarFieldEnum[] | FulfillmentSettingsScalarFieldEnum
    having?: FulfillmentSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FulfillmentSettingsCountAggregateInputType | true
    _min?: FulfillmentSettingsMinAggregateInputType
    _max?: FulfillmentSettingsMaxAggregateInputType
  }

  export type FulfillmentSettingsGroupByOutputType = {
    id: string
    sellerId: string
    usesMicroFulfillment: boolean
    microFulfillmentPartnerId: string | null
    microFulfillmentOptInDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: FulfillmentSettingsCountAggregateOutputType | null
    _min: FulfillmentSettingsMinAggregateOutputType | null
    _max: FulfillmentSettingsMaxAggregateOutputType | null
  }

  type GetFulfillmentSettingsGroupByPayload<T extends FulfillmentSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FulfillmentSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FulfillmentSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FulfillmentSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], FulfillmentSettingsGroupByOutputType[P]>
        }
      >
    >


  export type FulfillmentSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    usesMicroFulfillment?: boolean
    microFulfillmentPartnerId?: boolean
    microFulfillmentOptInDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fulfillmentSettings"]>

  export type FulfillmentSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    usesMicroFulfillment?: boolean
    microFulfillmentPartnerId?: boolean
    microFulfillmentOptInDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fulfillmentSettings"]>

  export type FulfillmentSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    usesMicroFulfillment?: boolean
    microFulfillmentPartnerId?: boolean
    microFulfillmentOptInDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fulfillmentSettings"]>

  export type FulfillmentSettingsSelectScalar = {
    id?: boolean
    sellerId?: boolean
    usesMicroFulfillment?: boolean
    microFulfillmentPartnerId?: boolean
    microFulfillmentOptInDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FulfillmentSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sellerId" | "usesMicroFulfillment" | "microFulfillmentPartnerId" | "microFulfillmentOptInDate" | "createdAt" | "updatedAt", ExtArgs["result"]["fulfillmentSettings"]>
  export type FulfillmentSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FulfillmentSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FulfillmentSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FulfillmentSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FulfillmentSettings"
    objects: {
      seller: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sellerId: string
      usesMicroFulfillment: boolean
      microFulfillmentPartnerId: string | null
      microFulfillmentOptInDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fulfillmentSettings"]>
    composites: {}
  }

  type FulfillmentSettingsGetPayload<S extends boolean | null | undefined | FulfillmentSettingsDefaultArgs> = $Result.GetResult<Prisma.$FulfillmentSettingsPayload, S>

  type FulfillmentSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FulfillmentSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FulfillmentSettingsCountAggregateInputType | true
    }

  export interface FulfillmentSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FulfillmentSettings'], meta: { name: 'FulfillmentSettings' } }
    /**
     * Find zero or one FulfillmentSettings that matches the filter.
     * @param {FulfillmentSettingsFindUniqueArgs} args - Arguments to find a FulfillmentSettings
     * @example
     * // Get one FulfillmentSettings
     * const fulfillmentSettings = await prisma.fulfillmentSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FulfillmentSettingsFindUniqueArgs>(args: SelectSubset<T, FulfillmentSettingsFindUniqueArgs<ExtArgs>>): Prisma__FulfillmentSettingsClient<$Result.GetResult<Prisma.$FulfillmentSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FulfillmentSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FulfillmentSettingsFindUniqueOrThrowArgs} args - Arguments to find a FulfillmentSettings
     * @example
     * // Get one FulfillmentSettings
     * const fulfillmentSettings = await prisma.fulfillmentSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FulfillmentSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, FulfillmentSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FulfillmentSettingsClient<$Result.GetResult<Prisma.$FulfillmentSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FulfillmentSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FulfillmentSettingsFindFirstArgs} args - Arguments to find a FulfillmentSettings
     * @example
     * // Get one FulfillmentSettings
     * const fulfillmentSettings = await prisma.fulfillmentSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FulfillmentSettingsFindFirstArgs>(args?: SelectSubset<T, FulfillmentSettingsFindFirstArgs<ExtArgs>>): Prisma__FulfillmentSettingsClient<$Result.GetResult<Prisma.$FulfillmentSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FulfillmentSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FulfillmentSettingsFindFirstOrThrowArgs} args - Arguments to find a FulfillmentSettings
     * @example
     * // Get one FulfillmentSettings
     * const fulfillmentSettings = await prisma.fulfillmentSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FulfillmentSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, FulfillmentSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FulfillmentSettingsClient<$Result.GetResult<Prisma.$FulfillmentSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FulfillmentSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FulfillmentSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FulfillmentSettings
     * const fulfillmentSettings = await prisma.fulfillmentSettings.findMany()
     * 
     * // Get first 10 FulfillmentSettings
     * const fulfillmentSettings = await prisma.fulfillmentSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fulfillmentSettingsWithIdOnly = await prisma.fulfillmentSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FulfillmentSettingsFindManyArgs>(args?: SelectSubset<T, FulfillmentSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FulfillmentSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FulfillmentSettings.
     * @param {FulfillmentSettingsCreateArgs} args - Arguments to create a FulfillmentSettings.
     * @example
     * // Create one FulfillmentSettings
     * const FulfillmentSettings = await prisma.fulfillmentSettings.create({
     *   data: {
     *     // ... data to create a FulfillmentSettings
     *   }
     * })
     * 
     */
    create<T extends FulfillmentSettingsCreateArgs>(args: SelectSubset<T, FulfillmentSettingsCreateArgs<ExtArgs>>): Prisma__FulfillmentSettingsClient<$Result.GetResult<Prisma.$FulfillmentSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FulfillmentSettings.
     * @param {FulfillmentSettingsCreateManyArgs} args - Arguments to create many FulfillmentSettings.
     * @example
     * // Create many FulfillmentSettings
     * const fulfillmentSettings = await prisma.fulfillmentSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FulfillmentSettingsCreateManyArgs>(args?: SelectSubset<T, FulfillmentSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FulfillmentSettings and returns the data saved in the database.
     * @param {FulfillmentSettingsCreateManyAndReturnArgs} args - Arguments to create many FulfillmentSettings.
     * @example
     * // Create many FulfillmentSettings
     * const fulfillmentSettings = await prisma.fulfillmentSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FulfillmentSettings and only return the `id`
     * const fulfillmentSettingsWithIdOnly = await prisma.fulfillmentSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FulfillmentSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, FulfillmentSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FulfillmentSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FulfillmentSettings.
     * @param {FulfillmentSettingsDeleteArgs} args - Arguments to delete one FulfillmentSettings.
     * @example
     * // Delete one FulfillmentSettings
     * const FulfillmentSettings = await prisma.fulfillmentSettings.delete({
     *   where: {
     *     // ... filter to delete one FulfillmentSettings
     *   }
     * })
     * 
     */
    delete<T extends FulfillmentSettingsDeleteArgs>(args: SelectSubset<T, FulfillmentSettingsDeleteArgs<ExtArgs>>): Prisma__FulfillmentSettingsClient<$Result.GetResult<Prisma.$FulfillmentSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FulfillmentSettings.
     * @param {FulfillmentSettingsUpdateArgs} args - Arguments to update one FulfillmentSettings.
     * @example
     * // Update one FulfillmentSettings
     * const fulfillmentSettings = await prisma.fulfillmentSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FulfillmentSettingsUpdateArgs>(args: SelectSubset<T, FulfillmentSettingsUpdateArgs<ExtArgs>>): Prisma__FulfillmentSettingsClient<$Result.GetResult<Prisma.$FulfillmentSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FulfillmentSettings.
     * @param {FulfillmentSettingsDeleteManyArgs} args - Arguments to filter FulfillmentSettings to delete.
     * @example
     * // Delete a few FulfillmentSettings
     * const { count } = await prisma.fulfillmentSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FulfillmentSettingsDeleteManyArgs>(args?: SelectSubset<T, FulfillmentSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FulfillmentSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FulfillmentSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FulfillmentSettings
     * const fulfillmentSettings = await prisma.fulfillmentSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FulfillmentSettingsUpdateManyArgs>(args: SelectSubset<T, FulfillmentSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FulfillmentSettings and returns the data updated in the database.
     * @param {FulfillmentSettingsUpdateManyAndReturnArgs} args - Arguments to update many FulfillmentSettings.
     * @example
     * // Update many FulfillmentSettings
     * const fulfillmentSettings = await prisma.fulfillmentSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FulfillmentSettings and only return the `id`
     * const fulfillmentSettingsWithIdOnly = await prisma.fulfillmentSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FulfillmentSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, FulfillmentSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FulfillmentSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FulfillmentSettings.
     * @param {FulfillmentSettingsUpsertArgs} args - Arguments to update or create a FulfillmentSettings.
     * @example
     * // Update or create a FulfillmentSettings
     * const fulfillmentSettings = await prisma.fulfillmentSettings.upsert({
     *   create: {
     *     // ... data to create a FulfillmentSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FulfillmentSettings we want to update
     *   }
     * })
     */
    upsert<T extends FulfillmentSettingsUpsertArgs>(args: SelectSubset<T, FulfillmentSettingsUpsertArgs<ExtArgs>>): Prisma__FulfillmentSettingsClient<$Result.GetResult<Prisma.$FulfillmentSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FulfillmentSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FulfillmentSettingsCountArgs} args - Arguments to filter FulfillmentSettings to count.
     * @example
     * // Count the number of FulfillmentSettings
     * const count = await prisma.fulfillmentSettings.count({
     *   where: {
     *     // ... the filter for the FulfillmentSettings we want to count
     *   }
     * })
    **/
    count<T extends FulfillmentSettingsCountArgs>(
      args?: Subset<T, FulfillmentSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FulfillmentSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FulfillmentSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FulfillmentSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FulfillmentSettingsAggregateArgs>(args: Subset<T, FulfillmentSettingsAggregateArgs>): Prisma.PrismaPromise<GetFulfillmentSettingsAggregateType<T>>

    /**
     * Group by FulfillmentSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FulfillmentSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FulfillmentSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FulfillmentSettingsGroupByArgs['orderBy'] }
        : { orderBy?: FulfillmentSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FulfillmentSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFulfillmentSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FulfillmentSettings model
   */
  readonly fields: FulfillmentSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FulfillmentSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FulfillmentSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FulfillmentSettings model
   */
  interface FulfillmentSettingsFieldRefs {
    readonly id: FieldRef<"FulfillmentSettings", 'String'>
    readonly sellerId: FieldRef<"FulfillmentSettings", 'String'>
    readonly usesMicroFulfillment: FieldRef<"FulfillmentSettings", 'Boolean'>
    readonly microFulfillmentPartnerId: FieldRef<"FulfillmentSettings", 'String'>
    readonly microFulfillmentOptInDate: FieldRef<"FulfillmentSettings", 'DateTime'>
    readonly createdAt: FieldRef<"FulfillmentSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"FulfillmentSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FulfillmentSettings findUnique
   */
  export type FulfillmentSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentSettings
     */
    select?: FulfillmentSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentSettings
     */
    omit?: FulfillmentSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentSettingsInclude<ExtArgs> | null
    /**
     * Filter, which FulfillmentSettings to fetch.
     */
    where: FulfillmentSettingsWhereUniqueInput
  }

  /**
   * FulfillmentSettings findUniqueOrThrow
   */
  export type FulfillmentSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentSettings
     */
    select?: FulfillmentSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentSettings
     */
    omit?: FulfillmentSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentSettingsInclude<ExtArgs> | null
    /**
     * Filter, which FulfillmentSettings to fetch.
     */
    where: FulfillmentSettingsWhereUniqueInput
  }

  /**
   * FulfillmentSettings findFirst
   */
  export type FulfillmentSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentSettings
     */
    select?: FulfillmentSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentSettings
     */
    omit?: FulfillmentSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentSettingsInclude<ExtArgs> | null
    /**
     * Filter, which FulfillmentSettings to fetch.
     */
    where?: FulfillmentSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FulfillmentSettings to fetch.
     */
    orderBy?: FulfillmentSettingsOrderByWithRelationInput | FulfillmentSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FulfillmentSettings.
     */
    cursor?: FulfillmentSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FulfillmentSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FulfillmentSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FulfillmentSettings.
     */
    distinct?: FulfillmentSettingsScalarFieldEnum | FulfillmentSettingsScalarFieldEnum[]
  }

  /**
   * FulfillmentSettings findFirstOrThrow
   */
  export type FulfillmentSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentSettings
     */
    select?: FulfillmentSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentSettings
     */
    omit?: FulfillmentSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentSettingsInclude<ExtArgs> | null
    /**
     * Filter, which FulfillmentSettings to fetch.
     */
    where?: FulfillmentSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FulfillmentSettings to fetch.
     */
    orderBy?: FulfillmentSettingsOrderByWithRelationInput | FulfillmentSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FulfillmentSettings.
     */
    cursor?: FulfillmentSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FulfillmentSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FulfillmentSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FulfillmentSettings.
     */
    distinct?: FulfillmentSettingsScalarFieldEnum | FulfillmentSettingsScalarFieldEnum[]
  }

  /**
   * FulfillmentSettings findMany
   */
  export type FulfillmentSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentSettings
     */
    select?: FulfillmentSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentSettings
     */
    omit?: FulfillmentSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentSettingsInclude<ExtArgs> | null
    /**
     * Filter, which FulfillmentSettings to fetch.
     */
    where?: FulfillmentSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FulfillmentSettings to fetch.
     */
    orderBy?: FulfillmentSettingsOrderByWithRelationInput | FulfillmentSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FulfillmentSettings.
     */
    cursor?: FulfillmentSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FulfillmentSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FulfillmentSettings.
     */
    skip?: number
    distinct?: FulfillmentSettingsScalarFieldEnum | FulfillmentSettingsScalarFieldEnum[]
  }

  /**
   * FulfillmentSettings create
   */
  export type FulfillmentSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentSettings
     */
    select?: FulfillmentSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentSettings
     */
    omit?: FulfillmentSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a FulfillmentSettings.
     */
    data: XOR<FulfillmentSettingsCreateInput, FulfillmentSettingsUncheckedCreateInput>
  }

  /**
   * FulfillmentSettings createMany
   */
  export type FulfillmentSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FulfillmentSettings.
     */
    data: FulfillmentSettingsCreateManyInput | FulfillmentSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FulfillmentSettings createManyAndReturn
   */
  export type FulfillmentSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentSettings
     */
    select?: FulfillmentSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentSettings
     */
    omit?: FulfillmentSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many FulfillmentSettings.
     */
    data: FulfillmentSettingsCreateManyInput | FulfillmentSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FulfillmentSettings update
   */
  export type FulfillmentSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentSettings
     */
    select?: FulfillmentSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentSettings
     */
    omit?: FulfillmentSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a FulfillmentSettings.
     */
    data: XOR<FulfillmentSettingsUpdateInput, FulfillmentSettingsUncheckedUpdateInput>
    /**
     * Choose, which FulfillmentSettings to update.
     */
    where: FulfillmentSettingsWhereUniqueInput
  }

  /**
   * FulfillmentSettings updateMany
   */
  export type FulfillmentSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FulfillmentSettings.
     */
    data: XOR<FulfillmentSettingsUpdateManyMutationInput, FulfillmentSettingsUncheckedUpdateManyInput>
    /**
     * Filter which FulfillmentSettings to update
     */
    where?: FulfillmentSettingsWhereInput
    /**
     * Limit how many FulfillmentSettings to update.
     */
    limit?: number
  }

  /**
   * FulfillmentSettings updateManyAndReturn
   */
  export type FulfillmentSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentSettings
     */
    select?: FulfillmentSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentSettings
     */
    omit?: FulfillmentSettingsOmit<ExtArgs> | null
    /**
     * The data used to update FulfillmentSettings.
     */
    data: XOR<FulfillmentSettingsUpdateManyMutationInput, FulfillmentSettingsUncheckedUpdateManyInput>
    /**
     * Filter which FulfillmentSettings to update
     */
    where?: FulfillmentSettingsWhereInput
    /**
     * Limit how many FulfillmentSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FulfillmentSettings upsert
   */
  export type FulfillmentSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentSettings
     */
    select?: FulfillmentSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentSettings
     */
    omit?: FulfillmentSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the FulfillmentSettings to update in case it exists.
     */
    where: FulfillmentSettingsWhereUniqueInput
    /**
     * In case the FulfillmentSettings found by the `where` argument doesn't exist, create a new FulfillmentSettings with this data.
     */
    create: XOR<FulfillmentSettingsCreateInput, FulfillmentSettingsUncheckedCreateInput>
    /**
     * In case the FulfillmentSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FulfillmentSettingsUpdateInput, FulfillmentSettingsUncheckedUpdateInput>
  }

  /**
   * FulfillmentSettings delete
   */
  export type FulfillmentSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentSettings
     */
    select?: FulfillmentSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentSettings
     */
    omit?: FulfillmentSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentSettingsInclude<ExtArgs> | null
    /**
     * Filter which FulfillmentSettings to delete.
     */
    where: FulfillmentSettingsWhereUniqueInput
  }

  /**
   * FulfillmentSettings deleteMany
   */
  export type FulfillmentSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FulfillmentSettings to delete
     */
    where?: FulfillmentSettingsWhereInput
    /**
     * Limit how many FulfillmentSettings to delete.
     */
    limit?: number
  }

  /**
   * FulfillmentSettings without action
   */
  export type FulfillmentSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentSettings
     */
    select?: FulfillmentSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentSettings
     */
    omit?: FulfillmentSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentSettingsInclude<ExtArgs> | null
  }


  /**
   * Model KYCDocument
   */

  export type AggregateKYCDocument = {
    _count: KYCDocumentCountAggregateOutputType | null
    _min: KYCDocumentMinAggregateOutputType | null
    _max: KYCDocumentMaxAggregateOutputType | null
  }

  export type KYCDocumentMinAggregateOutputType = {
    id: string | null
    sellerId: string | null
    documentType: string | null
    documentNumber: string | null
    documentUrl: string | null
    country: string | null
    status: $Enums.KYCStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KYCDocumentMaxAggregateOutputType = {
    id: string | null
    sellerId: string | null
    documentType: string | null
    documentNumber: string | null
    documentUrl: string | null
    country: string | null
    status: $Enums.KYCStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KYCDocumentCountAggregateOutputType = {
    id: number
    sellerId: number
    documentType: number
    documentNumber: number
    documentUrl: number
    country: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KYCDocumentMinAggregateInputType = {
    id?: true
    sellerId?: true
    documentType?: true
    documentNumber?: true
    documentUrl?: true
    country?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KYCDocumentMaxAggregateInputType = {
    id?: true
    sellerId?: true
    documentType?: true
    documentNumber?: true
    documentUrl?: true
    country?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KYCDocumentCountAggregateInputType = {
    id?: true
    sellerId?: true
    documentType?: true
    documentNumber?: true
    documentUrl?: true
    country?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KYCDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KYCDocument to aggregate.
     */
    where?: KYCDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCDocuments to fetch.
     */
    orderBy?: KYCDocumentOrderByWithRelationInput | KYCDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KYCDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KYCDocuments
    **/
    _count?: true | KYCDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KYCDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KYCDocumentMaxAggregateInputType
  }

  export type GetKYCDocumentAggregateType<T extends KYCDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateKYCDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKYCDocument[P]>
      : GetScalarType<T[P], AggregateKYCDocument[P]>
  }




  export type KYCDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KYCDocumentWhereInput
    orderBy?: KYCDocumentOrderByWithAggregationInput | KYCDocumentOrderByWithAggregationInput[]
    by: KYCDocumentScalarFieldEnum[] | KYCDocumentScalarFieldEnum
    having?: KYCDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KYCDocumentCountAggregateInputType | true
    _min?: KYCDocumentMinAggregateInputType
    _max?: KYCDocumentMaxAggregateInputType
  }

  export type KYCDocumentGroupByOutputType = {
    id: string
    sellerId: string
    documentType: string
    documentNumber: string
    documentUrl: string
    country: string
    status: $Enums.KYCStatus
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: KYCDocumentCountAggregateOutputType | null
    _min: KYCDocumentMinAggregateOutputType | null
    _max: KYCDocumentMaxAggregateOutputType | null
  }

  type GetKYCDocumentGroupByPayload<T extends KYCDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KYCDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KYCDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KYCDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], KYCDocumentGroupByOutputType[P]>
        }
      >
    >


  export type KYCDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    documentType?: boolean
    documentNumber?: boolean
    documentUrl?: boolean
    country?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kYCDocument"]>

  export type KYCDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    documentType?: boolean
    documentNumber?: boolean
    documentUrl?: boolean
    country?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kYCDocument"]>

  export type KYCDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    documentType?: boolean
    documentNumber?: boolean
    documentUrl?: boolean
    country?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kYCDocument"]>

  export type KYCDocumentSelectScalar = {
    id?: boolean
    sellerId?: boolean
    documentType?: boolean
    documentNumber?: boolean
    documentUrl?: boolean
    country?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KYCDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sellerId" | "documentType" | "documentNumber" | "documentUrl" | "country" | "status" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["kYCDocument"]>
  export type KYCDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type KYCDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type KYCDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $KYCDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KYCDocument"
    objects: {
      seller: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sellerId: string
      documentType: string
      documentNumber: string
      documentUrl: string
      country: string
      status: $Enums.KYCStatus
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["kYCDocument"]>
    composites: {}
  }

  type KYCDocumentGetPayload<S extends boolean | null | undefined | KYCDocumentDefaultArgs> = $Result.GetResult<Prisma.$KYCDocumentPayload, S>

  type KYCDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KYCDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KYCDocumentCountAggregateInputType | true
    }

  export interface KYCDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KYCDocument'], meta: { name: 'KYCDocument' } }
    /**
     * Find zero or one KYCDocument that matches the filter.
     * @param {KYCDocumentFindUniqueArgs} args - Arguments to find a KYCDocument
     * @example
     * // Get one KYCDocument
     * const kYCDocument = await prisma.kYCDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KYCDocumentFindUniqueArgs>(args: SelectSubset<T, KYCDocumentFindUniqueArgs<ExtArgs>>): Prisma__KYCDocumentClient<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KYCDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KYCDocumentFindUniqueOrThrowArgs} args - Arguments to find a KYCDocument
     * @example
     * // Get one KYCDocument
     * const kYCDocument = await prisma.kYCDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KYCDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, KYCDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KYCDocumentClient<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KYCDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCDocumentFindFirstArgs} args - Arguments to find a KYCDocument
     * @example
     * // Get one KYCDocument
     * const kYCDocument = await prisma.kYCDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KYCDocumentFindFirstArgs>(args?: SelectSubset<T, KYCDocumentFindFirstArgs<ExtArgs>>): Prisma__KYCDocumentClient<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KYCDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCDocumentFindFirstOrThrowArgs} args - Arguments to find a KYCDocument
     * @example
     * // Get one KYCDocument
     * const kYCDocument = await prisma.kYCDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KYCDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, KYCDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__KYCDocumentClient<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KYCDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KYCDocuments
     * const kYCDocuments = await prisma.kYCDocument.findMany()
     * 
     * // Get first 10 KYCDocuments
     * const kYCDocuments = await prisma.kYCDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kYCDocumentWithIdOnly = await prisma.kYCDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KYCDocumentFindManyArgs>(args?: SelectSubset<T, KYCDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KYCDocument.
     * @param {KYCDocumentCreateArgs} args - Arguments to create a KYCDocument.
     * @example
     * // Create one KYCDocument
     * const KYCDocument = await prisma.kYCDocument.create({
     *   data: {
     *     // ... data to create a KYCDocument
     *   }
     * })
     * 
     */
    create<T extends KYCDocumentCreateArgs>(args: SelectSubset<T, KYCDocumentCreateArgs<ExtArgs>>): Prisma__KYCDocumentClient<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KYCDocuments.
     * @param {KYCDocumentCreateManyArgs} args - Arguments to create many KYCDocuments.
     * @example
     * // Create many KYCDocuments
     * const kYCDocument = await prisma.kYCDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KYCDocumentCreateManyArgs>(args?: SelectSubset<T, KYCDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KYCDocuments and returns the data saved in the database.
     * @param {KYCDocumentCreateManyAndReturnArgs} args - Arguments to create many KYCDocuments.
     * @example
     * // Create many KYCDocuments
     * const kYCDocument = await prisma.kYCDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KYCDocuments and only return the `id`
     * const kYCDocumentWithIdOnly = await prisma.kYCDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KYCDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, KYCDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KYCDocument.
     * @param {KYCDocumentDeleteArgs} args - Arguments to delete one KYCDocument.
     * @example
     * // Delete one KYCDocument
     * const KYCDocument = await prisma.kYCDocument.delete({
     *   where: {
     *     // ... filter to delete one KYCDocument
     *   }
     * })
     * 
     */
    delete<T extends KYCDocumentDeleteArgs>(args: SelectSubset<T, KYCDocumentDeleteArgs<ExtArgs>>): Prisma__KYCDocumentClient<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KYCDocument.
     * @param {KYCDocumentUpdateArgs} args - Arguments to update one KYCDocument.
     * @example
     * // Update one KYCDocument
     * const kYCDocument = await prisma.kYCDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KYCDocumentUpdateArgs>(args: SelectSubset<T, KYCDocumentUpdateArgs<ExtArgs>>): Prisma__KYCDocumentClient<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KYCDocuments.
     * @param {KYCDocumentDeleteManyArgs} args - Arguments to filter KYCDocuments to delete.
     * @example
     * // Delete a few KYCDocuments
     * const { count } = await prisma.kYCDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KYCDocumentDeleteManyArgs>(args?: SelectSubset<T, KYCDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KYCDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KYCDocuments
     * const kYCDocument = await prisma.kYCDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KYCDocumentUpdateManyArgs>(args: SelectSubset<T, KYCDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KYCDocuments and returns the data updated in the database.
     * @param {KYCDocumentUpdateManyAndReturnArgs} args - Arguments to update many KYCDocuments.
     * @example
     * // Update many KYCDocuments
     * const kYCDocument = await prisma.kYCDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KYCDocuments and only return the `id`
     * const kYCDocumentWithIdOnly = await prisma.kYCDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KYCDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, KYCDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KYCDocument.
     * @param {KYCDocumentUpsertArgs} args - Arguments to update or create a KYCDocument.
     * @example
     * // Update or create a KYCDocument
     * const kYCDocument = await prisma.kYCDocument.upsert({
     *   create: {
     *     // ... data to create a KYCDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KYCDocument we want to update
     *   }
     * })
     */
    upsert<T extends KYCDocumentUpsertArgs>(args: SelectSubset<T, KYCDocumentUpsertArgs<ExtArgs>>): Prisma__KYCDocumentClient<$Result.GetResult<Prisma.$KYCDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KYCDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCDocumentCountArgs} args - Arguments to filter KYCDocuments to count.
     * @example
     * // Count the number of KYCDocuments
     * const count = await prisma.kYCDocument.count({
     *   where: {
     *     // ... the filter for the KYCDocuments we want to count
     *   }
     * })
    **/
    count<T extends KYCDocumentCountArgs>(
      args?: Subset<T, KYCDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KYCDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KYCDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KYCDocumentAggregateArgs>(args: Subset<T, KYCDocumentAggregateArgs>): Prisma.PrismaPromise<GetKYCDocumentAggregateType<T>>

    /**
     * Group by KYCDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KYCDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KYCDocumentGroupByArgs['orderBy'] }
        : { orderBy?: KYCDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KYCDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKYCDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KYCDocument model
   */
  readonly fields: KYCDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KYCDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KYCDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KYCDocument model
   */
  interface KYCDocumentFieldRefs {
    readonly id: FieldRef<"KYCDocument", 'String'>
    readonly sellerId: FieldRef<"KYCDocument", 'String'>
    readonly documentType: FieldRef<"KYCDocument", 'String'>
    readonly documentNumber: FieldRef<"KYCDocument", 'String'>
    readonly documentUrl: FieldRef<"KYCDocument", 'String'>
    readonly country: FieldRef<"KYCDocument", 'String'>
    readonly status: FieldRef<"KYCDocument", 'KYCStatus'>
    readonly notes: FieldRef<"KYCDocument", 'String'>
    readonly createdAt: FieldRef<"KYCDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"KYCDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KYCDocument findUnique
   */
  export type KYCDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KYCDocument to fetch.
     */
    where: KYCDocumentWhereUniqueInput
  }

  /**
   * KYCDocument findUniqueOrThrow
   */
  export type KYCDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KYCDocument to fetch.
     */
    where: KYCDocumentWhereUniqueInput
  }

  /**
   * KYCDocument findFirst
   */
  export type KYCDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KYCDocument to fetch.
     */
    where?: KYCDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCDocuments to fetch.
     */
    orderBy?: KYCDocumentOrderByWithRelationInput | KYCDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KYCDocuments.
     */
    cursor?: KYCDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KYCDocuments.
     */
    distinct?: KYCDocumentScalarFieldEnum | KYCDocumentScalarFieldEnum[]
  }

  /**
   * KYCDocument findFirstOrThrow
   */
  export type KYCDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KYCDocument to fetch.
     */
    where?: KYCDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCDocuments to fetch.
     */
    orderBy?: KYCDocumentOrderByWithRelationInput | KYCDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KYCDocuments.
     */
    cursor?: KYCDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KYCDocuments.
     */
    distinct?: KYCDocumentScalarFieldEnum | KYCDocumentScalarFieldEnum[]
  }

  /**
   * KYCDocument findMany
   */
  export type KYCDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KYCDocuments to fetch.
     */
    where?: KYCDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCDocuments to fetch.
     */
    orderBy?: KYCDocumentOrderByWithRelationInput | KYCDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KYCDocuments.
     */
    cursor?: KYCDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCDocuments.
     */
    skip?: number
    distinct?: KYCDocumentScalarFieldEnum | KYCDocumentScalarFieldEnum[]
  }

  /**
   * KYCDocument create
   */
  export type KYCDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a KYCDocument.
     */
    data: XOR<KYCDocumentCreateInput, KYCDocumentUncheckedCreateInput>
  }

  /**
   * KYCDocument createMany
   */
  export type KYCDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KYCDocuments.
     */
    data: KYCDocumentCreateManyInput | KYCDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KYCDocument createManyAndReturn
   */
  export type KYCDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many KYCDocuments.
     */
    data: KYCDocumentCreateManyInput | KYCDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KYCDocument update
   */
  export type KYCDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a KYCDocument.
     */
    data: XOR<KYCDocumentUpdateInput, KYCDocumentUncheckedUpdateInput>
    /**
     * Choose, which KYCDocument to update.
     */
    where: KYCDocumentWhereUniqueInput
  }

  /**
   * KYCDocument updateMany
   */
  export type KYCDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KYCDocuments.
     */
    data: XOR<KYCDocumentUpdateManyMutationInput, KYCDocumentUncheckedUpdateManyInput>
    /**
     * Filter which KYCDocuments to update
     */
    where?: KYCDocumentWhereInput
    /**
     * Limit how many KYCDocuments to update.
     */
    limit?: number
  }

  /**
   * KYCDocument updateManyAndReturn
   */
  export type KYCDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * The data used to update KYCDocuments.
     */
    data: XOR<KYCDocumentUpdateManyMutationInput, KYCDocumentUncheckedUpdateManyInput>
    /**
     * Filter which KYCDocuments to update
     */
    where?: KYCDocumentWhereInput
    /**
     * Limit how many KYCDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KYCDocument upsert
   */
  export type KYCDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the KYCDocument to update in case it exists.
     */
    where: KYCDocumentWhereUniqueInput
    /**
     * In case the KYCDocument found by the `where` argument doesn't exist, create a new KYCDocument with this data.
     */
    create: XOR<KYCDocumentCreateInput, KYCDocumentUncheckedCreateInput>
    /**
     * In case the KYCDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KYCDocumentUpdateInput, KYCDocumentUncheckedUpdateInput>
  }

  /**
   * KYCDocument delete
   */
  export type KYCDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
    /**
     * Filter which KYCDocument to delete.
     */
    where: KYCDocumentWhereUniqueInput
  }

  /**
   * KYCDocument deleteMany
   */
  export type KYCDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KYCDocuments to delete
     */
    where?: KYCDocumentWhereInput
    /**
     * Limit how many KYCDocuments to delete.
     */
    limit?: number
  }

  /**
   * KYCDocument without action
   */
  export type KYCDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCDocument
     */
    select?: KYCDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCDocument
     */
    omit?: KYCDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCDocumentInclude<ExtArgs> | null
  }


  /**
   * Model TaxRegistration
   */

  export type AggregateTaxRegistration = {
    _count: TaxRegistrationCountAggregateOutputType | null
    _min: TaxRegistrationMinAggregateOutputType | null
    _max: TaxRegistrationMaxAggregateOutputType | null
  }

  export type TaxRegistrationMinAggregateOutputType = {
    id: string | null
    sellerId: string | null
    taxId: string | null
    country: string | null
    status: $Enums.TaxStatus | null
    expiryDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxRegistrationMaxAggregateOutputType = {
    id: string | null
    sellerId: string | null
    taxId: string | null
    country: string | null
    status: $Enums.TaxStatus | null
    expiryDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxRegistrationCountAggregateOutputType = {
    id: number
    sellerId: number
    taxId: number
    country: number
    status: number
    expiryDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaxRegistrationMinAggregateInputType = {
    id?: true
    sellerId?: true
    taxId?: true
    country?: true
    status?: true
    expiryDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxRegistrationMaxAggregateInputType = {
    id?: true
    sellerId?: true
    taxId?: true
    country?: true
    status?: true
    expiryDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxRegistrationCountAggregateInputType = {
    id?: true
    sellerId?: true
    taxId?: true
    country?: true
    status?: true
    expiryDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaxRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxRegistration to aggregate.
     */
    where?: TaxRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxRegistrations to fetch.
     */
    orderBy?: TaxRegistrationOrderByWithRelationInput | TaxRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxRegistrations
    **/
    _count?: true | TaxRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxRegistrationMaxAggregateInputType
  }

  export type GetTaxRegistrationAggregateType<T extends TaxRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxRegistration[P]>
      : GetScalarType<T[P], AggregateTaxRegistration[P]>
  }




  export type TaxRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxRegistrationWhereInput
    orderBy?: TaxRegistrationOrderByWithAggregationInput | TaxRegistrationOrderByWithAggregationInput[]
    by: TaxRegistrationScalarFieldEnum[] | TaxRegistrationScalarFieldEnum
    having?: TaxRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxRegistrationCountAggregateInputType | true
    _min?: TaxRegistrationMinAggregateInputType
    _max?: TaxRegistrationMaxAggregateInputType
  }

  export type TaxRegistrationGroupByOutputType = {
    id: string
    sellerId: string
    taxId: string
    country: string
    status: $Enums.TaxStatus
    expiryDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TaxRegistrationCountAggregateOutputType | null
    _min: TaxRegistrationMinAggregateOutputType | null
    _max: TaxRegistrationMaxAggregateOutputType | null
  }

  type GetTaxRegistrationGroupByPayload<T extends TaxRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], TaxRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type TaxRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    taxId?: boolean
    country?: boolean
    status?: boolean
    expiryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxRegistration"]>

  export type TaxRegistrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    taxId?: boolean
    country?: boolean
    status?: boolean
    expiryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxRegistration"]>

  export type TaxRegistrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    taxId?: boolean
    country?: boolean
    status?: boolean
    expiryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxRegistration"]>

  export type TaxRegistrationSelectScalar = {
    id?: boolean
    sellerId?: boolean
    taxId?: boolean
    country?: boolean
    status?: boolean
    expiryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaxRegistrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sellerId" | "taxId" | "country" | "status" | "expiryDate" | "createdAt" | "updatedAt", ExtArgs["result"]["taxRegistration"]>
  export type TaxRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaxRegistrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaxRegistrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaxRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxRegistration"
    objects: {
      seller: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sellerId: string
      taxId: string
      country: string
      status: $Enums.TaxStatus
      expiryDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taxRegistration"]>
    composites: {}
  }

  type TaxRegistrationGetPayload<S extends boolean | null | undefined | TaxRegistrationDefaultArgs> = $Result.GetResult<Prisma.$TaxRegistrationPayload, S>

  type TaxRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaxRegistrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxRegistrationCountAggregateInputType | true
    }

  export interface TaxRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxRegistration'], meta: { name: 'TaxRegistration' } }
    /**
     * Find zero or one TaxRegistration that matches the filter.
     * @param {TaxRegistrationFindUniqueArgs} args - Arguments to find a TaxRegistration
     * @example
     * // Get one TaxRegistration
     * const taxRegistration = await prisma.taxRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxRegistrationFindUniqueArgs>(args: SelectSubset<T, TaxRegistrationFindUniqueArgs<ExtArgs>>): Prisma__TaxRegistrationClient<$Result.GetResult<Prisma.$TaxRegistrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaxRegistration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaxRegistrationFindUniqueOrThrowArgs} args - Arguments to find a TaxRegistration
     * @example
     * // Get one TaxRegistration
     * const taxRegistration = await prisma.taxRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxRegistrationClient<$Result.GetResult<Prisma.$TaxRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRegistrationFindFirstArgs} args - Arguments to find a TaxRegistration
     * @example
     * // Get one TaxRegistration
     * const taxRegistration = await prisma.taxRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxRegistrationFindFirstArgs>(args?: SelectSubset<T, TaxRegistrationFindFirstArgs<ExtArgs>>): Prisma__TaxRegistrationClient<$Result.GetResult<Prisma.$TaxRegistrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRegistrationFindFirstOrThrowArgs} args - Arguments to find a TaxRegistration
     * @example
     * // Get one TaxRegistration
     * const taxRegistration = await prisma.taxRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxRegistrationClient<$Result.GetResult<Prisma.$TaxRegistrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaxRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxRegistrations
     * const taxRegistrations = await prisma.taxRegistration.findMany()
     * 
     * // Get first 10 TaxRegistrations
     * const taxRegistrations = await prisma.taxRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxRegistrationWithIdOnly = await prisma.taxRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxRegistrationFindManyArgs>(args?: SelectSubset<T, TaxRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaxRegistration.
     * @param {TaxRegistrationCreateArgs} args - Arguments to create a TaxRegistration.
     * @example
     * // Create one TaxRegistration
     * const TaxRegistration = await prisma.taxRegistration.create({
     *   data: {
     *     // ... data to create a TaxRegistration
     *   }
     * })
     * 
     */
    create<T extends TaxRegistrationCreateArgs>(args: SelectSubset<T, TaxRegistrationCreateArgs<ExtArgs>>): Prisma__TaxRegistrationClient<$Result.GetResult<Prisma.$TaxRegistrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaxRegistrations.
     * @param {TaxRegistrationCreateManyArgs} args - Arguments to create many TaxRegistrations.
     * @example
     * // Create many TaxRegistrations
     * const taxRegistration = await prisma.taxRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxRegistrationCreateManyArgs>(args?: SelectSubset<T, TaxRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxRegistrations and returns the data saved in the database.
     * @param {TaxRegistrationCreateManyAndReturnArgs} args - Arguments to create many TaxRegistrations.
     * @example
     * // Create many TaxRegistrations
     * const taxRegistration = await prisma.taxRegistration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxRegistrations and only return the `id`
     * const taxRegistrationWithIdOnly = await prisma.taxRegistration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxRegistrationCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxRegistrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxRegistrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaxRegistration.
     * @param {TaxRegistrationDeleteArgs} args - Arguments to delete one TaxRegistration.
     * @example
     * // Delete one TaxRegistration
     * const TaxRegistration = await prisma.taxRegistration.delete({
     *   where: {
     *     // ... filter to delete one TaxRegistration
     *   }
     * })
     * 
     */
    delete<T extends TaxRegistrationDeleteArgs>(args: SelectSubset<T, TaxRegistrationDeleteArgs<ExtArgs>>): Prisma__TaxRegistrationClient<$Result.GetResult<Prisma.$TaxRegistrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaxRegistration.
     * @param {TaxRegistrationUpdateArgs} args - Arguments to update one TaxRegistration.
     * @example
     * // Update one TaxRegistration
     * const taxRegistration = await prisma.taxRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxRegistrationUpdateArgs>(args: SelectSubset<T, TaxRegistrationUpdateArgs<ExtArgs>>): Prisma__TaxRegistrationClient<$Result.GetResult<Prisma.$TaxRegistrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaxRegistrations.
     * @param {TaxRegistrationDeleteManyArgs} args - Arguments to filter TaxRegistrations to delete.
     * @example
     * // Delete a few TaxRegistrations
     * const { count } = await prisma.taxRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxRegistrationDeleteManyArgs>(args?: SelectSubset<T, TaxRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxRegistrations
     * const taxRegistration = await prisma.taxRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxRegistrationUpdateManyArgs>(args: SelectSubset<T, TaxRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxRegistrations and returns the data updated in the database.
     * @param {TaxRegistrationUpdateManyAndReturnArgs} args - Arguments to update many TaxRegistrations.
     * @example
     * // Update many TaxRegistrations
     * const taxRegistration = await prisma.taxRegistration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaxRegistrations and only return the `id`
     * const taxRegistrationWithIdOnly = await prisma.taxRegistration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaxRegistrationUpdateManyAndReturnArgs>(args: SelectSubset<T, TaxRegistrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxRegistrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaxRegistration.
     * @param {TaxRegistrationUpsertArgs} args - Arguments to update or create a TaxRegistration.
     * @example
     * // Update or create a TaxRegistration
     * const taxRegistration = await prisma.taxRegistration.upsert({
     *   create: {
     *     // ... data to create a TaxRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxRegistration we want to update
     *   }
     * })
     */
    upsert<T extends TaxRegistrationUpsertArgs>(args: SelectSubset<T, TaxRegistrationUpsertArgs<ExtArgs>>): Prisma__TaxRegistrationClient<$Result.GetResult<Prisma.$TaxRegistrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaxRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRegistrationCountArgs} args - Arguments to filter TaxRegistrations to count.
     * @example
     * // Count the number of TaxRegistrations
     * const count = await prisma.taxRegistration.count({
     *   where: {
     *     // ... the filter for the TaxRegistrations we want to count
     *   }
     * })
    **/
    count<T extends TaxRegistrationCountArgs>(
      args?: Subset<T, TaxRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxRegistrationAggregateArgs>(args: Subset<T, TaxRegistrationAggregateArgs>): Prisma.PrismaPromise<GetTaxRegistrationAggregateType<T>>

    /**
     * Group by TaxRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: TaxRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxRegistration model
   */
  readonly fields: TaxRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxRegistration model
   */
  interface TaxRegistrationFieldRefs {
    readonly id: FieldRef<"TaxRegistration", 'String'>
    readonly sellerId: FieldRef<"TaxRegistration", 'String'>
    readonly taxId: FieldRef<"TaxRegistration", 'String'>
    readonly country: FieldRef<"TaxRegistration", 'String'>
    readonly status: FieldRef<"TaxRegistration", 'TaxStatus'>
    readonly expiryDate: FieldRef<"TaxRegistration", 'DateTime'>
    readonly createdAt: FieldRef<"TaxRegistration", 'DateTime'>
    readonly updatedAt: FieldRef<"TaxRegistration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaxRegistration findUnique
   */
  export type TaxRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRegistration
     */
    select?: TaxRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRegistration
     */
    omit?: TaxRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which TaxRegistration to fetch.
     */
    where: TaxRegistrationWhereUniqueInput
  }

  /**
   * TaxRegistration findUniqueOrThrow
   */
  export type TaxRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRegistration
     */
    select?: TaxRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRegistration
     */
    omit?: TaxRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which TaxRegistration to fetch.
     */
    where: TaxRegistrationWhereUniqueInput
  }

  /**
   * TaxRegistration findFirst
   */
  export type TaxRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRegistration
     */
    select?: TaxRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRegistration
     */
    omit?: TaxRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which TaxRegistration to fetch.
     */
    where?: TaxRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxRegistrations to fetch.
     */
    orderBy?: TaxRegistrationOrderByWithRelationInput | TaxRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxRegistrations.
     */
    cursor?: TaxRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxRegistrations.
     */
    distinct?: TaxRegistrationScalarFieldEnum | TaxRegistrationScalarFieldEnum[]
  }

  /**
   * TaxRegistration findFirstOrThrow
   */
  export type TaxRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRegistration
     */
    select?: TaxRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRegistration
     */
    omit?: TaxRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which TaxRegistration to fetch.
     */
    where?: TaxRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxRegistrations to fetch.
     */
    orderBy?: TaxRegistrationOrderByWithRelationInput | TaxRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxRegistrations.
     */
    cursor?: TaxRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxRegistrations.
     */
    distinct?: TaxRegistrationScalarFieldEnum | TaxRegistrationScalarFieldEnum[]
  }

  /**
   * TaxRegistration findMany
   */
  export type TaxRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRegistration
     */
    select?: TaxRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRegistration
     */
    omit?: TaxRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which TaxRegistrations to fetch.
     */
    where?: TaxRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxRegistrations to fetch.
     */
    orderBy?: TaxRegistrationOrderByWithRelationInput | TaxRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxRegistrations.
     */
    cursor?: TaxRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxRegistrations.
     */
    skip?: number
    distinct?: TaxRegistrationScalarFieldEnum | TaxRegistrationScalarFieldEnum[]
  }

  /**
   * TaxRegistration create
   */
  export type TaxRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRegistration
     */
    select?: TaxRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRegistration
     */
    omit?: TaxRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a TaxRegistration.
     */
    data: XOR<TaxRegistrationCreateInput, TaxRegistrationUncheckedCreateInput>
  }

  /**
   * TaxRegistration createMany
   */
  export type TaxRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxRegistrations.
     */
    data: TaxRegistrationCreateManyInput | TaxRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxRegistration createManyAndReturn
   */
  export type TaxRegistrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRegistration
     */
    select?: TaxRegistrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRegistration
     */
    omit?: TaxRegistrationOmit<ExtArgs> | null
    /**
     * The data used to create many TaxRegistrations.
     */
    data: TaxRegistrationCreateManyInput | TaxRegistrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRegistrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxRegistration update
   */
  export type TaxRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRegistration
     */
    select?: TaxRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRegistration
     */
    omit?: TaxRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a TaxRegistration.
     */
    data: XOR<TaxRegistrationUpdateInput, TaxRegistrationUncheckedUpdateInput>
    /**
     * Choose, which TaxRegistration to update.
     */
    where: TaxRegistrationWhereUniqueInput
  }

  /**
   * TaxRegistration updateMany
   */
  export type TaxRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxRegistrations.
     */
    data: XOR<TaxRegistrationUpdateManyMutationInput, TaxRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which TaxRegistrations to update
     */
    where?: TaxRegistrationWhereInput
    /**
     * Limit how many TaxRegistrations to update.
     */
    limit?: number
  }

  /**
   * TaxRegistration updateManyAndReturn
   */
  export type TaxRegistrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRegistration
     */
    select?: TaxRegistrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRegistration
     */
    omit?: TaxRegistrationOmit<ExtArgs> | null
    /**
     * The data used to update TaxRegistrations.
     */
    data: XOR<TaxRegistrationUpdateManyMutationInput, TaxRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which TaxRegistrations to update
     */
    where?: TaxRegistrationWhereInput
    /**
     * Limit how many TaxRegistrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRegistrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxRegistration upsert
   */
  export type TaxRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRegistration
     */
    select?: TaxRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRegistration
     */
    omit?: TaxRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the TaxRegistration to update in case it exists.
     */
    where: TaxRegistrationWhereUniqueInput
    /**
     * In case the TaxRegistration found by the `where` argument doesn't exist, create a new TaxRegistration with this data.
     */
    create: XOR<TaxRegistrationCreateInput, TaxRegistrationUncheckedCreateInput>
    /**
     * In case the TaxRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxRegistrationUpdateInput, TaxRegistrationUncheckedUpdateInput>
  }

  /**
   * TaxRegistration delete
   */
  export type TaxRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRegistration
     */
    select?: TaxRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRegistration
     */
    omit?: TaxRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRegistrationInclude<ExtArgs> | null
    /**
     * Filter which TaxRegistration to delete.
     */
    where: TaxRegistrationWhereUniqueInput
  }

  /**
   * TaxRegistration deleteMany
   */
  export type TaxRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxRegistrations to delete
     */
    where?: TaxRegistrationWhereInput
    /**
     * Limit how many TaxRegistrations to delete.
     */
    limit?: number
  }

  /**
   * TaxRegistration without action
   */
  export type TaxRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRegistration
     */
    select?: TaxRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRegistration
     */
    omit?: TaxRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model CounterfeitReport
   */

  export type AggregateCounterfeitReport = {
    _count: CounterfeitReportCountAggregateOutputType | null
    _min: CounterfeitReportMinAggregateOutputType | null
    _max: CounterfeitReportMaxAggregateOutputType | null
  }

  export type CounterfeitReportMinAggregateOutputType = {
    id: string | null
    reporterId: string | null
    productId: string | null
    reason: string | null
    evidenceUrl: string | null
    status: $Enums.ReportStatus | null
    resolution: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CounterfeitReportMaxAggregateOutputType = {
    id: string | null
    reporterId: string | null
    productId: string | null
    reason: string | null
    evidenceUrl: string | null
    status: $Enums.ReportStatus | null
    resolution: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CounterfeitReportCountAggregateOutputType = {
    id: number
    reporterId: number
    productId: number
    reason: number
    evidenceUrl: number
    status: number
    resolution: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CounterfeitReportMinAggregateInputType = {
    id?: true
    reporterId?: true
    productId?: true
    reason?: true
    evidenceUrl?: true
    status?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CounterfeitReportMaxAggregateInputType = {
    id?: true
    reporterId?: true
    productId?: true
    reason?: true
    evidenceUrl?: true
    status?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CounterfeitReportCountAggregateInputType = {
    id?: true
    reporterId?: true
    productId?: true
    reason?: true
    evidenceUrl?: true
    status?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CounterfeitReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CounterfeitReport to aggregate.
     */
    where?: CounterfeitReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CounterfeitReports to fetch.
     */
    orderBy?: CounterfeitReportOrderByWithRelationInput | CounterfeitReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CounterfeitReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CounterfeitReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CounterfeitReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CounterfeitReports
    **/
    _count?: true | CounterfeitReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CounterfeitReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CounterfeitReportMaxAggregateInputType
  }

  export type GetCounterfeitReportAggregateType<T extends CounterfeitReportAggregateArgs> = {
        [P in keyof T & keyof AggregateCounterfeitReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCounterfeitReport[P]>
      : GetScalarType<T[P], AggregateCounterfeitReport[P]>
  }




  export type CounterfeitReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CounterfeitReportWhereInput
    orderBy?: CounterfeitReportOrderByWithAggregationInput | CounterfeitReportOrderByWithAggregationInput[]
    by: CounterfeitReportScalarFieldEnum[] | CounterfeitReportScalarFieldEnum
    having?: CounterfeitReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CounterfeitReportCountAggregateInputType | true
    _min?: CounterfeitReportMinAggregateInputType
    _max?: CounterfeitReportMaxAggregateInputType
  }

  export type CounterfeitReportGroupByOutputType = {
    id: string
    reporterId: string
    productId: string
    reason: string
    evidenceUrl: string | null
    status: $Enums.ReportStatus
    resolution: string | null
    createdAt: Date
    updatedAt: Date
    _count: CounterfeitReportCountAggregateOutputType | null
    _min: CounterfeitReportMinAggregateOutputType | null
    _max: CounterfeitReportMaxAggregateOutputType | null
  }

  type GetCounterfeitReportGroupByPayload<T extends CounterfeitReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CounterfeitReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CounterfeitReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CounterfeitReportGroupByOutputType[P]>
            : GetScalarType<T[P], CounterfeitReportGroupByOutputType[P]>
        }
      >
    >


  export type CounterfeitReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    productId?: boolean
    reason?: boolean
    evidenceUrl?: boolean
    status?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["counterfeitReport"]>

  export type CounterfeitReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    productId?: boolean
    reason?: boolean
    evidenceUrl?: boolean
    status?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["counterfeitReport"]>

  export type CounterfeitReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    productId?: boolean
    reason?: boolean
    evidenceUrl?: boolean
    status?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["counterfeitReport"]>

  export type CounterfeitReportSelectScalar = {
    id?: boolean
    reporterId?: boolean
    productId?: boolean
    reason?: boolean
    evidenceUrl?: boolean
    status?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CounterfeitReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reporterId" | "productId" | "reason" | "evidenceUrl" | "status" | "resolution" | "createdAt" | "updatedAt", ExtArgs["result"]["counterfeitReport"]>
  export type CounterfeitReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CounterfeitReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CounterfeitReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $CounterfeitReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CounterfeitReport"
    objects: {
      reporter: Prisma.$UserPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reporterId: string
      productId: string
      reason: string
      evidenceUrl: string | null
      status: $Enums.ReportStatus
      resolution: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["counterfeitReport"]>
    composites: {}
  }

  type CounterfeitReportGetPayload<S extends boolean | null | undefined | CounterfeitReportDefaultArgs> = $Result.GetResult<Prisma.$CounterfeitReportPayload, S>

  type CounterfeitReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CounterfeitReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CounterfeitReportCountAggregateInputType | true
    }

  export interface CounterfeitReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CounterfeitReport'], meta: { name: 'CounterfeitReport' } }
    /**
     * Find zero or one CounterfeitReport that matches the filter.
     * @param {CounterfeitReportFindUniqueArgs} args - Arguments to find a CounterfeitReport
     * @example
     * // Get one CounterfeitReport
     * const counterfeitReport = await prisma.counterfeitReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CounterfeitReportFindUniqueArgs>(args: SelectSubset<T, CounterfeitReportFindUniqueArgs<ExtArgs>>): Prisma__CounterfeitReportClient<$Result.GetResult<Prisma.$CounterfeitReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CounterfeitReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CounterfeitReportFindUniqueOrThrowArgs} args - Arguments to find a CounterfeitReport
     * @example
     * // Get one CounterfeitReport
     * const counterfeitReport = await prisma.counterfeitReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CounterfeitReportFindUniqueOrThrowArgs>(args: SelectSubset<T, CounterfeitReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CounterfeitReportClient<$Result.GetResult<Prisma.$CounterfeitReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CounterfeitReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterfeitReportFindFirstArgs} args - Arguments to find a CounterfeitReport
     * @example
     * // Get one CounterfeitReport
     * const counterfeitReport = await prisma.counterfeitReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CounterfeitReportFindFirstArgs>(args?: SelectSubset<T, CounterfeitReportFindFirstArgs<ExtArgs>>): Prisma__CounterfeitReportClient<$Result.GetResult<Prisma.$CounterfeitReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CounterfeitReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterfeitReportFindFirstOrThrowArgs} args - Arguments to find a CounterfeitReport
     * @example
     * // Get one CounterfeitReport
     * const counterfeitReport = await prisma.counterfeitReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CounterfeitReportFindFirstOrThrowArgs>(args?: SelectSubset<T, CounterfeitReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__CounterfeitReportClient<$Result.GetResult<Prisma.$CounterfeitReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CounterfeitReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterfeitReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CounterfeitReports
     * const counterfeitReports = await prisma.counterfeitReport.findMany()
     * 
     * // Get first 10 CounterfeitReports
     * const counterfeitReports = await prisma.counterfeitReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const counterfeitReportWithIdOnly = await prisma.counterfeitReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CounterfeitReportFindManyArgs>(args?: SelectSubset<T, CounterfeitReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CounterfeitReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CounterfeitReport.
     * @param {CounterfeitReportCreateArgs} args - Arguments to create a CounterfeitReport.
     * @example
     * // Create one CounterfeitReport
     * const CounterfeitReport = await prisma.counterfeitReport.create({
     *   data: {
     *     // ... data to create a CounterfeitReport
     *   }
     * })
     * 
     */
    create<T extends CounterfeitReportCreateArgs>(args: SelectSubset<T, CounterfeitReportCreateArgs<ExtArgs>>): Prisma__CounterfeitReportClient<$Result.GetResult<Prisma.$CounterfeitReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CounterfeitReports.
     * @param {CounterfeitReportCreateManyArgs} args - Arguments to create many CounterfeitReports.
     * @example
     * // Create many CounterfeitReports
     * const counterfeitReport = await prisma.counterfeitReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CounterfeitReportCreateManyArgs>(args?: SelectSubset<T, CounterfeitReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CounterfeitReports and returns the data saved in the database.
     * @param {CounterfeitReportCreateManyAndReturnArgs} args - Arguments to create many CounterfeitReports.
     * @example
     * // Create many CounterfeitReports
     * const counterfeitReport = await prisma.counterfeitReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CounterfeitReports and only return the `id`
     * const counterfeitReportWithIdOnly = await prisma.counterfeitReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CounterfeitReportCreateManyAndReturnArgs>(args?: SelectSubset<T, CounterfeitReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CounterfeitReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CounterfeitReport.
     * @param {CounterfeitReportDeleteArgs} args - Arguments to delete one CounterfeitReport.
     * @example
     * // Delete one CounterfeitReport
     * const CounterfeitReport = await prisma.counterfeitReport.delete({
     *   where: {
     *     // ... filter to delete one CounterfeitReport
     *   }
     * })
     * 
     */
    delete<T extends CounterfeitReportDeleteArgs>(args: SelectSubset<T, CounterfeitReportDeleteArgs<ExtArgs>>): Prisma__CounterfeitReportClient<$Result.GetResult<Prisma.$CounterfeitReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CounterfeitReport.
     * @param {CounterfeitReportUpdateArgs} args - Arguments to update one CounterfeitReport.
     * @example
     * // Update one CounterfeitReport
     * const counterfeitReport = await prisma.counterfeitReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CounterfeitReportUpdateArgs>(args: SelectSubset<T, CounterfeitReportUpdateArgs<ExtArgs>>): Prisma__CounterfeitReportClient<$Result.GetResult<Prisma.$CounterfeitReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CounterfeitReports.
     * @param {CounterfeitReportDeleteManyArgs} args - Arguments to filter CounterfeitReports to delete.
     * @example
     * // Delete a few CounterfeitReports
     * const { count } = await prisma.counterfeitReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CounterfeitReportDeleteManyArgs>(args?: SelectSubset<T, CounterfeitReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CounterfeitReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterfeitReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CounterfeitReports
     * const counterfeitReport = await prisma.counterfeitReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CounterfeitReportUpdateManyArgs>(args: SelectSubset<T, CounterfeitReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CounterfeitReports and returns the data updated in the database.
     * @param {CounterfeitReportUpdateManyAndReturnArgs} args - Arguments to update many CounterfeitReports.
     * @example
     * // Update many CounterfeitReports
     * const counterfeitReport = await prisma.counterfeitReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CounterfeitReports and only return the `id`
     * const counterfeitReportWithIdOnly = await prisma.counterfeitReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CounterfeitReportUpdateManyAndReturnArgs>(args: SelectSubset<T, CounterfeitReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CounterfeitReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CounterfeitReport.
     * @param {CounterfeitReportUpsertArgs} args - Arguments to update or create a CounterfeitReport.
     * @example
     * // Update or create a CounterfeitReport
     * const counterfeitReport = await prisma.counterfeitReport.upsert({
     *   create: {
     *     // ... data to create a CounterfeitReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CounterfeitReport we want to update
     *   }
     * })
     */
    upsert<T extends CounterfeitReportUpsertArgs>(args: SelectSubset<T, CounterfeitReportUpsertArgs<ExtArgs>>): Prisma__CounterfeitReportClient<$Result.GetResult<Prisma.$CounterfeitReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CounterfeitReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterfeitReportCountArgs} args - Arguments to filter CounterfeitReports to count.
     * @example
     * // Count the number of CounterfeitReports
     * const count = await prisma.counterfeitReport.count({
     *   where: {
     *     // ... the filter for the CounterfeitReports we want to count
     *   }
     * })
    **/
    count<T extends CounterfeitReportCountArgs>(
      args?: Subset<T, CounterfeitReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CounterfeitReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CounterfeitReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterfeitReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CounterfeitReportAggregateArgs>(args: Subset<T, CounterfeitReportAggregateArgs>): Prisma.PrismaPromise<GetCounterfeitReportAggregateType<T>>

    /**
     * Group by CounterfeitReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterfeitReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CounterfeitReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CounterfeitReportGroupByArgs['orderBy'] }
        : { orderBy?: CounterfeitReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CounterfeitReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCounterfeitReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CounterfeitReport model
   */
  readonly fields: CounterfeitReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CounterfeitReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CounterfeitReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reporter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CounterfeitReport model
   */
  interface CounterfeitReportFieldRefs {
    readonly id: FieldRef<"CounterfeitReport", 'String'>
    readonly reporterId: FieldRef<"CounterfeitReport", 'String'>
    readonly productId: FieldRef<"CounterfeitReport", 'String'>
    readonly reason: FieldRef<"CounterfeitReport", 'String'>
    readonly evidenceUrl: FieldRef<"CounterfeitReport", 'String'>
    readonly status: FieldRef<"CounterfeitReport", 'ReportStatus'>
    readonly resolution: FieldRef<"CounterfeitReport", 'String'>
    readonly createdAt: FieldRef<"CounterfeitReport", 'DateTime'>
    readonly updatedAt: FieldRef<"CounterfeitReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CounterfeitReport findUnique
   */
  export type CounterfeitReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterfeitReport
     */
    select?: CounterfeitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CounterfeitReport
     */
    omit?: CounterfeitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterfeitReportInclude<ExtArgs> | null
    /**
     * Filter, which CounterfeitReport to fetch.
     */
    where: CounterfeitReportWhereUniqueInput
  }

  /**
   * CounterfeitReport findUniqueOrThrow
   */
  export type CounterfeitReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterfeitReport
     */
    select?: CounterfeitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CounterfeitReport
     */
    omit?: CounterfeitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterfeitReportInclude<ExtArgs> | null
    /**
     * Filter, which CounterfeitReport to fetch.
     */
    where: CounterfeitReportWhereUniqueInput
  }

  /**
   * CounterfeitReport findFirst
   */
  export type CounterfeitReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterfeitReport
     */
    select?: CounterfeitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CounterfeitReport
     */
    omit?: CounterfeitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterfeitReportInclude<ExtArgs> | null
    /**
     * Filter, which CounterfeitReport to fetch.
     */
    where?: CounterfeitReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CounterfeitReports to fetch.
     */
    orderBy?: CounterfeitReportOrderByWithRelationInput | CounterfeitReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CounterfeitReports.
     */
    cursor?: CounterfeitReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CounterfeitReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CounterfeitReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CounterfeitReports.
     */
    distinct?: CounterfeitReportScalarFieldEnum | CounterfeitReportScalarFieldEnum[]
  }

  /**
   * CounterfeitReport findFirstOrThrow
   */
  export type CounterfeitReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterfeitReport
     */
    select?: CounterfeitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CounterfeitReport
     */
    omit?: CounterfeitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterfeitReportInclude<ExtArgs> | null
    /**
     * Filter, which CounterfeitReport to fetch.
     */
    where?: CounterfeitReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CounterfeitReports to fetch.
     */
    orderBy?: CounterfeitReportOrderByWithRelationInput | CounterfeitReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CounterfeitReports.
     */
    cursor?: CounterfeitReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CounterfeitReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CounterfeitReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CounterfeitReports.
     */
    distinct?: CounterfeitReportScalarFieldEnum | CounterfeitReportScalarFieldEnum[]
  }

  /**
   * CounterfeitReport findMany
   */
  export type CounterfeitReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterfeitReport
     */
    select?: CounterfeitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CounterfeitReport
     */
    omit?: CounterfeitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterfeitReportInclude<ExtArgs> | null
    /**
     * Filter, which CounterfeitReports to fetch.
     */
    where?: CounterfeitReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CounterfeitReports to fetch.
     */
    orderBy?: CounterfeitReportOrderByWithRelationInput | CounterfeitReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CounterfeitReports.
     */
    cursor?: CounterfeitReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CounterfeitReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CounterfeitReports.
     */
    skip?: number
    distinct?: CounterfeitReportScalarFieldEnum | CounterfeitReportScalarFieldEnum[]
  }

  /**
   * CounterfeitReport create
   */
  export type CounterfeitReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterfeitReport
     */
    select?: CounterfeitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CounterfeitReport
     */
    omit?: CounterfeitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterfeitReportInclude<ExtArgs> | null
    /**
     * The data needed to create a CounterfeitReport.
     */
    data: XOR<CounterfeitReportCreateInput, CounterfeitReportUncheckedCreateInput>
  }

  /**
   * CounterfeitReport createMany
   */
  export type CounterfeitReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CounterfeitReports.
     */
    data: CounterfeitReportCreateManyInput | CounterfeitReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CounterfeitReport createManyAndReturn
   */
  export type CounterfeitReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterfeitReport
     */
    select?: CounterfeitReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CounterfeitReport
     */
    omit?: CounterfeitReportOmit<ExtArgs> | null
    /**
     * The data used to create many CounterfeitReports.
     */
    data: CounterfeitReportCreateManyInput | CounterfeitReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterfeitReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CounterfeitReport update
   */
  export type CounterfeitReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterfeitReport
     */
    select?: CounterfeitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CounterfeitReport
     */
    omit?: CounterfeitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterfeitReportInclude<ExtArgs> | null
    /**
     * The data needed to update a CounterfeitReport.
     */
    data: XOR<CounterfeitReportUpdateInput, CounterfeitReportUncheckedUpdateInput>
    /**
     * Choose, which CounterfeitReport to update.
     */
    where: CounterfeitReportWhereUniqueInput
  }

  /**
   * CounterfeitReport updateMany
   */
  export type CounterfeitReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CounterfeitReports.
     */
    data: XOR<CounterfeitReportUpdateManyMutationInput, CounterfeitReportUncheckedUpdateManyInput>
    /**
     * Filter which CounterfeitReports to update
     */
    where?: CounterfeitReportWhereInput
    /**
     * Limit how many CounterfeitReports to update.
     */
    limit?: number
  }

  /**
   * CounterfeitReport updateManyAndReturn
   */
  export type CounterfeitReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterfeitReport
     */
    select?: CounterfeitReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CounterfeitReport
     */
    omit?: CounterfeitReportOmit<ExtArgs> | null
    /**
     * The data used to update CounterfeitReports.
     */
    data: XOR<CounterfeitReportUpdateManyMutationInput, CounterfeitReportUncheckedUpdateManyInput>
    /**
     * Filter which CounterfeitReports to update
     */
    where?: CounterfeitReportWhereInput
    /**
     * Limit how many CounterfeitReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterfeitReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CounterfeitReport upsert
   */
  export type CounterfeitReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterfeitReport
     */
    select?: CounterfeitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CounterfeitReport
     */
    omit?: CounterfeitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterfeitReportInclude<ExtArgs> | null
    /**
     * The filter to search for the CounterfeitReport to update in case it exists.
     */
    where: CounterfeitReportWhereUniqueInput
    /**
     * In case the CounterfeitReport found by the `where` argument doesn't exist, create a new CounterfeitReport with this data.
     */
    create: XOR<CounterfeitReportCreateInput, CounterfeitReportUncheckedCreateInput>
    /**
     * In case the CounterfeitReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CounterfeitReportUpdateInput, CounterfeitReportUncheckedUpdateInput>
  }

  /**
   * CounterfeitReport delete
   */
  export type CounterfeitReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterfeitReport
     */
    select?: CounterfeitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CounterfeitReport
     */
    omit?: CounterfeitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterfeitReportInclude<ExtArgs> | null
    /**
     * Filter which CounterfeitReport to delete.
     */
    where: CounterfeitReportWhereUniqueInput
  }

  /**
   * CounterfeitReport deleteMany
   */
  export type CounterfeitReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CounterfeitReports to delete
     */
    where?: CounterfeitReportWhereInput
    /**
     * Limit how many CounterfeitReports to delete.
     */
    limit?: number
  }

  /**
   * CounterfeitReport without action
   */
  export type CounterfeitReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterfeitReport
     */
    select?: CounterfeitReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CounterfeitReport
     */
    omit?: CounterfeitReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterfeitReportInclude<ExtArgs> | null
  }


  /**
   * Model SellerApplication
   */

  export type AggregateSellerApplication = {
    _count: SellerApplicationCountAggregateOutputType | null
    _min: SellerApplicationMinAggregateOutputType | null
    _max: SellerApplicationMaxAggregateOutputType | null
  }

  export type SellerApplicationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    businessName: string | null
    phone: string | null
    country: string | null
    city: string | null
    storefrontDesc: string | null
    bankName: string | null
    accountNumber: string | null
    accountName: string | null
    bankCode: string | null
    status: $Enums.ApplicationStatus | null
    adminNote: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellerApplicationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    businessName: string | null
    phone: string | null
    country: string | null
    city: string | null
    storefrontDesc: string | null
    bankName: string | null
    accountNumber: string | null
    accountName: string | null
    bankCode: string | null
    status: $Enums.ApplicationStatus | null
    adminNote: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellerApplicationCountAggregateOutputType = {
    id: number
    userId: number
    businessName: number
    phone: number
    country: number
    city: number
    storefrontDesc: number
    bankName: number
    accountNumber: number
    accountName: number
    bankCode: number
    status: number
    adminNote: number
    reviewedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SellerApplicationMinAggregateInputType = {
    id?: true
    userId?: true
    businessName?: true
    phone?: true
    country?: true
    city?: true
    storefrontDesc?: true
    bankName?: true
    accountNumber?: true
    accountName?: true
    bankCode?: true
    status?: true
    adminNote?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellerApplicationMaxAggregateInputType = {
    id?: true
    userId?: true
    businessName?: true
    phone?: true
    country?: true
    city?: true
    storefrontDesc?: true
    bankName?: true
    accountNumber?: true
    accountName?: true
    bankCode?: true
    status?: true
    adminNote?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellerApplicationCountAggregateInputType = {
    id?: true
    userId?: true
    businessName?: true
    phone?: true
    country?: true
    city?: true
    storefrontDesc?: true
    bankName?: true
    accountNumber?: true
    accountName?: true
    bankCode?: true
    status?: true
    adminNote?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SellerApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellerApplication to aggregate.
     */
    where?: SellerApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerApplications to fetch.
     */
    orderBy?: SellerApplicationOrderByWithRelationInput | SellerApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellerApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellerApplications
    **/
    _count?: true | SellerApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellerApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellerApplicationMaxAggregateInputType
  }

  export type GetSellerApplicationAggregateType<T extends SellerApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateSellerApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellerApplication[P]>
      : GetScalarType<T[P], AggregateSellerApplication[P]>
  }




  export type SellerApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellerApplicationWhereInput
    orderBy?: SellerApplicationOrderByWithAggregationInput | SellerApplicationOrderByWithAggregationInput[]
    by: SellerApplicationScalarFieldEnum[] | SellerApplicationScalarFieldEnum
    having?: SellerApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellerApplicationCountAggregateInputType | true
    _min?: SellerApplicationMinAggregateInputType
    _max?: SellerApplicationMaxAggregateInputType
  }

  export type SellerApplicationGroupByOutputType = {
    id: string
    userId: string
    businessName: string
    phone: string
    country: string
    city: string
    storefrontDesc: string
    bankName: string | null
    accountNumber: string | null
    accountName: string | null
    bankCode: string | null
    status: $Enums.ApplicationStatus
    adminNote: string | null
    reviewedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SellerApplicationCountAggregateOutputType | null
    _min: SellerApplicationMinAggregateOutputType | null
    _max: SellerApplicationMaxAggregateOutputType | null
  }

  type GetSellerApplicationGroupByPayload<T extends SellerApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellerApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellerApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellerApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], SellerApplicationGroupByOutputType[P]>
        }
      >
    >


  export type SellerApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessName?: boolean
    phone?: boolean
    country?: boolean
    city?: boolean
    storefrontDesc?: boolean
    bankName?: boolean
    accountNumber?: boolean
    accountName?: boolean
    bankCode?: boolean
    status?: boolean
    adminNote?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellerApplication"]>

  export type SellerApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessName?: boolean
    phone?: boolean
    country?: boolean
    city?: boolean
    storefrontDesc?: boolean
    bankName?: boolean
    accountNumber?: boolean
    accountName?: boolean
    bankCode?: boolean
    status?: boolean
    adminNote?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellerApplication"]>

  export type SellerApplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessName?: boolean
    phone?: boolean
    country?: boolean
    city?: boolean
    storefrontDesc?: boolean
    bankName?: boolean
    accountNumber?: boolean
    accountName?: boolean
    bankCode?: boolean
    status?: boolean
    adminNote?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellerApplication"]>

  export type SellerApplicationSelectScalar = {
    id?: boolean
    userId?: boolean
    businessName?: boolean
    phone?: boolean
    country?: boolean
    city?: boolean
    storefrontDesc?: boolean
    bankName?: boolean
    accountNumber?: boolean
    accountName?: boolean
    bankCode?: boolean
    status?: boolean
    adminNote?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SellerApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "businessName" | "phone" | "country" | "city" | "storefrontDesc" | "bankName" | "accountNumber" | "accountName" | "bankCode" | "status" | "adminNote" | "reviewedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["sellerApplication"]>
  export type SellerApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SellerApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SellerApplicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SellerApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellerApplication"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      businessName: string
      phone: string
      country: string
      city: string
      storefrontDesc: string
      bankName: string | null
      accountNumber: string | null
      accountName: string | null
      bankCode: string | null
      status: $Enums.ApplicationStatus
      adminNote: string | null
      reviewedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sellerApplication"]>
    composites: {}
  }

  type SellerApplicationGetPayload<S extends boolean | null | undefined | SellerApplicationDefaultArgs> = $Result.GetResult<Prisma.$SellerApplicationPayload, S>

  type SellerApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellerApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellerApplicationCountAggregateInputType | true
    }

  export interface SellerApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellerApplication'], meta: { name: 'SellerApplication' } }
    /**
     * Find zero or one SellerApplication that matches the filter.
     * @param {SellerApplicationFindUniqueArgs} args - Arguments to find a SellerApplication
     * @example
     * // Get one SellerApplication
     * const sellerApplication = await prisma.sellerApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellerApplicationFindUniqueArgs>(args: SelectSubset<T, SellerApplicationFindUniqueArgs<ExtArgs>>): Prisma__SellerApplicationClient<$Result.GetResult<Prisma.$SellerApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SellerApplication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellerApplicationFindUniqueOrThrowArgs} args - Arguments to find a SellerApplication
     * @example
     * // Get one SellerApplication
     * const sellerApplication = await prisma.sellerApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellerApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, SellerApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellerApplicationClient<$Result.GetResult<Prisma.$SellerApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellerApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerApplicationFindFirstArgs} args - Arguments to find a SellerApplication
     * @example
     * // Get one SellerApplication
     * const sellerApplication = await prisma.sellerApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellerApplicationFindFirstArgs>(args?: SelectSubset<T, SellerApplicationFindFirstArgs<ExtArgs>>): Prisma__SellerApplicationClient<$Result.GetResult<Prisma.$SellerApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellerApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerApplicationFindFirstOrThrowArgs} args - Arguments to find a SellerApplication
     * @example
     * // Get one SellerApplication
     * const sellerApplication = await prisma.sellerApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellerApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, SellerApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellerApplicationClient<$Result.GetResult<Prisma.$SellerApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellerApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellerApplications
     * const sellerApplications = await prisma.sellerApplication.findMany()
     * 
     * // Get first 10 SellerApplications
     * const sellerApplications = await prisma.sellerApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellerApplicationWithIdOnly = await prisma.sellerApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellerApplicationFindManyArgs>(args?: SelectSubset<T, SellerApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SellerApplication.
     * @param {SellerApplicationCreateArgs} args - Arguments to create a SellerApplication.
     * @example
     * // Create one SellerApplication
     * const SellerApplication = await prisma.sellerApplication.create({
     *   data: {
     *     // ... data to create a SellerApplication
     *   }
     * })
     * 
     */
    create<T extends SellerApplicationCreateArgs>(args: SelectSubset<T, SellerApplicationCreateArgs<ExtArgs>>): Prisma__SellerApplicationClient<$Result.GetResult<Prisma.$SellerApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SellerApplications.
     * @param {SellerApplicationCreateManyArgs} args - Arguments to create many SellerApplications.
     * @example
     * // Create many SellerApplications
     * const sellerApplication = await prisma.sellerApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellerApplicationCreateManyArgs>(args?: SelectSubset<T, SellerApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SellerApplications and returns the data saved in the database.
     * @param {SellerApplicationCreateManyAndReturnArgs} args - Arguments to create many SellerApplications.
     * @example
     * // Create many SellerApplications
     * const sellerApplication = await prisma.sellerApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SellerApplications and only return the `id`
     * const sellerApplicationWithIdOnly = await prisma.sellerApplication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SellerApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, SellerApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerApplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SellerApplication.
     * @param {SellerApplicationDeleteArgs} args - Arguments to delete one SellerApplication.
     * @example
     * // Delete one SellerApplication
     * const SellerApplication = await prisma.sellerApplication.delete({
     *   where: {
     *     // ... filter to delete one SellerApplication
     *   }
     * })
     * 
     */
    delete<T extends SellerApplicationDeleteArgs>(args: SelectSubset<T, SellerApplicationDeleteArgs<ExtArgs>>): Prisma__SellerApplicationClient<$Result.GetResult<Prisma.$SellerApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SellerApplication.
     * @param {SellerApplicationUpdateArgs} args - Arguments to update one SellerApplication.
     * @example
     * // Update one SellerApplication
     * const sellerApplication = await prisma.sellerApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellerApplicationUpdateArgs>(args: SelectSubset<T, SellerApplicationUpdateArgs<ExtArgs>>): Prisma__SellerApplicationClient<$Result.GetResult<Prisma.$SellerApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SellerApplications.
     * @param {SellerApplicationDeleteManyArgs} args - Arguments to filter SellerApplications to delete.
     * @example
     * // Delete a few SellerApplications
     * const { count } = await prisma.sellerApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellerApplicationDeleteManyArgs>(args?: SelectSubset<T, SellerApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellerApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellerApplications
     * const sellerApplication = await prisma.sellerApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellerApplicationUpdateManyArgs>(args: SelectSubset<T, SellerApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellerApplications and returns the data updated in the database.
     * @param {SellerApplicationUpdateManyAndReturnArgs} args - Arguments to update many SellerApplications.
     * @example
     * // Update many SellerApplications
     * const sellerApplication = await prisma.sellerApplication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SellerApplications and only return the `id`
     * const sellerApplicationWithIdOnly = await prisma.sellerApplication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SellerApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, SellerApplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerApplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SellerApplication.
     * @param {SellerApplicationUpsertArgs} args - Arguments to update or create a SellerApplication.
     * @example
     * // Update or create a SellerApplication
     * const sellerApplication = await prisma.sellerApplication.upsert({
     *   create: {
     *     // ... data to create a SellerApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellerApplication we want to update
     *   }
     * })
     */
    upsert<T extends SellerApplicationUpsertArgs>(args: SelectSubset<T, SellerApplicationUpsertArgs<ExtArgs>>): Prisma__SellerApplicationClient<$Result.GetResult<Prisma.$SellerApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SellerApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerApplicationCountArgs} args - Arguments to filter SellerApplications to count.
     * @example
     * // Count the number of SellerApplications
     * const count = await prisma.sellerApplication.count({
     *   where: {
     *     // ... the filter for the SellerApplications we want to count
     *   }
     * })
    **/
    count<T extends SellerApplicationCountArgs>(
      args?: Subset<T, SellerApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellerApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellerApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellerApplicationAggregateArgs>(args: Subset<T, SellerApplicationAggregateArgs>): Prisma.PrismaPromise<GetSellerApplicationAggregateType<T>>

    /**
     * Group by SellerApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellerApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellerApplicationGroupByArgs['orderBy'] }
        : { orderBy?: SellerApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellerApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellerApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellerApplication model
   */
  readonly fields: SellerApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellerApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellerApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellerApplication model
   */
  interface SellerApplicationFieldRefs {
    readonly id: FieldRef<"SellerApplication", 'String'>
    readonly userId: FieldRef<"SellerApplication", 'String'>
    readonly businessName: FieldRef<"SellerApplication", 'String'>
    readonly phone: FieldRef<"SellerApplication", 'String'>
    readonly country: FieldRef<"SellerApplication", 'String'>
    readonly city: FieldRef<"SellerApplication", 'String'>
    readonly storefrontDesc: FieldRef<"SellerApplication", 'String'>
    readonly bankName: FieldRef<"SellerApplication", 'String'>
    readonly accountNumber: FieldRef<"SellerApplication", 'String'>
    readonly accountName: FieldRef<"SellerApplication", 'String'>
    readonly bankCode: FieldRef<"SellerApplication", 'String'>
    readonly status: FieldRef<"SellerApplication", 'ApplicationStatus'>
    readonly adminNote: FieldRef<"SellerApplication", 'String'>
    readonly reviewedAt: FieldRef<"SellerApplication", 'DateTime'>
    readonly createdAt: FieldRef<"SellerApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"SellerApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SellerApplication findUnique
   */
  export type SellerApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerApplication
     */
    select?: SellerApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerApplication
     */
    omit?: SellerApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerApplicationInclude<ExtArgs> | null
    /**
     * Filter, which SellerApplication to fetch.
     */
    where: SellerApplicationWhereUniqueInput
  }

  /**
   * SellerApplication findUniqueOrThrow
   */
  export type SellerApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerApplication
     */
    select?: SellerApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerApplication
     */
    omit?: SellerApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerApplicationInclude<ExtArgs> | null
    /**
     * Filter, which SellerApplication to fetch.
     */
    where: SellerApplicationWhereUniqueInput
  }

  /**
   * SellerApplication findFirst
   */
  export type SellerApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerApplication
     */
    select?: SellerApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerApplication
     */
    omit?: SellerApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerApplicationInclude<ExtArgs> | null
    /**
     * Filter, which SellerApplication to fetch.
     */
    where?: SellerApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerApplications to fetch.
     */
    orderBy?: SellerApplicationOrderByWithRelationInput | SellerApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellerApplications.
     */
    cursor?: SellerApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellerApplications.
     */
    distinct?: SellerApplicationScalarFieldEnum | SellerApplicationScalarFieldEnum[]
  }

  /**
   * SellerApplication findFirstOrThrow
   */
  export type SellerApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerApplication
     */
    select?: SellerApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerApplication
     */
    omit?: SellerApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerApplicationInclude<ExtArgs> | null
    /**
     * Filter, which SellerApplication to fetch.
     */
    where?: SellerApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerApplications to fetch.
     */
    orderBy?: SellerApplicationOrderByWithRelationInput | SellerApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellerApplications.
     */
    cursor?: SellerApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellerApplications.
     */
    distinct?: SellerApplicationScalarFieldEnum | SellerApplicationScalarFieldEnum[]
  }

  /**
   * SellerApplication findMany
   */
  export type SellerApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerApplication
     */
    select?: SellerApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerApplication
     */
    omit?: SellerApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerApplicationInclude<ExtArgs> | null
    /**
     * Filter, which SellerApplications to fetch.
     */
    where?: SellerApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerApplications to fetch.
     */
    orderBy?: SellerApplicationOrderByWithRelationInput | SellerApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellerApplications.
     */
    cursor?: SellerApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerApplications.
     */
    skip?: number
    distinct?: SellerApplicationScalarFieldEnum | SellerApplicationScalarFieldEnum[]
  }

  /**
   * SellerApplication create
   */
  export type SellerApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerApplication
     */
    select?: SellerApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerApplication
     */
    omit?: SellerApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a SellerApplication.
     */
    data: XOR<SellerApplicationCreateInput, SellerApplicationUncheckedCreateInput>
  }

  /**
   * SellerApplication createMany
   */
  export type SellerApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellerApplications.
     */
    data: SellerApplicationCreateManyInput | SellerApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellerApplication createManyAndReturn
   */
  export type SellerApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerApplication
     */
    select?: SellerApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SellerApplication
     */
    omit?: SellerApplicationOmit<ExtArgs> | null
    /**
     * The data used to create many SellerApplications.
     */
    data: SellerApplicationCreateManyInput | SellerApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SellerApplication update
   */
  export type SellerApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerApplication
     */
    select?: SellerApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerApplication
     */
    omit?: SellerApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a SellerApplication.
     */
    data: XOR<SellerApplicationUpdateInput, SellerApplicationUncheckedUpdateInput>
    /**
     * Choose, which SellerApplication to update.
     */
    where: SellerApplicationWhereUniqueInput
  }

  /**
   * SellerApplication updateMany
   */
  export type SellerApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellerApplications.
     */
    data: XOR<SellerApplicationUpdateManyMutationInput, SellerApplicationUncheckedUpdateManyInput>
    /**
     * Filter which SellerApplications to update
     */
    where?: SellerApplicationWhereInput
    /**
     * Limit how many SellerApplications to update.
     */
    limit?: number
  }

  /**
   * SellerApplication updateManyAndReturn
   */
  export type SellerApplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerApplication
     */
    select?: SellerApplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SellerApplication
     */
    omit?: SellerApplicationOmit<ExtArgs> | null
    /**
     * The data used to update SellerApplications.
     */
    data: XOR<SellerApplicationUpdateManyMutationInput, SellerApplicationUncheckedUpdateManyInput>
    /**
     * Filter which SellerApplications to update
     */
    where?: SellerApplicationWhereInput
    /**
     * Limit how many SellerApplications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerApplicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SellerApplication upsert
   */
  export type SellerApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerApplication
     */
    select?: SellerApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerApplication
     */
    omit?: SellerApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the SellerApplication to update in case it exists.
     */
    where: SellerApplicationWhereUniqueInput
    /**
     * In case the SellerApplication found by the `where` argument doesn't exist, create a new SellerApplication with this data.
     */
    create: XOR<SellerApplicationCreateInput, SellerApplicationUncheckedCreateInput>
    /**
     * In case the SellerApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellerApplicationUpdateInput, SellerApplicationUncheckedUpdateInput>
  }

  /**
   * SellerApplication delete
   */
  export type SellerApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerApplication
     */
    select?: SellerApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerApplication
     */
    omit?: SellerApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerApplicationInclude<ExtArgs> | null
    /**
     * Filter which SellerApplication to delete.
     */
    where: SellerApplicationWhereUniqueInput
  }

  /**
   * SellerApplication deleteMany
   */
  export type SellerApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellerApplications to delete
     */
    where?: SellerApplicationWhereInput
    /**
     * Limit how many SellerApplications to delete.
     */
    limit?: number
  }

  /**
   * SellerApplication without action
   */
  export type SellerApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerApplication
     */
    select?: SellerApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerApplication
     */
    omit?: SellerApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerApplicationInclude<ExtArgs> | null
  }


  /**
   * Model Dispute
   */

  export type AggregateDispute = {
    _count: DisputeCountAggregateOutputType | null
    _min: DisputeMinAggregateOutputType | null
    _max: DisputeMaxAggregateOutputType | null
  }

  export type DisputeMinAggregateOutputType = {
    id: string | null
    orderItemId: string | null
    buyerId: string | null
    reasonCode: $Enums.DisputeReason | null
    description: string | null
    photoProofUrl: string | null
    status: $Enums.DisputeStatus | null
    resolutionNote: string | null
    resolvedById: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DisputeMaxAggregateOutputType = {
    id: string | null
    orderItemId: string | null
    buyerId: string | null
    reasonCode: $Enums.DisputeReason | null
    description: string | null
    photoProofUrl: string | null
    status: $Enums.DisputeStatus | null
    resolutionNote: string | null
    resolvedById: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DisputeCountAggregateOutputType = {
    id: number
    orderItemId: number
    buyerId: number
    reasonCode: number
    description: number
    photoProofUrl: number
    status: number
    resolutionNote: number
    resolvedById: number
    resolvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DisputeMinAggregateInputType = {
    id?: true
    orderItemId?: true
    buyerId?: true
    reasonCode?: true
    description?: true
    photoProofUrl?: true
    status?: true
    resolutionNote?: true
    resolvedById?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DisputeMaxAggregateInputType = {
    id?: true
    orderItemId?: true
    buyerId?: true
    reasonCode?: true
    description?: true
    photoProofUrl?: true
    status?: true
    resolutionNote?: true
    resolvedById?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DisputeCountAggregateInputType = {
    id?: true
    orderItemId?: true
    buyerId?: true
    reasonCode?: true
    description?: true
    photoProofUrl?: true
    status?: true
    resolutionNote?: true
    resolvedById?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DisputeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dispute to aggregate.
     */
    where?: DisputeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disputes to fetch.
     */
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisputeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disputes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Disputes
    **/
    _count?: true | DisputeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisputeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisputeMaxAggregateInputType
  }

  export type GetDisputeAggregateType<T extends DisputeAggregateArgs> = {
        [P in keyof T & keyof AggregateDispute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDispute[P]>
      : GetScalarType<T[P], AggregateDispute[P]>
  }




  export type DisputeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisputeWhereInput
    orderBy?: DisputeOrderByWithAggregationInput | DisputeOrderByWithAggregationInput[]
    by: DisputeScalarFieldEnum[] | DisputeScalarFieldEnum
    having?: DisputeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisputeCountAggregateInputType | true
    _min?: DisputeMinAggregateInputType
    _max?: DisputeMaxAggregateInputType
  }

  export type DisputeGroupByOutputType = {
    id: string
    orderItemId: string
    buyerId: string
    reasonCode: $Enums.DisputeReason
    description: string
    photoProofUrl: string | null
    status: $Enums.DisputeStatus
    resolutionNote: string | null
    resolvedById: string | null
    resolvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DisputeCountAggregateOutputType | null
    _min: DisputeMinAggregateOutputType | null
    _max: DisputeMaxAggregateOutputType | null
  }

  type GetDisputeGroupByPayload<T extends DisputeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisputeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisputeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisputeGroupByOutputType[P]>
            : GetScalarType<T[P], DisputeGroupByOutputType[P]>
        }
      >
    >


  export type DisputeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    buyerId?: boolean
    reasonCode?: boolean
    description?: boolean
    photoProofUrl?: boolean
    status?: boolean
    resolutionNote?: boolean
    resolvedById?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispute"]>

  export type DisputeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    buyerId?: boolean
    reasonCode?: boolean
    description?: boolean
    photoProofUrl?: boolean
    status?: boolean
    resolutionNote?: boolean
    resolvedById?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispute"]>

  export type DisputeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    buyerId?: boolean
    reasonCode?: boolean
    description?: boolean
    photoProofUrl?: boolean
    status?: boolean
    resolutionNote?: boolean
    resolvedById?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispute"]>

  export type DisputeSelectScalar = {
    id?: boolean
    orderItemId?: boolean
    buyerId?: boolean
    reasonCode?: boolean
    description?: boolean
    photoProofUrl?: boolean
    status?: boolean
    resolutionNote?: boolean
    resolvedById?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DisputeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderItemId" | "buyerId" | "reasonCode" | "description" | "photoProofUrl" | "status" | "resolutionNote" | "resolvedById" | "resolvedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["dispute"]>
  export type DisputeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DisputeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DisputeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DisputePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dispute"
    objects: {
      orderItem: Prisma.$OrderItemPayload<ExtArgs>
      buyer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderItemId: string
      buyerId: string
      reasonCode: $Enums.DisputeReason
      description: string
      photoProofUrl: string | null
      status: $Enums.DisputeStatus
      resolutionNote: string | null
      resolvedById: string | null
      resolvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dispute"]>
    composites: {}
  }

  type DisputeGetPayload<S extends boolean | null | undefined | DisputeDefaultArgs> = $Result.GetResult<Prisma.$DisputePayload, S>

  type DisputeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DisputeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisputeCountAggregateInputType | true
    }

  export interface DisputeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dispute'], meta: { name: 'Dispute' } }
    /**
     * Find zero or one Dispute that matches the filter.
     * @param {DisputeFindUniqueArgs} args - Arguments to find a Dispute
     * @example
     * // Get one Dispute
     * const dispute = await prisma.dispute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisputeFindUniqueArgs>(args: SelectSubset<T, DisputeFindUniqueArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dispute that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DisputeFindUniqueOrThrowArgs} args - Arguments to find a Dispute
     * @example
     * // Get one Dispute
     * const dispute = await prisma.dispute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisputeFindUniqueOrThrowArgs>(args: SelectSubset<T, DisputeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dispute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeFindFirstArgs} args - Arguments to find a Dispute
     * @example
     * // Get one Dispute
     * const dispute = await prisma.dispute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisputeFindFirstArgs>(args?: SelectSubset<T, DisputeFindFirstArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dispute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeFindFirstOrThrowArgs} args - Arguments to find a Dispute
     * @example
     * // Get one Dispute
     * const dispute = await prisma.dispute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisputeFindFirstOrThrowArgs>(args?: SelectSubset<T, DisputeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Disputes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Disputes
     * const disputes = await prisma.dispute.findMany()
     * 
     * // Get first 10 Disputes
     * const disputes = await prisma.dispute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disputeWithIdOnly = await prisma.dispute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisputeFindManyArgs>(args?: SelectSubset<T, DisputeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dispute.
     * @param {DisputeCreateArgs} args - Arguments to create a Dispute.
     * @example
     * // Create one Dispute
     * const Dispute = await prisma.dispute.create({
     *   data: {
     *     // ... data to create a Dispute
     *   }
     * })
     * 
     */
    create<T extends DisputeCreateArgs>(args: SelectSubset<T, DisputeCreateArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Disputes.
     * @param {DisputeCreateManyArgs} args - Arguments to create many Disputes.
     * @example
     * // Create many Disputes
     * const dispute = await prisma.dispute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisputeCreateManyArgs>(args?: SelectSubset<T, DisputeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Disputes and returns the data saved in the database.
     * @param {DisputeCreateManyAndReturnArgs} args - Arguments to create many Disputes.
     * @example
     * // Create many Disputes
     * const dispute = await prisma.dispute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Disputes and only return the `id`
     * const disputeWithIdOnly = await prisma.dispute.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisputeCreateManyAndReturnArgs>(args?: SelectSubset<T, DisputeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dispute.
     * @param {DisputeDeleteArgs} args - Arguments to delete one Dispute.
     * @example
     * // Delete one Dispute
     * const Dispute = await prisma.dispute.delete({
     *   where: {
     *     // ... filter to delete one Dispute
     *   }
     * })
     * 
     */
    delete<T extends DisputeDeleteArgs>(args: SelectSubset<T, DisputeDeleteArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dispute.
     * @param {DisputeUpdateArgs} args - Arguments to update one Dispute.
     * @example
     * // Update one Dispute
     * const dispute = await prisma.dispute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisputeUpdateArgs>(args: SelectSubset<T, DisputeUpdateArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Disputes.
     * @param {DisputeDeleteManyArgs} args - Arguments to filter Disputes to delete.
     * @example
     * // Delete a few Disputes
     * const { count } = await prisma.dispute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisputeDeleteManyArgs>(args?: SelectSubset<T, DisputeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Disputes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Disputes
     * const dispute = await prisma.dispute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisputeUpdateManyArgs>(args: SelectSubset<T, DisputeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Disputes and returns the data updated in the database.
     * @param {DisputeUpdateManyAndReturnArgs} args - Arguments to update many Disputes.
     * @example
     * // Update many Disputes
     * const dispute = await prisma.dispute.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Disputes and only return the `id`
     * const disputeWithIdOnly = await prisma.dispute.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DisputeUpdateManyAndReturnArgs>(args: SelectSubset<T, DisputeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dispute.
     * @param {DisputeUpsertArgs} args - Arguments to update or create a Dispute.
     * @example
     * // Update or create a Dispute
     * const dispute = await prisma.dispute.upsert({
     *   create: {
     *     // ... data to create a Dispute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dispute we want to update
     *   }
     * })
     */
    upsert<T extends DisputeUpsertArgs>(args: SelectSubset<T, DisputeUpsertArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Disputes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeCountArgs} args - Arguments to filter Disputes to count.
     * @example
     * // Count the number of Disputes
     * const count = await prisma.dispute.count({
     *   where: {
     *     // ... the filter for the Disputes we want to count
     *   }
     * })
    **/
    count<T extends DisputeCountArgs>(
      args?: Subset<T, DisputeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisputeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dispute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisputeAggregateArgs>(args: Subset<T, DisputeAggregateArgs>): Prisma.PrismaPromise<GetDisputeAggregateType<T>>

    /**
     * Group by Dispute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisputeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisputeGroupByArgs['orderBy'] }
        : { orderBy?: DisputeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisputeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisputeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dispute model
   */
  readonly fields: DisputeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dispute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisputeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItem<T extends OrderItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderItemDefaultArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    buyer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dispute model
   */
  interface DisputeFieldRefs {
    readonly id: FieldRef<"Dispute", 'String'>
    readonly orderItemId: FieldRef<"Dispute", 'String'>
    readonly buyerId: FieldRef<"Dispute", 'String'>
    readonly reasonCode: FieldRef<"Dispute", 'DisputeReason'>
    readonly description: FieldRef<"Dispute", 'String'>
    readonly photoProofUrl: FieldRef<"Dispute", 'String'>
    readonly status: FieldRef<"Dispute", 'DisputeStatus'>
    readonly resolutionNote: FieldRef<"Dispute", 'String'>
    readonly resolvedById: FieldRef<"Dispute", 'String'>
    readonly resolvedAt: FieldRef<"Dispute", 'DateTime'>
    readonly createdAt: FieldRef<"Dispute", 'DateTime'>
    readonly updatedAt: FieldRef<"Dispute", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dispute findUnique
   */
  export type DisputeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Dispute to fetch.
     */
    where: DisputeWhereUniqueInput
  }

  /**
   * Dispute findUniqueOrThrow
   */
  export type DisputeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Dispute to fetch.
     */
    where: DisputeWhereUniqueInput
  }

  /**
   * Dispute findFirst
   */
  export type DisputeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Dispute to fetch.
     */
    where?: DisputeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disputes to fetch.
     */
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Disputes.
     */
    cursor?: DisputeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disputes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Disputes.
     */
    distinct?: DisputeScalarFieldEnum | DisputeScalarFieldEnum[]
  }

  /**
   * Dispute findFirstOrThrow
   */
  export type DisputeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Dispute to fetch.
     */
    where?: DisputeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disputes to fetch.
     */
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Disputes.
     */
    cursor?: DisputeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disputes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Disputes.
     */
    distinct?: DisputeScalarFieldEnum | DisputeScalarFieldEnum[]
  }

  /**
   * Dispute findMany
   */
  export type DisputeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Disputes to fetch.
     */
    where?: DisputeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disputes to fetch.
     */
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Disputes.
     */
    cursor?: DisputeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disputes.
     */
    skip?: number
    distinct?: DisputeScalarFieldEnum | DisputeScalarFieldEnum[]
  }

  /**
   * Dispute create
   */
  export type DisputeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * The data needed to create a Dispute.
     */
    data: XOR<DisputeCreateInput, DisputeUncheckedCreateInput>
  }

  /**
   * Dispute createMany
   */
  export type DisputeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Disputes.
     */
    data: DisputeCreateManyInput | DisputeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dispute createManyAndReturn
   */
  export type DisputeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * The data used to create many Disputes.
     */
    data: DisputeCreateManyInput | DisputeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dispute update
   */
  export type DisputeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * The data needed to update a Dispute.
     */
    data: XOR<DisputeUpdateInput, DisputeUncheckedUpdateInput>
    /**
     * Choose, which Dispute to update.
     */
    where: DisputeWhereUniqueInput
  }

  /**
   * Dispute updateMany
   */
  export type DisputeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Disputes.
     */
    data: XOR<DisputeUpdateManyMutationInput, DisputeUncheckedUpdateManyInput>
    /**
     * Filter which Disputes to update
     */
    where?: DisputeWhereInput
    /**
     * Limit how many Disputes to update.
     */
    limit?: number
  }

  /**
   * Dispute updateManyAndReturn
   */
  export type DisputeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * The data used to update Disputes.
     */
    data: XOR<DisputeUpdateManyMutationInput, DisputeUncheckedUpdateManyInput>
    /**
     * Filter which Disputes to update
     */
    where?: DisputeWhereInput
    /**
     * Limit how many Disputes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dispute upsert
   */
  export type DisputeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * The filter to search for the Dispute to update in case it exists.
     */
    where: DisputeWhereUniqueInput
    /**
     * In case the Dispute found by the `where` argument doesn't exist, create a new Dispute with this data.
     */
    create: XOR<DisputeCreateInput, DisputeUncheckedCreateInput>
    /**
     * In case the Dispute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisputeUpdateInput, DisputeUncheckedUpdateInput>
  }

  /**
   * Dispute delete
   */
  export type DisputeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter which Dispute to delete.
     */
    where: DisputeWhereUniqueInput
  }

  /**
   * Dispute deleteMany
   */
  export type DisputeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Disputes to delete
     */
    where?: DisputeWhereInput
    /**
     * Limit how many Disputes to delete.
     */
    limit?: number
  }

  /**
   * Dispute without action
   */
  export type DisputeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    orderItemId: string | null
    sellerId: string | null
    buyerId: string | null
    productId: string | null
    rating: number | null
    comment: string | null
    isVisible: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    orderItemId: string | null
    sellerId: string | null
    buyerId: string | null
    productId: string | null
    rating: number | null
    comment: string | null
    isVisible: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    orderItemId: number
    sellerId: number
    buyerId: number
    productId: number
    rating: number
    comment: number
    isVisible: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    orderItemId?: true
    sellerId?: true
    buyerId?: true
    productId?: true
    rating?: true
    comment?: true
    isVisible?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    orderItemId?: true
    sellerId?: true
    buyerId?: true
    productId?: true
    rating?: true
    comment?: true
    isVisible?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    orderItemId?: true
    sellerId?: true
    buyerId?: true
    productId?: true
    rating?: true
    comment?: true
    isVisible?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    orderItemId: string
    sellerId: string
    buyerId: string
    productId: string
    rating: number
    comment: string
    isVisible: boolean
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    sellerId?: boolean
    buyerId?: boolean
    productId?: boolean
    rating?: boolean
    comment?: boolean
    isVisible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    sellerId?: boolean
    buyerId?: boolean
    productId?: boolean
    rating?: boolean
    comment?: boolean
    isVisible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    sellerId?: boolean
    buyerId?: boolean
    productId?: boolean
    rating?: boolean
    comment?: boolean
    isVisible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    orderItemId?: boolean
    sellerId?: boolean
    buyerId?: boolean
    productId?: boolean
    rating?: boolean
    comment?: boolean
    isVisible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderItemId" | "sellerId" | "buyerId" | "productId" | "rating" | "comment" | "isVisible" | "createdAt" | "updatedAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      orderItem: Prisma.$OrderItemPayload<ExtArgs>
      seller: Prisma.$UserPayload<ExtArgs>
      buyer: Prisma.$UserPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderItemId: string
      sellerId: string
      buyerId: string
      productId: string
      rating: number
      comment: string
      isVisible: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItem<T extends OrderItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderItemDefaultArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    buyer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly orderItemId: FieldRef<"Review", 'String'>
    readonly sellerId: FieldRef<"Review", 'String'>
    readonly buyerId: FieldRef<"Review", 'String'>
    readonly productId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly isVisible: FieldRef<"Review", 'Boolean'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    body: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    body: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    body: number
    message: number
    type: number
    isRead: number
    readAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    body?: true
    message?: true
    type?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    body?: true
    message?: true
    type?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    body?: true
    message?: true
    type?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    body: string
    message: string
    type: string
    isRead: boolean
    readAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "body" | "message" | "type" | "isRead" | "readAt" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      body: string
      message: string
      type: string
      isRead: boolean
      readAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model CommunityStory
   */

  export type AggregateCommunityStory = {
    _count: CommunityStoryCountAggregateOutputType | null
    _min: CommunityStoryMinAggregateOutputType | null
    _max: CommunityStoryMaxAggregateOutputType | null
  }

  export type CommunityStoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    content: string | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type CommunityStoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    content: string | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type CommunityStoryCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    content: number
    imageUrl: number
    createdAt: number
    _all: number
  }


  export type CommunityStoryMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    content?: true
    imageUrl?: true
    createdAt?: true
  }

  export type CommunityStoryMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    content?: true
    imageUrl?: true
    createdAt?: true
  }

  export type CommunityStoryCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    content?: true
    imageUrl?: true
    createdAt?: true
    _all?: true
  }

  export type CommunityStoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityStory to aggregate.
     */
    where?: CommunityStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityStories to fetch.
     */
    orderBy?: CommunityStoryOrderByWithRelationInput | CommunityStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityStories
    **/
    _count?: true | CommunityStoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityStoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityStoryMaxAggregateInputType
  }

  export type GetCommunityStoryAggregateType<T extends CommunityStoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityStory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityStory[P]>
      : GetScalarType<T[P], AggregateCommunityStory[P]>
  }




  export type CommunityStoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityStoryWhereInput
    orderBy?: CommunityStoryOrderByWithAggregationInput | CommunityStoryOrderByWithAggregationInput[]
    by: CommunityStoryScalarFieldEnum[] | CommunityStoryScalarFieldEnum
    having?: CommunityStoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityStoryCountAggregateInputType | true
    _min?: CommunityStoryMinAggregateInputType
    _max?: CommunityStoryMaxAggregateInputType
  }

  export type CommunityStoryGroupByOutputType = {
    id: string
    userId: string
    productId: string
    content: string
    imageUrl: string | null
    createdAt: Date
    _count: CommunityStoryCountAggregateOutputType | null
    _min: CommunityStoryMinAggregateOutputType | null
    _max: CommunityStoryMaxAggregateOutputType | null
  }

  type GetCommunityStoryGroupByPayload<T extends CommunityStoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityStoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityStoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityStoryGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityStoryGroupByOutputType[P]>
        }
      >
    >


  export type CommunityStorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    content?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityStory"]>

  export type CommunityStorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    content?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityStory"]>

  export type CommunityStorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    content?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityStory"]>

  export type CommunityStorySelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    content?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }

  export type CommunityStoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "productId" | "content" | "imageUrl" | "createdAt", ExtArgs["result"]["communityStory"]>
  export type CommunityStoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CommunityStoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CommunityStoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $CommunityStoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityStory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      productId: string
      content: string
      imageUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["communityStory"]>
    composites: {}
  }

  type CommunityStoryGetPayload<S extends boolean | null | undefined | CommunityStoryDefaultArgs> = $Result.GetResult<Prisma.$CommunityStoryPayload, S>

  type CommunityStoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunityStoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunityStoryCountAggregateInputType | true
    }

  export interface CommunityStoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityStory'], meta: { name: 'CommunityStory' } }
    /**
     * Find zero or one CommunityStory that matches the filter.
     * @param {CommunityStoryFindUniqueArgs} args - Arguments to find a CommunityStory
     * @example
     * // Get one CommunityStory
     * const communityStory = await prisma.communityStory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityStoryFindUniqueArgs>(args: SelectSubset<T, CommunityStoryFindUniqueArgs<ExtArgs>>): Prisma__CommunityStoryClient<$Result.GetResult<Prisma.$CommunityStoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommunityStory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunityStoryFindUniqueOrThrowArgs} args - Arguments to find a CommunityStory
     * @example
     * // Get one CommunityStory
     * const communityStory = await prisma.communityStory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityStoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityStoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityStoryClient<$Result.GetResult<Prisma.$CommunityStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityStory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityStoryFindFirstArgs} args - Arguments to find a CommunityStory
     * @example
     * // Get one CommunityStory
     * const communityStory = await prisma.communityStory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityStoryFindFirstArgs>(args?: SelectSubset<T, CommunityStoryFindFirstArgs<ExtArgs>>): Prisma__CommunityStoryClient<$Result.GetResult<Prisma.$CommunityStoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityStory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityStoryFindFirstOrThrowArgs} args - Arguments to find a CommunityStory
     * @example
     * // Get one CommunityStory
     * const communityStory = await prisma.communityStory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityStoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityStoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityStoryClient<$Result.GetResult<Prisma.$CommunityStoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommunityStories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityStoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityStories
     * const communityStories = await prisma.communityStory.findMany()
     * 
     * // Get first 10 CommunityStories
     * const communityStories = await prisma.communityStory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityStoryWithIdOnly = await prisma.communityStory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityStoryFindManyArgs>(args?: SelectSubset<T, CommunityStoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommunityStory.
     * @param {CommunityStoryCreateArgs} args - Arguments to create a CommunityStory.
     * @example
     * // Create one CommunityStory
     * const CommunityStory = await prisma.communityStory.create({
     *   data: {
     *     // ... data to create a CommunityStory
     *   }
     * })
     * 
     */
    create<T extends CommunityStoryCreateArgs>(args: SelectSubset<T, CommunityStoryCreateArgs<ExtArgs>>): Prisma__CommunityStoryClient<$Result.GetResult<Prisma.$CommunityStoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommunityStories.
     * @param {CommunityStoryCreateManyArgs} args - Arguments to create many CommunityStories.
     * @example
     * // Create many CommunityStories
     * const communityStory = await prisma.communityStory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityStoryCreateManyArgs>(args?: SelectSubset<T, CommunityStoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommunityStories and returns the data saved in the database.
     * @param {CommunityStoryCreateManyAndReturnArgs} args - Arguments to create many CommunityStories.
     * @example
     * // Create many CommunityStories
     * const communityStory = await prisma.communityStory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommunityStories and only return the `id`
     * const communityStoryWithIdOnly = await prisma.communityStory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunityStoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunityStoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityStoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommunityStory.
     * @param {CommunityStoryDeleteArgs} args - Arguments to delete one CommunityStory.
     * @example
     * // Delete one CommunityStory
     * const CommunityStory = await prisma.communityStory.delete({
     *   where: {
     *     // ... filter to delete one CommunityStory
     *   }
     * })
     * 
     */
    delete<T extends CommunityStoryDeleteArgs>(args: SelectSubset<T, CommunityStoryDeleteArgs<ExtArgs>>): Prisma__CommunityStoryClient<$Result.GetResult<Prisma.$CommunityStoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommunityStory.
     * @param {CommunityStoryUpdateArgs} args - Arguments to update one CommunityStory.
     * @example
     * // Update one CommunityStory
     * const communityStory = await prisma.communityStory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityStoryUpdateArgs>(args: SelectSubset<T, CommunityStoryUpdateArgs<ExtArgs>>): Prisma__CommunityStoryClient<$Result.GetResult<Prisma.$CommunityStoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommunityStories.
     * @param {CommunityStoryDeleteManyArgs} args - Arguments to filter CommunityStories to delete.
     * @example
     * // Delete a few CommunityStories
     * const { count } = await prisma.communityStory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityStoryDeleteManyArgs>(args?: SelectSubset<T, CommunityStoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityStoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityStories
     * const communityStory = await prisma.communityStory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityStoryUpdateManyArgs>(args: SelectSubset<T, CommunityStoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityStories and returns the data updated in the database.
     * @param {CommunityStoryUpdateManyAndReturnArgs} args - Arguments to update many CommunityStories.
     * @example
     * // Update many CommunityStories
     * const communityStory = await prisma.communityStory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommunityStories and only return the `id`
     * const communityStoryWithIdOnly = await prisma.communityStory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommunityStoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CommunityStoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityStoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommunityStory.
     * @param {CommunityStoryUpsertArgs} args - Arguments to update or create a CommunityStory.
     * @example
     * // Update or create a CommunityStory
     * const communityStory = await prisma.communityStory.upsert({
     *   create: {
     *     // ... data to create a CommunityStory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityStory we want to update
     *   }
     * })
     */
    upsert<T extends CommunityStoryUpsertArgs>(args: SelectSubset<T, CommunityStoryUpsertArgs<ExtArgs>>): Prisma__CommunityStoryClient<$Result.GetResult<Prisma.$CommunityStoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommunityStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityStoryCountArgs} args - Arguments to filter CommunityStories to count.
     * @example
     * // Count the number of CommunityStories
     * const count = await prisma.communityStory.count({
     *   where: {
     *     // ... the filter for the CommunityStories we want to count
     *   }
     * })
    **/
    count<T extends CommunityStoryCountArgs>(
      args?: Subset<T, CommunityStoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityStoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityStory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityStoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityStoryAggregateArgs>(args: Subset<T, CommunityStoryAggregateArgs>): Prisma.PrismaPromise<GetCommunityStoryAggregateType<T>>

    /**
     * Group by CommunityStory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityStoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityStoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityStoryGroupByArgs['orderBy'] }
        : { orderBy?: CommunityStoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityStoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityStoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityStory model
   */
  readonly fields: CommunityStoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityStory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityStoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunityStory model
   */
  interface CommunityStoryFieldRefs {
    readonly id: FieldRef<"CommunityStory", 'String'>
    readonly userId: FieldRef<"CommunityStory", 'String'>
    readonly productId: FieldRef<"CommunityStory", 'String'>
    readonly content: FieldRef<"CommunityStory", 'String'>
    readonly imageUrl: FieldRef<"CommunityStory", 'String'>
    readonly createdAt: FieldRef<"CommunityStory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommunityStory findUnique
   */
  export type CommunityStoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityStory
     */
    select?: CommunityStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityStory
     */
    omit?: CommunityStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityStoryInclude<ExtArgs> | null
    /**
     * Filter, which CommunityStory to fetch.
     */
    where: CommunityStoryWhereUniqueInput
  }

  /**
   * CommunityStory findUniqueOrThrow
   */
  export type CommunityStoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityStory
     */
    select?: CommunityStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityStory
     */
    omit?: CommunityStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityStoryInclude<ExtArgs> | null
    /**
     * Filter, which CommunityStory to fetch.
     */
    where: CommunityStoryWhereUniqueInput
  }

  /**
   * CommunityStory findFirst
   */
  export type CommunityStoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityStory
     */
    select?: CommunityStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityStory
     */
    omit?: CommunityStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityStoryInclude<ExtArgs> | null
    /**
     * Filter, which CommunityStory to fetch.
     */
    where?: CommunityStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityStories to fetch.
     */
    orderBy?: CommunityStoryOrderByWithRelationInput | CommunityStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityStories.
     */
    cursor?: CommunityStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityStories.
     */
    distinct?: CommunityStoryScalarFieldEnum | CommunityStoryScalarFieldEnum[]
  }

  /**
   * CommunityStory findFirstOrThrow
   */
  export type CommunityStoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityStory
     */
    select?: CommunityStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityStory
     */
    omit?: CommunityStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityStoryInclude<ExtArgs> | null
    /**
     * Filter, which CommunityStory to fetch.
     */
    where?: CommunityStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityStories to fetch.
     */
    orderBy?: CommunityStoryOrderByWithRelationInput | CommunityStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityStories.
     */
    cursor?: CommunityStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityStories.
     */
    distinct?: CommunityStoryScalarFieldEnum | CommunityStoryScalarFieldEnum[]
  }

  /**
   * CommunityStory findMany
   */
  export type CommunityStoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityStory
     */
    select?: CommunityStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityStory
     */
    omit?: CommunityStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityStoryInclude<ExtArgs> | null
    /**
     * Filter, which CommunityStories to fetch.
     */
    where?: CommunityStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityStories to fetch.
     */
    orderBy?: CommunityStoryOrderByWithRelationInput | CommunityStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityStories.
     */
    cursor?: CommunityStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityStories.
     */
    skip?: number
    distinct?: CommunityStoryScalarFieldEnum | CommunityStoryScalarFieldEnum[]
  }

  /**
   * CommunityStory create
   */
  export type CommunityStoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityStory
     */
    select?: CommunityStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityStory
     */
    omit?: CommunityStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityStoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityStory.
     */
    data: XOR<CommunityStoryCreateInput, CommunityStoryUncheckedCreateInput>
  }

  /**
   * CommunityStory createMany
   */
  export type CommunityStoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityStories.
     */
    data: CommunityStoryCreateManyInput | CommunityStoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityStory createManyAndReturn
   */
  export type CommunityStoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityStory
     */
    select?: CommunityStorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityStory
     */
    omit?: CommunityStoryOmit<ExtArgs> | null
    /**
     * The data used to create many CommunityStories.
     */
    data: CommunityStoryCreateManyInput | CommunityStoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityStoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommunityStory update
   */
  export type CommunityStoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityStory
     */
    select?: CommunityStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityStory
     */
    omit?: CommunityStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityStoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityStory.
     */
    data: XOR<CommunityStoryUpdateInput, CommunityStoryUncheckedUpdateInput>
    /**
     * Choose, which CommunityStory to update.
     */
    where: CommunityStoryWhereUniqueInput
  }

  /**
   * CommunityStory updateMany
   */
  export type CommunityStoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityStories.
     */
    data: XOR<CommunityStoryUpdateManyMutationInput, CommunityStoryUncheckedUpdateManyInput>
    /**
     * Filter which CommunityStories to update
     */
    where?: CommunityStoryWhereInput
    /**
     * Limit how many CommunityStories to update.
     */
    limit?: number
  }

  /**
   * CommunityStory updateManyAndReturn
   */
  export type CommunityStoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityStory
     */
    select?: CommunityStorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityStory
     */
    omit?: CommunityStoryOmit<ExtArgs> | null
    /**
     * The data used to update CommunityStories.
     */
    data: XOR<CommunityStoryUpdateManyMutationInput, CommunityStoryUncheckedUpdateManyInput>
    /**
     * Filter which CommunityStories to update
     */
    where?: CommunityStoryWhereInput
    /**
     * Limit how many CommunityStories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityStoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommunityStory upsert
   */
  export type CommunityStoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityStory
     */
    select?: CommunityStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityStory
     */
    omit?: CommunityStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityStoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityStory to update in case it exists.
     */
    where: CommunityStoryWhereUniqueInput
    /**
     * In case the CommunityStory found by the `where` argument doesn't exist, create a new CommunityStory with this data.
     */
    create: XOR<CommunityStoryCreateInput, CommunityStoryUncheckedCreateInput>
    /**
     * In case the CommunityStory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityStoryUpdateInput, CommunityStoryUncheckedUpdateInput>
  }

  /**
   * CommunityStory delete
   */
  export type CommunityStoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityStory
     */
    select?: CommunityStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityStory
     */
    omit?: CommunityStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityStoryInclude<ExtArgs> | null
    /**
     * Filter which CommunityStory to delete.
     */
    where: CommunityStoryWhereUniqueInput
  }

  /**
   * CommunityStory deleteMany
   */
  export type CommunityStoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityStories to delete
     */
    where?: CommunityStoryWhereInput
    /**
     * Limit how many CommunityStories to delete.
     */
    limit?: number
  }

  /**
   * CommunityStory without action
   */
  export type CommunityStoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityStory
     */
    select?: CommunityStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityStory
     */
    omit?: CommunityStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityStoryInclude<ExtArgs> | null
  }


  /**
   * Model ProductView
   */

  export type AggregateProductView = {
    _count: ProductViewCountAggregateOutputType | null
    _min: ProductViewMinAggregateOutputType | null
    _max: ProductViewMaxAggregateOutputType | null
  }

  export type ProductViewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    timestamp: Date | null
  }

  export type ProductViewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    timestamp: Date | null
  }

  export type ProductViewCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    timestamp: number
    _all: number
  }


  export type ProductViewMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    timestamp?: true
  }

  export type ProductViewMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    timestamp?: true
  }

  export type ProductViewCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    timestamp?: true
    _all?: true
  }

  export type ProductViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductView to aggregate.
     */
    where?: ProductViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductViews to fetch.
     */
    orderBy?: ProductViewOrderByWithRelationInput | ProductViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductViews
    **/
    _count?: true | ProductViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductViewMaxAggregateInputType
  }

  export type GetProductViewAggregateType<T extends ProductViewAggregateArgs> = {
        [P in keyof T & keyof AggregateProductView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductView[P]>
      : GetScalarType<T[P], AggregateProductView[P]>
  }




  export type ProductViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductViewWhereInput
    orderBy?: ProductViewOrderByWithAggregationInput | ProductViewOrderByWithAggregationInput[]
    by: ProductViewScalarFieldEnum[] | ProductViewScalarFieldEnum
    having?: ProductViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductViewCountAggregateInputType | true
    _min?: ProductViewMinAggregateInputType
    _max?: ProductViewMaxAggregateInputType
  }

  export type ProductViewGroupByOutputType = {
    id: string
    userId: string
    productId: string
    timestamp: Date
    _count: ProductViewCountAggregateOutputType | null
    _min: ProductViewMinAggregateOutputType | null
    _max: ProductViewMaxAggregateOutputType | null
  }

  type GetProductViewGroupByPayload<T extends ProductViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductViewGroupByOutputType[P]>
            : GetScalarType<T[P], ProductViewGroupByOutputType[P]>
        }
      >
    >


  export type ProductViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productView"]>

  export type ProductViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productView"]>

  export type ProductViewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productView"]>

  export type ProductViewSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    timestamp?: boolean
  }

  export type ProductViewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "productId" | "timestamp", ExtArgs["result"]["productView"]>
  export type ProductViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductViewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductViewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductView"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      productId: string
      timestamp: Date
    }, ExtArgs["result"]["productView"]>
    composites: {}
  }

  type ProductViewGetPayload<S extends boolean | null | undefined | ProductViewDefaultArgs> = $Result.GetResult<Prisma.$ProductViewPayload, S>

  type ProductViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductViewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductViewCountAggregateInputType | true
    }

  export interface ProductViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductView'], meta: { name: 'ProductView' } }
    /**
     * Find zero or one ProductView that matches the filter.
     * @param {ProductViewFindUniqueArgs} args - Arguments to find a ProductView
     * @example
     * // Get one ProductView
     * const productView = await prisma.productView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductViewFindUniqueArgs>(args: SelectSubset<T, ProductViewFindUniqueArgs<ExtArgs>>): Prisma__ProductViewClient<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductView that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductViewFindUniqueOrThrowArgs} args - Arguments to find a ProductView
     * @example
     * // Get one ProductView
     * const productView = await prisma.productView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductViewFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductViewClient<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductViewFindFirstArgs} args - Arguments to find a ProductView
     * @example
     * // Get one ProductView
     * const productView = await prisma.productView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductViewFindFirstArgs>(args?: SelectSubset<T, ProductViewFindFirstArgs<ExtArgs>>): Prisma__ProductViewClient<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductViewFindFirstOrThrowArgs} args - Arguments to find a ProductView
     * @example
     * // Get one ProductView
     * const productView = await prisma.productView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductViewFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductViewClient<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductViews
     * const productViews = await prisma.productView.findMany()
     * 
     * // Get first 10 ProductViews
     * const productViews = await prisma.productView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productViewWithIdOnly = await prisma.productView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductViewFindManyArgs>(args?: SelectSubset<T, ProductViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductView.
     * @param {ProductViewCreateArgs} args - Arguments to create a ProductView.
     * @example
     * // Create one ProductView
     * const ProductView = await prisma.productView.create({
     *   data: {
     *     // ... data to create a ProductView
     *   }
     * })
     * 
     */
    create<T extends ProductViewCreateArgs>(args: SelectSubset<T, ProductViewCreateArgs<ExtArgs>>): Prisma__ProductViewClient<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductViews.
     * @param {ProductViewCreateManyArgs} args - Arguments to create many ProductViews.
     * @example
     * // Create many ProductViews
     * const productView = await prisma.productView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductViewCreateManyArgs>(args?: SelectSubset<T, ProductViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductViews and returns the data saved in the database.
     * @param {ProductViewCreateManyAndReturnArgs} args - Arguments to create many ProductViews.
     * @example
     * // Create many ProductViews
     * const productView = await prisma.productView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductViews and only return the `id`
     * const productViewWithIdOnly = await prisma.productView.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductViewCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductView.
     * @param {ProductViewDeleteArgs} args - Arguments to delete one ProductView.
     * @example
     * // Delete one ProductView
     * const ProductView = await prisma.productView.delete({
     *   where: {
     *     // ... filter to delete one ProductView
     *   }
     * })
     * 
     */
    delete<T extends ProductViewDeleteArgs>(args: SelectSubset<T, ProductViewDeleteArgs<ExtArgs>>): Prisma__ProductViewClient<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductView.
     * @param {ProductViewUpdateArgs} args - Arguments to update one ProductView.
     * @example
     * // Update one ProductView
     * const productView = await prisma.productView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductViewUpdateArgs>(args: SelectSubset<T, ProductViewUpdateArgs<ExtArgs>>): Prisma__ProductViewClient<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductViews.
     * @param {ProductViewDeleteManyArgs} args - Arguments to filter ProductViews to delete.
     * @example
     * // Delete a few ProductViews
     * const { count } = await prisma.productView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductViewDeleteManyArgs>(args?: SelectSubset<T, ProductViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductViews
     * const productView = await prisma.productView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductViewUpdateManyArgs>(args: SelectSubset<T, ProductViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductViews and returns the data updated in the database.
     * @param {ProductViewUpdateManyAndReturnArgs} args - Arguments to update many ProductViews.
     * @example
     * // Update many ProductViews
     * const productView = await prisma.productView.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductViews and only return the `id`
     * const productViewWithIdOnly = await prisma.productView.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductViewUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductViewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductView.
     * @param {ProductViewUpsertArgs} args - Arguments to update or create a ProductView.
     * @example
     * // Update or create a ProductView
     * const productView = await prisma.productView.upsert({
     *   create: {
     *     // ... data to create a ProductView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductView we want to update
     *   }
     * })
     */
    upsert<T extends ProductViewUpsertArgs>(args: SelectSubset<T, ProductViewUpsertArgs<ExtArgs>>): Prisma__ProductViewClient<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductViewCountArgs} args - Arguments to filter ProductViews to count.
     * @example
     * // Count the number of ProductViews
     * const count = await prisma.productView.count({
     *   where: {
     *     // ... the filter for the ProductViews we want to count
     *   }
     * })
    **/
    count<T extends ProductViewCountArgs>(
      args?: Subset<T, ProductViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductViewAggregateArgs>(args: Subset<T, ProductViewAggregateArgs>): Prisma.PrismaPromise<GetProductViewAggregateType<T>>

    /**
     * Group by ProductView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductViewGroupByArgs['orderBy'] }
        : { orderBy?: ProductViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductView model
   */
  readonly fields: ProductViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductView model
   */
  interface ProductViewFieldRefs {
    readonly id: FieldRef<"ProductView", 'String'>
    readonly userId: FieldRef<"ProductView", 'String'>
    readonly productId: FieldRef<"ProductView", 'String'>
    readonly timestamp: FieldRef<"ProductView", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductView findUnique
   */
  export type ProductViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductView
     */
    omit?: ProductViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    /**
     * Filter, which ProductView to fetch.
     */
    where: ProductViewWhereUniqueInput
  }

  /**
   * ProductView findUniqueOrThrow
   */
  export type ProductViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductView
     */
    omit?: ProductViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    /**
     * Filter, which ProductView to fetch.
     */
    where: ProductViewWhereUniqueInput
  }

  /**
   * ProductView findFirst
   */
  export type ProductViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductView
     */
    omit?: ProductViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    /**
     * Filter, which ProductView to fetch.
     */
    where?: ProductViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductViews to fetch.
     */
    orderBy?: ProductViewOrderByWithRelationInput | ProductViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductViews.
     */
    cursor?: ProductViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductViews.
     */
    distinct?: ProductViewScalarFieldEnum | ProductViewScalarFieldEnum[]
  }

  /**
   * ProductView findFirstOrThrow
   */
  export type ProductViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductView
     */
    omit?: ProductViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    /**
     * Filter, which ProductView to fetch.
     */
    where?: ProductViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductViews to fetch.
     */
    orderBy?: ProductViewOrderByWithRelationInput | ProductViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductViews.
     */
    cursor?: ProductViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductViews.
     */
    distinct?: ProductViewScalarFieldEnum | ProductViewScalarFieldEnum[]
  }

  /**
   * ProductView findMany
   */
  export type ProductViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductView
     */
    omit?: ProductViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    /**
     * Filter, which ProductViews to fetch.
     */
    where?: ProductViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductViews to fetch.
     */
    orderBy?: ProductViewOrderByWithRelationInput | ProductViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductViews.
     */
    cursor?: ProductViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductViews.
     */
    skip?: number
    distinct?: ProductViewScalarFieldEnum | ProductViewScalarFieldEnum[]
  }

  /**
   * ProductView create
   */
  export type ProductViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductView
     */
    omit?: ProductViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductView.
     */
    data: XOR<ProductViewCreateInput, ProductViewUncheckedCreateInput>
  }

  /**
   * ProductView createMany
   */
  export type ProductViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductViews.
     */
    data: ProductViewCreateManyInput | ProductViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductView createManyAndReturn
   */
  export type ProductViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductView
     */
    omit?: ProductViewOmit<ExtArgs> | null
    /**
     * The data used to create many ProductViews.
     */
    data: ProductViewCreateManyInput | ProductViewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductView update
   */
  export type ProductViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductView
     */
    omit?: ProductViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductView.
     */
    data: XOR<ProductViewUpdateInput, ProductViewUncheckedUpdateInput>
    /**
     * Choose, which ProductView to update.
     */
    where: ProductViewWhereUniqueInput
  }

  /**
   * ProductView updateMany
   */
  export type ProductViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductViews.
     */
    data: XOR<ProductViewUpdateManyMutationInput, ProductViewUncheckedUpdateManyInput>
    /**
     * Filter which ProductViews to update
     */
    where?: ProductViewWhereInput
    /**
     * Limit how many ProductViews to update.
     */
    limit?: number
  }

  /**
   * ProductView updateManyAndReturn
   */
  export type ProductViewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductView
     */
    omit?: ProductViewOmit<ExtArgs> | null
    /**
     * The data used to update ProductViews.
     */
    data: XOR<ProductViewUpdateManyMutationInput, ProductViewUncheckedUpdateManyInput>
    /**
     * Filter which ProductViews to update
     */
    where?: ProductViewWhereInput
    /**
     * Limit how many ProductViews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductView upsert
   */
  export type ProductViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductView
     */
    omit?: ProductViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductView to update in case it exists.
     */
    where: ProductViewWhereUniqueInput
    /**
     * In case the ProductView found by the `where` argument doesn't exist, create a new ProductView with this data.
     */
    create: XOR<ProductViewCreateInput, ProductViewUncheckedCreateInput>
    /**
     * In case the ProductView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductViewUpdateInput, ProductViewUncheckedUpdateInput>
  }

  /**
   * ProductView delete
   */
  export type ProductViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductView
     */
    omit?: ProductViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    /**
     * Filter which ProductView to delete.
     */
    where: ProductViewWhereUniqueInput
  }

  /**
   * ProductView deleteMany
   */
  export type ProductViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductViews to delete
     */
    where?: ProductViewWhereInput
    /**
     * Limit how many ProductViews to delete.
     */
    limit?: number
  }

  /**
   * ProductView without action
   */
  export type ProductViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductView
     */
    omit?: ProductViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
  }


  /**
   * Model SponsoredPlacement
   */

  export type AggregateSponsoredPlacement = {
    _count: SponsoredPlacementCountAggregateOutputType | null
    _avg: SponsoredPlacementAvgAggregateOutputType | null
    _sum: SponsoredPlacementSumAggregateOutputType | null
    _min: SponsoredPlacementMinAggregateOutputType | null
    _max: SponsoredPlacementMaxAggregateOutputType | null
  }

  export type SponsoredPlacementAvgAggregateOutputType = {
    bidAmount: Decimal | null
  }

  export type SponsoredPlacementSumAggregateOutputType = {
    bidAmount: Decimal | null
  }

  export type SponsoredPlacementMinAggregateOutputType = {
    id: string | null
    sellerId: string | null
    productId: string | null
    categorySlug: string | null
    searchTerm: string | null
    bidAmount: Decimal | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.SponsoredPlacementStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SponsoredPlacementMaxAggregateOutputType = {
    id: string | null
    sellerId: string | null
    productId: string | null
    categorySlug: string | null
    searchTerm: string | null
    bidAmount: Decimal | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.SponsoredPlacementStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SponsoredPlacementCountAggregateOutputType = {
    id: number
    sellerId: number
    productId: number
    categorySlug: number
    searchTerm: number
    bidAmount: number
    startDate: number
    endDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SponsoredPlacementAvgAggregateInputType = {
    bidAmount?: true
  }

  export type SponsoredPlacementSumAggregateInputType = {
    bidAmount?: true
  }

  export type SponsoredPlacementMinAggregateInputType = {
    id?: true
    sellerId?: true
    productId?: true
    categorySlug?: true
    searchTerm?: true
    bidAmount?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SponsoredPlacementMaxAggregateInputType = {
    id?: true
    sellerId?: true
    productId?: true
    categorySlug?: true
    searchTerm?: true
    bidAmount?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SponsoredPlacementCountAggregateInputType = {
    id?: true
    sellerId?: true
    productId?: true
    categorySlug?: true
    searchTerm?: true
    bidAmount?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SponsoredPlacementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SponsoredPlacement to aggregate.
     */
    where?: SponsoredPlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SponsoredPlacements to fetch.
     */
    orderBy?: SponsoredPlacementOrderByWithRelationInput | SponsoredPlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SponsoredPlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SponsoredPlacements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SponsoredPlacements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SponsoredPlacements
    **/
    _count?: true | SponsoredPlacementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SponsoredPlacementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SponsoredPlacementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SponsoredPlacementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SponsoredPlacementMaxAggregateInputType
  }

  export type GetSponsoredPlacementAggregateType<T extends SponsoredPlacementAggregateArgs> = {
        [P in keyof T & keyof AggregateSponsoredPlacement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSponsoredPlacement[P]>
      : GetScalarType<T[P], AggregateSponsoredPlacement[P]>
  }




  export type SponsoredPlacementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SponsoredPlacementWhereInput
    orderBy?: SponsoredPlacementOrderByWithAggregationInput | SponsoredPlacementOrderByWithAggregationInput[]
    by: SponsoredPlacementScalarFieldEnum[] | SponsoredPlacementScalarFieldEnum
    having?: SponsoredPlacementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SponsoredPlacementCountAggregateInputType | true
    _avg?: SponsoredPlacementAvgAggregateInputType
    _sum?: SponsoredPlacementSumAggregateInputType
    _min?: SponsoredPlacementMinAggregateInputType
    _max?: SponsoredPlacementMaxAggregateInputType
  }

  export type SponsoredPlacementGroupByOutputType = {
    id: string
    sellerId: string
    productId: string
    categorySlug: string | null
    searchTerm: string | null
    bidAmount: Decimal
    startDate: Date
    endDate: Date
    status: $Enums.SponsoredPlacementStatus
    createdAt: Date
    updatedAt: Date
    _count: SponsoredPlacementCountAggregateOutputType | null
    _avg: SponsoredPlacementAvgAggregateOutputType | null
    _sum: SponsoredPlacementSumAggregateOutputType | null
    _min: SponsoredPlacementMinAggregateOutputType | null
    _max: SponsoredPlacementMaxAggregateOutputType | null
  }

  type GetSponsoredPlacementGroupByPayload<T extends SponsoredPlacementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SponsoredPlacementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SponsoredPlacementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SponsoredPlacementGroupByOutputType[P]>
            : GetScalarType<T[P], SponsoredPlacementGroupByOutputType[P]>
        }
      >
    >


  export type SponsoredPlacementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    productId?: boolean
    categorySlug?: boolean
    searchTerm?: boolean
    bidAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sponsoredPlacement"]>

  export type SponsoredPlacementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    productId?: boolean
    categorySlug?: boolean
    searchTerm?: boolean
    bidAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sponsoredPlacement"]>

  export type SponsoredPlacementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    productId?: boolean
    categorySlug?: boolean
    searchTerm?: boolean
    bidAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sponsoredPlacement"]>

  export type SponsoredPlacementSelectScalar = {
    id?: boolean
    sellerId?: boolean
    productId?: boolean
    categorySlug?: boolean
    searchTerm?: boolean
    bidAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SponsoredPlacementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sellerId" | "productId" | "categorySlug" | "searchTerm" | "bidAmount" | "startDate" | "endDate" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["sponsoredPlacement"]>
  export type SponsoredPlacementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type SponsoredPlacementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type SponsoredPlacementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $SponsoredPlacementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SponsoredPlacement"
    objects: {
      seller: Prisma.$UserPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sellerId: string
      productId: string
      categorySlug: string | null
      searchTerm: string | null
      bidAmount: Prisma.Decimal
      startDate: Date
      endDate: Date
      status: $Enums.SponsoredPlacementStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sponsoredPlacement"]>
    composites: {}
  }

  type SponsoredPlacementGetPayload<S extends boolean | null | undefined | SponsoredPlacementDefaultArgs> = $Result.GetResult<Prisma.$SponsoredPlacementPayload, S>

  type SponsoredPlacementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SponsoredPlacementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SponsoredPlacementCountAggregateInputType | true
    }

  export interface SponsoredPlacementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SponsoredPlacement'], meta: { name: 'SponsoredPlacement' } }
    /**
     * Find zero or one SponsoredPlacement that matches the filter.
     * @param {SponsoredPlacementFindUniqueArgs} args - Arguments to find a SponsoredPlacement
     * @example
     * // Get one SponsoredPlacement
     * const sponsoredPlacement = await prisma.sponsoredPlacement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SponsoredPlacementFindUniqueArgs>(args: SelectSubset<T, SponsoredPlacementFindUniqueArgs<ExtArgs>>): Prisma__SponsoredPlacementClient<$Result.GetResult<Prisma.$SponsoredPlacementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SponsoredPlacement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SponsoredPlacementFindUniqueOrThrowArgs} args - Arguments to find a SponsoredPlacement
     * @example
     * // Get one SponsoredPlacement
     * const sponsoredPlacement = await prisma.sponsoredPlacement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SponsoredPlacementFindUniqueOrThrowArgs>(args: SelectSubset<T, SponsoredPlacementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SponsoredPlacementClient<$Result.GetResult<Prisma.$SponsoredPlacementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SponsoredPlacement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsoredPlacementFindFirstArgs} args - Arguments to find a SponsoredPlacement
     * @example
     * // Get one SponsoredPlacement
     * const sponsoredPlacement = await prisma.sponsoredPlacement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SponsoredPlacementFindFirstArgs>(args?: SelectSubset<T, SponsoredPlacementFindFirstArgs<ExtArgs>>): Prisma__SponsoredPlacementClient<$Result.GetResult<Prisma.$SponsoredPlacementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SponsoredPlacement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsoredPlacementFindFirstOrThrowArgs} args - Arguments to find a SponsoredPlacement
     * @example
     * // Get one SponsoredPlacement
     * const sponsoredPlacement = await prisma.sponsoredPlacement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SponsoredPlacementFindFirstOrThrowArgs>(args?: SelectSubset<T, SponsoredPlacementFindFirstOrThrowArgs<ExtArgs>>): Prisma__SponsoredPlacementClient<$Result.GetResult<Prisma.$SponsoredPlacementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SponsoredPlacements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsoredPlacementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SponsoredPlacements
     * const sponsoredPlacements = await prisma.sponsoredPlacement.findMany()
     * 
     * // Get first 10 SponsoredPlacements
     * const sponsoredPlacements = await prisma.sponsoredPlacement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sponsoredPlacementWithIdOnly = await prisma.sponsoredPlacement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SponsoredPlacementFindManyArgs>(args?: SelectSubset<T, SponsoredPlacementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsoredPlacementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SponsoredPlacement.
     * @param {SponsoredPlacementCreateArgs} args - Arguments to create a SponsoredPlacement.
     * @example
     * // Create one SponsoredPlacement
     * const SponsoredPlacement = await prisma.sponsoredPlacement.create({
     *   data: {
     *     // ... data to create a SponsoredPlacement
     *   }
     * })
     * 
     */
    create<T extends SponsoredPlacementCreateArgs>(args: SelectSubset<T, SponsoredPlacementCreateArgs<ExtArgs>>): Prisma__SponsoredPlacementClient<$Result.GetResult<Prisma.$SponsoredPlacementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SponsoredPlacements.
     * @param {SponsoredPlacementCreateManyArgs} args - Arguments to create many SponsoredPlacements.
     * @example
     * // Create many SponsoredPlacements
     * const sponsoredPlacement = await prisma.sponsoredPlacement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SponsoredPlacementCreateManyArgs>(args?: SelectSubset<T, SponsoredPlacementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SponsoredPlacements and returns the data saved in the database.
     * @param {SponsoredPlacementCreateManyAndReturnArgs} args - Arguments to create many SponsoredPlacements.
     * @example
     * // Create many SponsoredPlacements
     * const sponsoredPlacement = await prisma.sponsoredPlacement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SponsoredPlacements and only return the `id`
     * const sponsoredPlacementWithIdOnly = await prisma.sponsoredPlacement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SponsoredPlacementCreateManyAndReturnArgs>(args?: SelectSubset<T, SponsoredPlacementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsoredPlacementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SponsoredPlacement.
     * @param {SponsoredPlacementDeleteArgs} args - Arguments to delete one SponsoredPlacement.
     * @example
     * // Delete one SponsoredPlacement
     * const SponsoredPlacement = await prisma.sponsoredPlacement.delete({
     *   where: {
     *     // ... filter to delete one SponsoredPlacement
     *   }
     * })
     * 
     */
    delete<T extends SponsoredPlacementDeleteArgs>(args: SelectSubset<T, SponsoredPlacementDeleteArgs<ExtArgs>>): Prisma__SponsoredPlacementClient<$Result.GetResult<Prisma.$SponsoredPlacementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SponsoredPlacement.
     * @param {SponsoredPlacementUpdateArgs} args - Arguments to update one SponsoredPlacement.
     * @example
     * // Update one SponsoredPlacement
     * const sponsoredPlacement = await prisma.sponsoredPlacement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SponsoredPlacementUpdateArgs>(args: SelectSubset<T, SponsoredPlacementUpdateArgs<ExtArgs>>): Prisma__SponsoredPlacementClient<$Result.GetResult<Prisma.$SponsoredPlacementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SponsoredPlacements.
     * @param {SponsoredPlacementDeleteManyArgs} args - Arguments to filter SponsoredPlacements to delete.
     * @example
     * // Delete a few SponsoredPlacements
     * const { count } = await prisma.sponsoredPlacement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SponsoredPlacementDeleteManyArgs>(args?: SelectSubset<T, SponsoredPlacementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SponsoredPlacements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsoredPlacementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SponsoredPlacements
     * const sponsoredPlacement = await prisma.sponsoredPlacement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SponsoredPlacementUpdateManyArgs>(args: SelectSubset<T, SponsoredPlacementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SponsoredPlacements and returns the data updated in the database.
     * @param {SponsoredPlacementUpdateManyAndReturnArgs} args - Arguments to update many SponsoredPlacements.
     * @example
     * // Update many SponsoredPlacements
     * const sponsoredPlacement = await prisma.sponsoredPlacement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SponsoredPlacements and only return the `id`
     * const sponsoredPlacementWithIdOnly = await prisma.sponsoredPlacement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SponsoredPlacementUpdateManyAndReturnArgs>(args: SelectSubset<T, SponsoredPlacementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsoredPlacementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SponsoredPlacement.
     * @param {SponsoredPlacementUpsertArgs} args - Arguments to update or create a SponsoredPlacement.
     * @example
     * // Update or create a SponsoredPlacement
     * const sponsoredPlacement = await prisma.sponsoredPlacement.upsert({
     *   create: {
     *     // ... data to create a SponsoredPlacement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SponsoredPlacement we want to update
     *   }
     * })
     */
    upsert<T extends SponsoredPlacementUpsertArgs>(args: SelectSubset<T, SponsoredPlacementUpsertArgs<ExtArgs>>): Prisma__SponsoredPlacementClient<$Result.GetResult<Prisma.$SponsoredPlacementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SponsoredPlacements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsoredPlacementCountArgs} args - Arguments to filter SponsoredPlacements to count.
     * @example
     * // Count the number of SponsoredPlacements
     * const count = await prisma.sponsoredPlacement.count({
     *   where: {
     *     // ... the filter for the SponsoredPlacements we want to count
     *   }
     * })
    **/
    count<T extends SponsoredPlacementCountArgs>(
      args?: Subset<T, SponsoredPlacementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SponsoredPlacementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SponsoredPlacement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsoredPlacementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SponsoredPlacementAggregateArgs>(args: Subset<T, SponsoredPlacementAggregateArgs>): Prisma.PrismaPromise<GetSponsoredPlacementAggregateType<T>>

    /**
     * Group by SponsoredPlacement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsoredPlacementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SponsoredPlacementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SponsoredPlacementGroupByArgs['orderBy'] }
        : { orderBy?: SponsoredPlacementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SponsoredPlacementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSponsoredPlacementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SponsoredPlacement model
   */
  readonly fields: SponsoredPlacementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SponsoredPlacement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SponsoredPlacementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SponsoredPlacement model
   */
  interface SponsoredPlacementFieldRefs {
    readonly id: FieldRef<"SponsoredPlacement", 'String'>
    readonly sellerId: FieldRef<"SponsoredPlacement", 'String'>
    readonly productId: FieldRef<"SponsoredPlacement", 'String'>
    readonly categorySlug: FieldRef<"SponsoredPlacement", 'String'>
    readonly searchTerm: FieldRef<"SponsoredPlacement", 'String'>
    readonly bidAmount: FieldRef<"SponsoredPlacement", 'Decimal'>
    readonly startDate: FieldRef<"SponsoredPlacement", 'DateTime'>
    readonly endDate: FieldRef<"SponsoredPlacement", 'DateTime'>
    readonly status: FieldRef<"SponsoredPlacement", 'SponsoredPlacementStatus'>
    readonly createdAt: FieldRef<"SponsoredPlacement", 'DateTime'>
    readonly updatedAt: FieldRef<"SponsoredPlacement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SponsoredPlacement findUnique
   */
  export type SponsoredPlacementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsoredPlacement
     */
    select?: SponsoredPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsoredPlacement
     */
    omit?: SponsoredPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsoredPlacementInclude<ExtArgs> | null
    /**
     * Filter, which SponsoredPlacement to fetch.
     */
    where: SponsoredPlacementWhereUniqueInput
  }

  /**
   * SponsoredPlacement findUniqueOrThrow
   */
  export type SponsoredPlacementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsoredPlacement
     */
    select?: SponsoredPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsoredPlacement
     */
    omit?: SponsoredPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsoredPlacementInclude<ExtArgs> | null
    /**
     * Filter, which SponsoredPlacement to fetch.
     */
    where: SponsoredPlacementWhereUniqueInput
  }

  /**
   * SponsoredPlacement findFirst
   */
  export type SponsoredPlacementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsoredPlacement
     */
    select?: SponsoredPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsoredPlacement
     */
    omit?: SponsoredPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsoredPlacementInclude<ExtArgs> | null
    /**
     * Filter, which SponsoredPlacement to fetch.
     */
    where?: SponsoredPlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SponsoredPlacements to fetch.
     */
    orderBy?: SponsoredPlacementOrderByWithRelationInput | SponsoredPlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SponsoredPlacements.
     */
    cursor?: SponsoredPlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SponsoredPlacements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SponsoredPlacements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SponsoredPlacements.
     */
    distinct?: SponsoredPlacementScalarFieldEnum | SponsoredPlacementScalarFieldEnum[]
  }

  /**
   * SponsoredPlacement findFirstOrThrow
   */
  export type SponsoredPlacementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsoredPlacement
     */
    select?: SponsoredPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsoredPlacement
     */
    omit?: SponsoredPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsoredPlacementInclude<ExtArgs> | null
    /**
     * Filter, which SponsoredPlacement to fetch.
     */
    where?: SponsoredPlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SponsoredPlacements to fetch.
     */
    orderBy?: SponsoredPlacementOrderByWithRelationInput | SponsoredPlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SponsoredPlacements.
     */
    cursor?: SponsoredPlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SponsoredPlacements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SponsoredPlacements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SponsoredPlacements.
     */
    distinct?: SponsoredPlacementScalarFieldEnum | SponsoredPlacementScalarFieldEnum[]
  }

  /**
   * SponsoredPlacement findMany
   */
  export type SponsoredPlacementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsoredPlacement
     */
    select?: SponsoredPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsoredPlacement
     */
    omit?: SponsoredPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsoredPlacementInclude<ExtArgs> | null
    /**
     * Filter, which SponsoredPlacements to fetch.
     */
    where?: SponsoredPlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SponsoredPlacements to fetch.
     */
    orderBy?: SponsoredPlacementOrderByWithRelationInput | SponsoredPlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SponsoredPlacements.
     */
    cursor?: SponsoredPlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SponsoredPlacements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SponsoredPlacements.
     */
    skip?: number
    distinct?: SponsoredPlacementScalarFieldEnum | SponsoredPlacementScalarFieldEnum[]
  }

  /**
   * SponsoredPlacement create
   */
  export type SponsoredPlacementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsoredPlacement
     */
    select?: SponsoredPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsoredPlacement
     */
    omit?: SponsoredPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsoredPlacementInclude<ExtArgs> | null
    /**
     * The data needed to create a SponsoredPlacement.
     */
    data: XOR<SponsoredPlacementCreateInput, SponsoredPlacementUncheckedCreateInput>
  }

  /**
   * SponsoredPlacement createMany
   */
  export type SponsoredPlacementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SponsoredPlacements.
     */
    data: SponsoredPlacementCreateManyInput | SponsoredPlacementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SponsoredPlacement createManyAndReturn
   */
  export type SponsoredPlacementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsoredPlacement
     */
    select?: SponsoredPlacementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SponsoredPlacement
     */
    omit?: SponsoredPlacementOmit<ExtArgs> | null
    /**
     * The data used to create many SponsoredPlacements.
     */
    data: SponsoredPlacementCreateManyInput | SponsoredPlacementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsoredPlacementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SponsoredPlacement update
   */
  export type SponsoredPlacementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsoredPlacement
     */
    select?: SponsoredPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsoredPlacement
     */
    omit?: SponsoredPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsoredPlacementInclude<ExtArgs> | null
    /**
     * The data needed to update a SponsoredPlacement.
     */
    data: XOR<SponsoredPlacementUpdateInput, SponsoredPlacementUncheckedUpdateInput>
    /**
     * Choose, which SponsoredPlacement to update.
     */
    where: SponsoredPlacementWhereUniqueInput
  }

  /**
   * SponsoredPlacement updateMany
   */
  export type SponsoredPlacementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SponsoredPlacements.
     */
    data: XOR<SponsoredPlacementUpdateManyMutationInput, SponsoredPlacementUncheckedUpdateManyInput>
    /**
     * Filter which SponsoredPlacements to update
     */
    where?: SponsoredPlacementWhereInput
    /**
     * Limit how many SponsoredPlacements to update.
     */
    limit?: number
  }

  /**
   * SponsoredPlacement updateManyAndReturn
   */
  export type SponsoredPlacementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsoredPlacement
     */
    select?: SponsoredPlacementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SponsoredPlacement
     */
    omit?: SponsoredPlacementOmit<ExtArgs> | null
    /**
     * The data used to update SponsoredPlacements.
     */
    data: XOR<SponsoredPlacementUpdateManyMutationInput, SponsoredPlacementUncheckedUpdateManyInput>
    /**
     * Filter which SponsoredPlacements to update
     */
    where?: SponsoredPlacementWhereInput
    /**
     * Limit how many SponsoredPlacements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsoredPlacementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SponsoredPlacement upsert
   */
  export type SponsoredPlacementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsoredPlacement
     */
    select?: SponsoredPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsoredPlacement
     */
    omit?: SponsoredPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsoredPlacementInclude<ExtArgs> | null
    /**
     * The filter to search for the SponsoredPlacement to update in case it exists.
     */
    where: SponsoredPlacementWhereUniqueInput
    /**
     * In case the SponsoredPlacement found by the `where` argument doesn't exist, create a new SponsoredPlacement with this data.
     */
    create: XOR<SponsoredPlacementCreateInput, SponsoredPlacementUncheckedCreateInput>
    /**
     * In case the SponsoredPlacement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SponsoredPlacementUpdateInput, SponsoredPlacementUncheckedUpdateInput>
  }

  /**
   * SponsoredPlacement delete
   */
  export type SponsoredPlacementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsoredPlacement
     */
    select?: SponsoredPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsoredPlacement
     */
    omit?: SponsoredPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsoredPlacementInclude<ExtArgs> | null
    /**
     * Filter which SponsoredPlacement to delete.
     */
    where: SponsoredPlacementWhereUniqueInput
  }

  /**
   * SponsoredPlacement deleteMany
   */
  export type SponsoredPlacementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SponsoredPlacements to delete
     */
    where?: SponsoredPlacementWhereInput
    /**
     * Limit how many SponsoredPlacements to delete.
     */
    limit?: number
  }

  /**
   * SponsoredPlacement without action
   */
  export type SponsoredPlacementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsoredPlacement
     */
    select?: SponsoredPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SponsoredPlacement
     */
    omit?: SponsoredPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsoredPlacementInclude<ExtArgs> | null
  }


  /**
   * Model SellerService
   */

  export type AggregateSellerService = {
    _count: SellerServiceCountAggregateOutputType | null
    _avg: SellerServiceAvgAggregateOutputType | null
    _sum: SellerServiceSumAggregateOutputType | null
    _min: SellerServiceMinAggregateOutputType | null
    _max: SellerServiceMaxAggregateOutputType | null
  }

  export type SellerServiceAvgAggregateOutputType = {
    price: Decimal | null
    deliveryTime: number | null
  }

  export type SellerServiceSumAggregateOutputType = {
    price: Decimal | null
    deliveryTime: number | null
  }

  export type SellerServiceMinAggregateOutputType = {
    id: string | null
    sellerId: string | null
    title: string | null
    description: string | null
    price: Decimal | null
    currency: string | null
    category: string | null
    deliveryTime: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellerServiceMaxAggregateOutputType = {
    id: string | null
    sellerId: string | null
    title: string | null
    description: string | null
    price: Decimal | null
    currency: string | null
    category: string | null
    deliveryTime: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellerServiceCountAggregateOutputType = {
    id: number
    sellerId: number
    title: number
    description: number
    price: number
    currency: number
    category: number
    deliveryTime: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SellerServiceAvgAggregateInputType = {
    price?: true
    deliveryTime?: true
  }

  export type SellerServiceSumAggregateInputType = {
    price?: true
    deliveryTime?: true
  }

  export type SellerServiceMinAggregateInputType = {
    id?: true
    sellerId?: true
    title?: true
    description?: true
    price?: true
    currency?: true
    category?: true
    deliveryTime?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellerServiceMaxAggregateInputType = {
    id?: true
    sellerId?: true
    title?: true
    description?: true
    price?: true
    currency?: true
    category?: true
    deliveryTime?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellerServiceCountAggregateInputType = {
    id?: true
    sellerId?: true
    title?: true
    description?: true
    price?: true
    currency?: true
    category?: true
    deliveryTime?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SellerServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellerService to aggregate.
     */
    where?: SellerServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerServices to fetch.
     */
    orderBy?: SellerServiceOrderByWithRelationInput | SellerServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellerServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellerServices
    **/
    _count?: true | SellerServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellerServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellerServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellerServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellerServiceMaxAggregateInputType
  }

  export type GetSellerServiceAggregateType<T extends SellerServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateSellerService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellerService[P]>
      : GetScalarType<T[P], AggregateSellerService[P]>
  }




  export type SellerServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellerServiceWhereInput
    orderBy?: SellerServiceOrderByWithAggregationInput | SellerServiceOrderByWithAggregationInput[]
    by: SellerServiceScalarFieldEnum[] | SellerServiceScalarFieldEnum
    having?: SellerServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellerServiceCountAggregateInputType | true
    _avg?: SellerServiceAvgAggregateInputType
    _sum?: SellerServiceSumAggregateInputType
    _min?: SellerServiceMinAggregateInputType
    _max?: SellerServiceMaxAggregateInputType
  }

  export type SellerServiceGroupByOutputType = {
    id: string
    sellerId: string
    title: string
    description: string
    price: Decimal
    currency: string
    category: string
    deliveryTime: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: SellerServiceCountAggregateOutputType | null
    _avg: SellerServiceAvgAggregateOutputType | null
    _sum: SellerServiceSumAggregateOutputType | null
    _min: SellerServiceMinAggregateOutputType | null
    _max: SellerServiceMaxAggregateOutputType | null
  }

  type GetSellerServiceGroupByPayload<T extends SellerServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellerServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellerServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellerServiceGroupByOutputType[P]>
            : GetScalarType<T[P], SellerServiceGroupByOutputType[P]>
        }
      >
    >


  export type SellerServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    category?: boolean
    deliveryTime?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
    orders?: boolean | SellerService$ordersArgs<ExtArgs>
    _count?: boolean | SellerServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellerService"]>

  export type SellerServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    category?: boolean
    deliveryTime?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellerService"]>

  export type SellerServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    category?: boolean
    deliveryTime?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellerService"]>

  export type SellerServiceSelectScalar = {
    id?: boolean
    sellerId?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    category?: boolean
    deliveryTime?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SellerServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sellerId" | "title" | "description" | "price" | "currency" | "category" | "deliveryTime" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["sellerService"]>
  export type SellerServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
    orders?: boolean | SellerService$ordersArgs<ExtArgs>
    _count?: boolean | SellerServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SellerServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SellerServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SellerServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellerService"
    objects: {
      seller: Prisma.$UserPayload<ExtArgs>
      orders: Prisma.$ServiceOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sellerId: string
      title: string
      description: string
      price: Prisma.Decimal
      currency: string
      category: string
      deliveryTime: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sellerService"]>
    composites: {}
  }

  type SellerServiceGetPayload<S extends boolean | null | undefined | SellerServiceDefaultArgs> = $Result.GetResult<Prisma.$SellerServicePayload, S>

  type SellerServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellerServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellerServiceCountAggregateInputType | true
    }

  export interface SellerServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellerService'], meta: { name: 'SellerService' } }
    /**
     * Find zero or one SellerService that matches the filter.
     * @param {SellerServiceFindUniqueArgs} args - Arguments to find a SellerService
     * @example
     * // Get one SellerService
     * const sellerService = await prisma.sellerService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellerServiceFindUniqueArgs>(args: SelectSubset<T, SellerServiceFindUniqueArgs<ExtArgs>>): Prisma__SellerServiceClient<$Result.GetResult<Prisma.$SellerServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SellerService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellerServiceFindUniqueOrThrowArgs} args - Arguments to find a SellerService
     * @example
     * // Get one SellerService
     * const sellerService = await prisma.sellerService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellerServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, SellerServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellerServiceClient<$Result.GetResult<Prisma.$SellerServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellerService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerServiceFindFirstArgs} args - Arguments to find a SellerService
     * @example
     * // Get one SellerService
     * const sellerService = await prisma.sellerService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellerServiceFindFirstArgs>(args?: SelectSubset<T, SellerServiceFindFirstArgs<ExtArgs>>): Prisma__SellerServiceClient<$Result.GetResult<Prisma.$SellerServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellerService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerServiceFindFirstOrThrowArgs} args - Arguments to find a SellerService
     * @example
     * // Get one SellerService
     * const sellerService = await prisma.sellerService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellerServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, SellerServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellerServiceClient<$Result.GetResult<Prisma.$SellerServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellerServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellerServices
     * const sellerServices = await prisma.sellerService.findMany()
     * 
     * // Get first 10 SellerServices
     * const sellerServices = await prisma.sellerService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellerServiceWithIdOnly = await prisma.sellerService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellerServiceFindManyArgs>(args?: SelectSubset<T, SellerServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SellerService.
     * @param {SellerServiceCreateArgs} args - Arguments to create a SellerService.
     * @example
     * // Create one SellerService
     * const SellerService = await prisma.sellerService.create({
     *   data: {
     *     // ... data to create a SellerService
     *   }
     * })
     * 
     */
    create<T extends SellerServiceCreateArgs>(args: SelectSubset<T, SellerServiceCreateArgs<ExtArgs>>): Prisma__SellerServiceClient<$Result.GetResult<Prisma.$SellerServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SellerServices.
     * @param {SellerServiceCreateManyArgs} args - Arguments to create many SellerServices.
     * @example
     * // Create many SellerServices
     * const sellerService = await prisma.sellerService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellerServiceCreateManyArgs>(args?: SelectSubset<T, SellerServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SellerServices and returns the data saved in the database.
     * @param {SellerServiceCreateManyAndReturnArgs} args - Arguments to create many SellerServices.
     * @example
     * // Create many SellerServices
     * const sellerService = await prisma.sellerService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SellerServices and only return the `id`
     * const sellerServiceWithIdOnly = await prisma.sellerService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SellerServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, SellerServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SellerService.
     * @param {SellerServiceDeleteArgs} args - Arguments to delete one SellerService.
     * @example
     * // Delete one SellerService
     * const SellerService = await prisma.sellerService.delete({
     *   where: {
     *     // ... filter to delete one SellerService
     *   }
     * })
     * 
     */
    delete<T extends SellerServiceDeleteArgs>(args: SelectSubset<T, SellerServiceDeleteArgs<ExtArgs>>): Prisma__SellerServiceClient<$Result.GetResult<Prisma.$SellerServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SellerService.
     * @param {SellerServiceUpdateArgs} args - Arguments to update one SellerService.
     * @example
     * // Update one SellerService
     * const sellerService = await prisma.sellerService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellerServiceUpdateArgs>(args: SelectSubset<T, SellerServiceUpdateArgs<ExtArgs>>): Prisma__SellerServiceClient<$Result.GetResult<Prisma.$SellerServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SellerServices.
     * @param {SellerServiceDeleteManyArgs} args - Arguments to filter SellerServices to delete.
     * @example
     * // Delete a few SellerServices
     * const { count } = await prisma.sellerService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellerServiceDeleteManyArgs>(args?: SelectSubset<T, SellerServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellerServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellerServices
     * const sellerService = await prisma.sellerService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellerServiceUpdateManyArgs>(args: SelectSubset<T, SellerServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellerServices and returns the data updated in the database.
     * @param {SellerServiceUpdateManyAndReturnArgs} args - Arguments to update many SellerServices.
     * @example
     * // Update many SellerServices
     * const sellerService = await prisma.sellerService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SellerServices and only return the `id`
     * const sellerServiceWithIdOnly = await prisma.sellerService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SellerServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, SellerServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SellerService.
     * @param {SellerServiceUpsertArgs} args - Arguments to update or create a SellerService.
     * @example
     * // Update or create a SellerService
     * const sellerService = await prisma.sellerService.upsert({
     *   create: {
     *     // ... data to create a SellerService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellerService we want to update
     *   }
     * })
     */
    upsert<T extends SellerServiceUpsertArgs>(args: SelectSubset<T, SellerServiceUpsertArgs<ExtArgs>>): Prisma__SellerServiceClient<$Result.GetResult<Prisma.$SellerServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SellerServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerServiceCountArgs} args - Arguments to filter SellerServices to count.
     * @example
     * // Count the number of SellerServices
     * const count = await prisma.sellerService.count({
     *   where: {
     *     // ... the filter for the SellerServices we want to count
     *   }
     * })
    **/
    count<T extends SellerServiceCountArgs>(
      args?: Subset<T, SellerServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellerServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellerService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellerServiceAggregateArgs>(args: Subset<T, SellerServiceAggregateArgs>): Prisma.PrismaPromise<GetSellerServiceAggregateType<T>>

    /**
     * Group by SellerService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellerServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellerServiceGroupByArgs['orderBy'] }
        : { orderBy?: SellerServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellerServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellerServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellerService model
   */
  readonly fields: SellerServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellerService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellerServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orders<T extends SellerService$ordersArgs<ExtArgs> = {}>(args?: Subset<T, SellerService$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellerService model
   */
  interface SellerServiceFieldRefs {
    readonly id: FieldRef<"SellerService", 'String'>
    readonly sellerId: FieldRef<"SellerService", 'String'>
    readonly title: FieldRef<"SellerService", 'String'>
    readonly description: FieldRef<"SellerService", 'String'>
    readonly price: FieldRef<"SellerService", 'Decimal'>
    readonly currency: FieldRef<"SellerService", 'String'>
    readonly category: FieldRef<"SellerService", 'String'>
    readonly deliveryTime: FieldRef<"SellerService", 'Int'>
    readonly active: FieldRef<"SellerService", 'Boolean'>
    readonly createdAt: FieldRef<"SellerService", 'DateTime'>
    readonly updatedAt: FieldRef<"SellerService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SellerService findUnique
   */
  export type SellerServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerService
     */
    select?: SellerServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerService
     */
    omit?: SellerServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerServiceInclude<ExtArgs> | null
    /**
     * Filter, which SellerService to fetch.
     */
    where: SellerServiceWhereUniqueInput
  }

  /**
   * SellerService findUniqueOrThrow
   */
  export type SellerServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerService
     */
    select?: SellerServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerService
     */
    omit?: SellerServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerServiceInclude<ExtArgs> | null
    /**
     * Filter, which SellerService to fetch.
     */
    where: SellerServiceWhereUniqueInput
  }

  /**
   * SellerService findFirst
   */
  export type SellerServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerService
     */
    select?: SellerServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerService
     */
    omit?: SellerServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerServiceInclude<ExtArgs> | null
    /**
     * Filter, which SellerService to fetch.
     */
    where?: SellerServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerServices to fetch.
     */
    orderBy?: SellerServiceOrderByWithRelationInput | SellerServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellerServices.
     */
    cursor?: SellerServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellerServices.
     */
    distinct?: SellerServiceScalarFieldEnum | SellerServiceScalarFieldEnum[]
  }

  /**
   * SellerService findFirstOrThrow
   */
  export type SellerServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerService
     */
    select?: SellerServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerService
     */
    omit?: SellerServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerServiceInclude<ExtArgs> | null
    /**
     * Filter, which SellerService to fetch.
     */
    where?: SellerServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerServices to fetch.
     */
    orderBy?: SellerServiceOrderByWithRelationInput | SellerServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellerServices.
     */
    cursor?: SellerServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellerServices.
     */
    distinct?: SellerServiceScalarFieldEnum | SellerServiceScalarFieldEnum[]
  }

  /**
   * SellerService findMany
   */
  export type SellerServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerService
     */
    select?: SellerServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerService
     */
    omit?: SellerServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerServiceInclude<ExtArgs> | null
    /**
     * Filter, which SellerServices to fetch.
     */
    where?: SellerServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerServices to fetch.
     */
    orderBy?: SellerServiceOrderByWithRelationInput | SellerServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellerServices.
     */
    cursor?: SellerServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerServices.
     */
    skip?: number
    distinct?: SellerServiceScalarFieldEnum | SellerServiceScalarFieldEnum[]
  }

  /**
   * SellerService create
   */
  export type SellerServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerService
     */
    select?: SellerServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerService
     */
    omit?: SellerServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a SellerService.
     */
    data: XOR<SellerServiceCreateInput, SellerServiceUncheckedCreateInput>
  }

  /**
   * SellerService createMany
   */
  export type SellerServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellerServices.
     */
    data: SellerServiceCreateManyInput | SellerServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellerService createManyAndReturn
   */
  export type SellerServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerService
     */
    select?: SellerServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SellerService
     */
    omit?: SellerServiceOmit<ExtArgs> | null
    /**
     * The data used to create many SellerServices.
     */
    data: SellerServiceCreateManyInput | SellerServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SellerService update
   */
  export type SellerServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerService
     */
    select?: SellerServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerService
     */
    omit?: SellerServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a SellerService.
     */
    data: XOR<SellerServiceUpdateInput, SellerServiceUncheckedUpdateInput>
    /**
     * Choose, which SellerService to update.
     */
    where: SellerServiceWhereUniqueInput
  }

  /**
   * SellerService updateMany
   */
  export type SellerServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellerServices.
     */
    data: XOR<SellerServiceUpdateManyMutationInput, SellerServiceUncheckedUpdateManyInput>
    /**
     * Filter which SellerServices to update
     */
    where?: SellerServiceWhereInput
    /**
     * Limit how many SellerServices to update.
     */
    limit?: number
  }

  /**
   * SellerService updateManyAndReturn
   */
  export type SellerServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerService
     */
    select?: SellerServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SellerService
     */
    omit?: SellerServiceOmit<ExtArgs> | null
    /**
     * The data used to update SellerServices.
     */
    data: XOR<SellerServiceUpdateManyMutationInput, SellerServiceUncheckedUpdateManyInput>
    /**
     * Filter which SellerServices to update
     */
    where?: SellerServiceWhereInput
    /**
     * Limit how many SellerServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SellerService upsert
   */
  export type SellerServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerService
     */
    select?: SellerServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerService
     */
    omit?: SellerServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the SellerService to update in case it exists.
     */
    where: SellerServiceWhereUniqueInput
    /**
     * In case the SellerService found by the `where` argument doesn't exist, create a new SellerService with this data.
     */
    create: XOR<SellerServiceCreateInput, SellerServiceUncheckedCreateInput>
    /**
     * In case the SellerService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellerServiceUpdateInput, SellerServiceUncheckedUpdateInput>
  }

  /**
   * SellerService delete
   */
  export type SellerServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerService
     */
    select?: SellerServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerService
     */
    omit?: SellerServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerServiceInclude<ExtArgs> | null
    /**
     * Filter which SellerService to delete.
     */
    where: SellerServiceWhereUniqueInput
  }

  /**
   * SellerService deleteMany
   */
  export type SellerServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellerServices to delete
     */
    where?: SellerServiceWhereInput
    /**
     * Limit how many SellerServices to delete.
     */
    limit?: number
  }

  /**
   * SellerService.orders
   */
  export type SellerService$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    where?: ServiceOrderWhereInput
    orderBy?: ServiceOrderOrderByWithRelationInput | ServiceOrderOrderByWithRelationInput[]
    cursor?: ServiceOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceOrderScalarFieldEnum | ServiceOrderScalarFieldEnum[]
  }

  /**
   * SellerService without action
   */
  export type SellerServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerService
     */
    select?: SellerServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerService
     */
    omit?: SellerServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerServiceInclude<ExtArgs> | null
  }


  /**
   * Model ServiceOrder
   */

  export type AggregateServiceOrder = {
    _count: ServiceOrderCountAggregateOutputType | null
    _avg: ServiceOrderAvgAggregateOutputType | null
    _sum: ServiceOrderSumAggregateOutputType | null
    _min: ServiceOrderMinAggregateOutputType | null
    _max: ServiceOrderMaxAggregateOutputType | null
  }

  export type ServiceOrderAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type ServiceOrderSumAggregateOutputType = {
    price: Decimal | null
  }

  export type ServiceOrderMinAggregateOutputType = {
    id: string | null
    serviceId: string | null
    buyerId: string | null
    sellerId: string | null
    message: string | null
    price: Decimal | null
    currency: string | null
    status: $Enums.ServiceOrderStatus | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceOrderMaxAggregateOutputType = {
    id: string | null
    serviceId: string | null
    buyerId: string | null
    sellerId: string | null
    message: string | null
    price: Decimal | null
    currency: string | null
    status: $Enums.ServiceOrderStatus | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceOrderCountAggregateOutputType = {
    id: number
    serviceId: number
    buyerId: number
    sellerId: number
    message: number
    price: number
    currency: number
    status: number
    note: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceOrderAvgAggregateInputType = {
    price?: true
  }

  export type ServiceOrderSumAggregateInputType = {
    price?: true
  }

  export type ServiceOrderMinAggregateInputType = {
    id?: true
    serviceId?: true
    buyerId?: true
    sellerId?: true
    message?: true
    price?: true
    currency?: true
    status?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceOrderMaxAggregateInputType = {
    id?: true
    serviceId?: true
    buyerId?: true
    sellerId?: true
    message?: true
    price?: true
    currency?: true
    status?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceOrderCountAggregateInputType = {
    id?: true
    serviceId?: true
    buyerId?: true
    sellerId?: true
    message?: true
    price?: true
    currency?: true
    status?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceOrder to aggregate.
     */
    where?: ServiceOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceOrders to fetch.
     */
    orderBy?: ServiceOrderOrderByWithRelationInput | ServiceOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceOrders
    **/
    _count?: true | ServiceOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceOrderMaxAggregateInputType
  }

  export type GetServiceOrderAggregateType<T extends ServiceOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceOrder[P]>
      : GetScalarType<T[P], AggregateServiceOrder[P]>
  }




  export type ServiceOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceOrderWhereInput
    orderBy?: ServiceOrderOrderByWithAggregationInput | ServiceOrderOrderByWithAggregationInput[]
    by: ServiceOrderScalarFieldEnum[] | ServiceOrderScalarFieldEnum
    having?: ServiceOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceOrderCountAggregateInputType | true
    _avg?: ServiceOrderAvgAggregateInputType
    _sum?: ServiceOrderSumAggregateInputType
    _min?: ServiceOrderMinAggregateInputType
    _max?: ServiceOrderMaxAggregateInputType
  }

  export type ServiceOrderGroupByOutputType = {
    id: string
    serviceId: string
    buyerId: string
    sellerId: string
    message: string
    price: Decimal
    currency: string
    status: $Enums.ServiceOrderStatus
    note: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceOrderCountAggregateOutputType | null
    _avg: ServiceOrderAvgAggregateOutputType | null
    _sum: ServiceOrderSumAggregateOutputType | null
    _min: ServiceOrderMinAggregateOutputType | null
    _max: ServiceOrderMaxAggregateOutputType | null
  }

  type GetServiceOrderGroupByPayload<T extends ServiceOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceOrderGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceOrderGroupByOutputType[P]>
        }
      >
    >


  export type ServiceOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    message?: boolean
    price?: boolean
    currency?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | SellerServiceDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceOrder"]>

  export type ServiceOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    message?: boolean
    price?: boolean
    currency?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | SellerServiceDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceOrder"]>

  export type ServiceOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    message?: boolean
    price?: boolean
    currency?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | SellerServiceDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceOrder"]>

  export type ServiceOrderSelectScalar = {
    id?: boolean
    serviceId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    message?: boolean
    price?: boolean
    currency?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceId" | "buyerId" | "sellerId" | "message" | "price" | "currency" | "status" | "note" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceOrder"]>
  export type ServiceOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | SellerServiceDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ServiceOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | SellerServiceDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ServiceOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | SellerServiceDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ServiceOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceOrder"
    objects: {
      service: Prisma.$SellerServicePayload<ExtArgs>
      buyer: Prisma.$UserPayload<ExtArgs>
      seller: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceId: string
      buyerId: string
      sellerId: string
      message: string
      price: Prisma.Decimal
      currency: string
      status: $Enums.ServiceOrderStatus
      note: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceOrder"]>
    composites: {}
  }

  type ServiceOrderGetPayload<S extends boolean | null | undefined | ServiceOrderDefaultArgs> = $Result.GetResult<Prisma.$ServiceOrderPayload, S>

  type ServiceOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceOrderCountAggregateInputType | true
    }

  export interface ServiceOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceOrder'], meta: { name: 'ServiceOrder' } }
    /**
     * Find zero or one ServiceOrder that matches the filter.
     * @param {ServiceOrderFindUniqueArgs} args - Arguments to find a ServiceOrder
     * @example
     * // Get one ServiceOrder
     * const serviceOrder = await prisma.serviceOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceOrderFindUniqueArgs>(args: SelectSubset<T, ServiceOrderFindUniqueArgs<ExtArgs>>): Prisma__ServiceOrderClient<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceOrderFindUniqueOrThrowArgs} args - Arguments to find a ServiceOrder
     * @example
     * // Get one ServiceOrder
     * const serviceOrder = await prisma.serviceOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceOrderClient<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOrderFindFirstArgs} args - Arguments to find a ServiceOrder
     * @example
     * // Get one ServiceOrder
     * const serviceOrder = await prisma.serviceOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceOrderFindFirstArgs>(args?: SelectSubset<T, ServiceOrderFindFirstArgs<ExtArgs>>): Prisma__ServiceOrderClient<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOrderFindFirstOrThrowArgs} args - Arguments to find a ServiceOrder
     * @example
     * // Get one ServiceOrder
     * const serviceOrder = await prisma.serviceOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceOrderClient<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceOrders
     * const serviceOrders = await prisma.serviceOrder.findMany()
     * 
     * // Get first 10 ServiceOrders
     * const serviceOrders = await prisma.serviceOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceOrderWithIdOnly = await prisma.serviceOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceOrderFindManyArgs>(args?: SelectSubset<T, ServiceOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceOrder.
     * @param {ServiceOrderCreateArgs} args - Arguments to create a ServiceOrder.
     * @example
     * // Create one ServiceOrder
     * const ServiceOrder = await prisma.serviceOrder.create({
     *   data: {
     *     // ... data to create a ServiceOrder
     *   }
     * })
     * 
     */
    create<T extends ServiceOrderCreateArgs>(args: SelectSubset<T, ServiceOrderCreateArgs<ExtArgs>>): Prisma__ServiceOrderClient<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceOrders.
     * @param {ServiceOrderCreateManyArgs} args - Arguments to create many ServiceOrders.
     * @example
     * // Create many ServiceOrders
     * const serviceOrder = await prisma.serviceOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceOrderCreateManyArgs>(args?: SelectSubset<T, ServiceOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceOrders and returns the data saved in the database.
     * @param {ServiceOrderCreateManyAndReturnArgs} args - Arguments to create many ServiceOrders.
     * @example
     * // Create many ServiceOrders
     * const serviceOrder = await prisma.serviceOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceOrders and only return the `id`
     * const serviceOrderWithIdOnly = await prisma.serviceOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceOrder.
     * @param {ServiceOrderDeleteArgs} args - Arguments to delete one ServiceOrder.
     * @example
     * // Delete one ServiceOrder
     * const ServiceOrder = await prisma.serviceOrder.delete({
     *   where: {
     *     // ... filter to delete one ServiceOrder
     *   }
     * })
     * 
     */
    delete<T extends ServiceOrderDeleteArgs>(args: SelectSubset<T, ServiceOrderDeleteArgs<ExtArgs>>): Prisma__ServiceOrderClient<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceOrder.
     * @param {ServiceOrderUpdateArgs} args - Arguments to update one ServiceOrder.
     * @example
     * // Update one ServiceOrder
     * const serviceOrder = await prisma.serviceOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceOrderUpdateArgs>(args: SelectSubset<T, ServiceOrderUpdateArgs<ExtArgs>>): Prisma__ServiceOrderClient<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceOrders.
     * @param {ServiceOrderDeleteManyArgs} args - Arguments to filter ServiceOrders to delete.
     * @example
     * // Delete a few ServiceOrders
     * const { count } = await prisma.serviceOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceOrderDeleteManyArgs>(args?: SelectSubset<T, ServiceOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceOrders
     * const serviceOrder = await prisma.serviceOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceOrderUpdateManyArgs>(args: SelectSubset<T, ServiceOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceOrders and returns the data updated in the database.
     * @param {ServiceOrderUpdateManyAndReturnArgs} args - Arguments to update many ServiceOrders.
     * @example
     * // Update many ServiceOrders
     * const serviceOrder = await prisma.serviceOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceOrders and only return the `id`
     * const serviceOrderWithIdOnly = await prisma.serviceOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceOrder.
     * @param {ServiceOrderUpsertArgs} args - Arguments to update or create a ServiceOrder.
     * @example
     * // Update or create a ServiceOrder
     * const serviceOrder = await prisma.serviceOrder.upsert({
     *   create: {
     *     // ... data to create a ServiceOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceOrder we want to update
     *   }
     * })
     */
    upsert<T extends ServiceOrderUpsertArgs>(args: SelectSubset<T, ServiceOrderUpsertArgs<ExtArgs>>): Prisma__ServiceOrderClient<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOrderCountArgs} args - Arguments to filter ServiceOrders to count.
     * @example
     * // Count the number of ServiceOrders
     * const count = await prisma.serviceOrder.count({
     *   where: {
     *     // ... the filter for the ServiceOrders we want to count
     *   }
     * })
    **/
    count<T extends ServiceOrderCountArgs>(
      args?: Subset<T, ServiceOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceOrderAggregateArgs>(args: Subset<T, ServiceOrderAggregateArgs>): Prisma.PrismaPromise<GetServiceOrderAggregateType<T>>

    /**
     * Group by ServiceOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceOrderGroupByArgs['orderBy'] }
        : { orderBy?: ServiceOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceOrder model
   */
  readonly fields: ServiceOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends SellerServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SellerServiceDefaultArgs<ExtArgs>>): Prisma__SellerServiceClient<$Result.GetResult<Prisma.$SellerServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    buyer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceOrder model
   */
  interface ServiceOrderFieldRefs {
    readonly id: FieldRef<"ServiceOrder", 'String'>
    readonly serviceId: FieldRef<"ServiceOrder", 'String'>
    readonly buyerId: FieldRef<"ServiceOrder", 'String'>
    readonly sellerId: FieldRef<"ServiceOrder", 'String'>
    readonly message: FieldRef<"ServiceOrder", 'String'>
    readonly price: FieldRef<"ServiceOrder", 'Decimal'>
    readonly currency: FieldRef<"ServiceOrder", 'String'>
    readonly status: FieldRef<"ServiceOrder", 'ServiceOrderStatus'>
    readonly note: FieldRef<"ServiceOrder", 'String'>
    readonly createdAt: FieldRef<"ServiceOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceOrder findUnique
   */
  export type ServiceOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceOrder to fetch.
     */
    where: ServiceOrderWhereUniqueInput
  }

  /**
   * ServiceOrder findUniqueOrThrow
   */
  export type ServiceOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceOrder to fetch.
     */
    where: ServiceOrderWhereUniqueInput
  }

  /**
   * ServiceOrder findFirst
   */
  export type ServiceOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceOrder to fetch.
     */
    where?: ServiceOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceOrders to fetch.
     */
    orderBy?: ServiceOrderOrderByWithRelationInput | ServiceOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceOrders.
     */
    cursor?: ServiceOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceOrders.
     */
    distinct?: ServiceOrderScalarFieldEnum | ServiceOrderScalarFieldEnum[]
  }

  /**
   * ServiceOrder findFirstOrThrow
   */
  export type ServiceOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceOrder to fetch.
     */
    where?: ServiceOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceOrders to fetch.
     */
    orderBy?: ServiceOrderOrderByWithRelationInput | ServiceOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceOrders.
     */
    cursor?: ServiceOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceOrders.
     */
    distinct?: ServiceOrderScalarFieldEnum | ServiceOrderScalarFieldEnum[]
  }

  /**
   * ServiceOrder findMany
   */
  export type ServiceOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceOrders to fetch.
     */
    where?: ServiceOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceOrders to fetch.
     */
    orderBy?: ServiceOrderOrderByWithRelationInput | ServiceOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceOrders.
     */
    cursor?: ServiceOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceOrders.
     */
    skip?: number
    distinct?: ServiceOrderScalarFieldEnum | ServiceOrderScalarFieldEnum[]
  }

  /**
   * ServiceOrder create
   */
  export type ServiceOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceOrder.
     */
    data: XOR<ServiceOrderCreateInput, ServiceOrderUncheckedCreateInput>
  }

  /**
   * ServiceOrder createMany
   */
  export type ServiceOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceOrders.
     */
    data: ServiceOrderCreateManyInput | ServiceOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceOrder createManyAndReturn
   */
  export type ServiceOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceOrders.
     */
    data: ServiceOrderCreateManyInput | ServiceOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceOrder update
   */
  export type ServiceOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceOrder.
     */
    data: XOR<ServiceOrderUpdateInput, ServiceOrderUncheckedUpdateInput>
    /**
     * Choose, which ServiceOrder to update.
     */
    where: ServiceOrderWhereUniqueInput
  }

  /**
   * ServiceOrder updateMany
   */
  export type ServiceOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceOrders.
     */
    data: XOR<ServiceOrderUpdateManyMutationInput, ServiceOrderUncheckedUpdateManyInput>
    /**
     * Filter which ServiceOrders to update
     */
    where?: ServiceOrderWhereInput
    /**
     * Limit how many ServiceOrders to update.
     */
    limit?: number
  }

  /**
   * ServiceOrder updateManyAndReturn
   */
  export type ServiceOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * The data used to update ServiceOrders.
     */
    data: XOR<ServiceOrderUpdateManyMutationInput, ServiceOrderUncheckedUpdateManyInput>
    /**
     * Filter which ServiceOrders to update
     */
    where?: ServiceOrderWhereInput
    /**
     * Limit how many ServiceOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceOrder upsert
   */
  export type ServiceOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceOrder to update in case it exists.
     */
    where: ServiceOrderWhereUniqueInput
    /**
     * In case the ServiceOrder found by the `where` argument doesn't exist, create a new ServiceOrder with this data.
     */
    create: XOR<ServiceOrderCreateInput, ServiceOrderUncheckedCreateInput>
    /**
     * In case the ServiceOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceOrderUpdateInput, ServiceOrderUncheckedUpdateInput>
  }

  /**
   * ServiceOrder delete
   */
  export type ServiceOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    /**
     * Filter which ServiceOrder to delete.
     */
    where: ServiceOrderWhereUniqueInput
  }

  /**
   * ServiceOrder deleteMany
   */
  export type ServiceOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceOrders to delete
     */
    where?: ServiceOrderWhereInput
    /**
     * Limit how many ServiceOrders to delete.
     */
    limit?: number
  }

  /**
   * ServiceOrder without action
   */
  export type ServiceOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionPlan
   */

  export type AggregateSubscriptionPlan = {
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  export type SubscriptionPlanAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type SubscriptionPlanSumAggregateOutputType = {
    price: Decimal | null
  }

  export type SubscriptionPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    currency: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    currency: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPlanCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    currency: number
    features: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionPlanAvgAggregateInputType = {
    price?: true
  }

  export type SubscriptionPlanSumAggregateInputType = {
    price?: true
  }

  export type SubscriptionPlanMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPlanMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPlanCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    features?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlan to aggregate.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionPlans
    **/
    _count?: true | SubscriptionPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type GetSubscriptionPlanAggregateType<T extends SubscriptionPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
      : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
  }




  export type SubscriptionPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPlanWhereInput
    orderBy?: SubscriptionPlanOrderByWithAggregationInput | SubscriptionPlanOrderByWithAggregationInput[]
    by: SubscriptionPlanScalarFieldEnum[] | SubscriptionPlanScalarFieldEnum
    having?: SubscriptionPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionPlanCountAggregateInputType | true
    _avg?: SubscriptionPlanAvgAggregateInputType
    _sum?: SubscriptionPlanSumAggregateInputType
    _min?: SubscriptionPlanMinAggregateInputType
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type SubscriptionPlanGroupByOutputType = {
    id: string
    name: string
    description: string
    price: Decimal
    currency: string
    features: string[]
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  type GetSubscriptionPlanGroupByPayload<T extends SubscriptionPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    features?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    features?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    features?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    features?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "currency" | "features" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["subscriptionPlan"]>
  export type SubscriptionPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SubscriptionPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SubscriptionPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionPlan"
    objects: {
      subscriptions: Prisma.$UserSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      price: Prisma.Decimal
      currency: string
      features: string[]
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriptionPlan"]>
    composites: {}
  }

  type SubscriptionPlanGetPayload<S extends boolean | null | undefined | SubscriptionPlanDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPlanPayload, S>

  type SubscriptionPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionPlanCountAggregateInputType | true
    }

  export interface SubscriptionPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionPlan'], meta: { name: 'SubscriptionPlan' } }
    /**
     * Find zero or one SubscriptionPlan that matches the filter.
     * @param {SubscriptionPlanFindUniqueArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionPlanFindUniqueArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubscriptionPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionPlanFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionPlanFindFirstArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubscriptionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
     * 
     * // Get first 10 SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionPlanFindManyArgs>(args?: SelectSubset<T, SubscriptionPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubscriptionPlan.
     * @param {SubscriptionPlanCreateArgs} args - Arguments to create a SubscriptionPlan.
     * @example
     * // Create one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.create({
     *   data: {
     *     // ... data to create a SubscriptionPlan
     *   }
     * })
     * 
     */
    create<T extends SubscriptionPlanCreateArgs>(args: SelectSubset<T, SubscriptionPlanCreateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubscriptionPlans.
     * @param {SubscriptionPlanCreateManyArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionPlanCreateManyArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionPlans and returns the data saved in the database.
     * @param {SubscriptionPlanCreateManyAndReturnArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubscriptionPlan.
     * @param {SubscriptionPlanDeleteArgs} args - Arguments to delete one SubscriptionPlan.
     * @example
     * // Delete one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionPlan
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionPlanDeleteArgs>(args: SelectSubset<T, SubscriptionPlanDeleteArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubscriptionPlan.
     * @param {SubscriptionPlanUpdateArgs} args - Arguments to update one SubscriptionPlan.
     * @example
     * // Update one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionPlanUpdateArgs>(args: SelectSubset<T, SubscriptionPlanUpdateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubscriptionPlans.
     * @param {SubscriptionPlanDeleteManyArgs} args - Arguments to filter SubscriptionPlans to delete.
     * @example
     * // Delete a few SubscriptionPlans
     * const { count } = await prisma.subscriptionPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionPlanDeleteManyArgs>(args?: SelectSubset<T, SubscriptionPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionPlanUpdateManyArgs>(args: SelectSubset<T, SubscriptionPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans and returns the data updated in the database.
     * @param {SubscriptionPlanUpdateManyAndReturnArgs} args - Arguments to update many SubscriptionPlans.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubscriptionPlan.
     * @param {SubscriptionPlanUpsertArgs} args - Arguments to update or create a SubscriptionPlan.
     * @example
     * // Update or create a SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.upsert({
     *   create: {
     *     // ... data to create a SubscriptionPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionPlan we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionPlanUpsertArgs>(args: SelectSubset<T, SubscriptionPlanUpsertArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanCountArgs} args - Arguments to filter SubscriptionPlans to count.
     * @example
     * // Count the number of SubscriptionPlans
     * const count = await prisma.subscriptionPlan.count({
     *   where: {
     *     // ... the filter for the SubscriptionPlans we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionPlanCountArgs>(
      args?: Subset<T, SubscriptionPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionPlanAggregateArgs>(args: Subset<T, SubscriptionPlanAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionPlanAggregateType<T>>

    /**
     * Group by SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionPlanGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionPlan model
   */
  readonly fields: SubscriptionPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends SubscriptionPlan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionPlan model
   */
  interface SubscriptionPlanFieldRefs {
    readonly id: FieldRef<"SubscriptionPlan", 'String'>
    readonly name: FieldRef<"SubscriptionPlan", 'String'>
    readonly description: FieldRef<"SubscriptionPlan", 'String'>
    readonly price: FieldRef<"SubscriptionPlan", 'Decimal'>
    readonly currency: FieldRef<"SubscriptionPlan", 'String'>
    readonly features: FieldRef<"SubscriptionPlan", 'String[]'>
    readonly active: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly createdAt: FieldRef<"SubscriptionPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"SubscriptionPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionPlan findUnique
   */
  export type SubscriptionPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findUniqueOrThrow
   */
  export type SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findFirst
   */
  export type SubscriptionPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findFirstOrThrow
   */
  export type SubscriptionPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findMany
   */
  export type SubscriptionPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlans to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan create
   */
  export type SubscriptionPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
  }

  /**
   * SubscriptionPlan createMany
   */
  export type SubscriptionPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan createManyAndReturn
   */
  export type SubscriptionPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan update
   */
  export type SubscriptionPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionPlan to update.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan updateMany
   */
  export type SubscriptionPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput
    /**
     * Limit how many SubscriptionPlans to update.
     */
    limit?: number
  }

  /**
   * SubscriptionPlan updateManyAndReturn
   */
  export type SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput
    /**
     * Limit how many SubscriptionPlans to update.
     */
    limit?: number
  }

  /**
   * SubscriptionPlan upsert
   */
  export type SubscriptionPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionPlan to update in case it exists.
     */
    where: SubscriptionPlanWhereUniqueInput
    /**
     * In case the SubscriptionPlan found by the `where` argument doesn't exist, create a new SubscriptionPlan with this data.
     */
    create: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
    /**
     * In case the SubscriptionPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
  }

  /**
   * SubscriptionPlan delete
   */
  export type SubscriptionPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionPlan to delete.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan deleteMany
   */
  export type SubscriptionPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlans to delete
     */
    where?: SubscriptionPlanWhereInput
    /**
     * Limit how many SubscriptionPlans to delete.
     */
    limit?: number
  }

  /**
   * SubscriptionPlan.subscriptions
   */
  export type SubscriptionPlan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    where?: UserSubscriptionWhereInput
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    cursor?: UserSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan without action
   */
  export type SubscriptionPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
  }


  /**
   * Model UserSubscription
   */

  export type AggregateUserSubscription = {
    _count: UserSubscriptionCountAggregateOutputType | null
    _avg: UserSubscriptionAvgAggregateOutputType | null
    _sum: UserSubscriptionSumAggregateOutputType | null
    _min: UserSubscriptionMinAggregateOutputType | null
    _max: UserSubscriptionMaxAggregateOutputType | null
  }

  export type UserSubscriptionAvgAggregateOutputType = {
    planPrice: Decimal | null
  }

  export type UserSubscriptionSumAggregateOutputType = {
    planPrice: Decimal | null
  }

  export type UserSubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    planId: string | null
    planPrice: Decimal | null
    status: $Enums.SubscriptionStatus | null
    startDate: Date | null
    endDate: Date | null
    autoRenew: boolean | null
    paymentMethod: string | null
    cancelledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    planId: string | null
    planPrice: Decimal | null
    status: $Enums.SubscriptionStatus | null
    startDate: Date | null
    endDate: Date | null
    autoRenew: boolean | null
    paymentMethod: string | null
    cancelledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    planId: number
    planPrice: number
    status: number
    startDate: number
    endDate: number
    autoRenew: number
    paymentMethod: number
    cancelledAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSubscriptionAvgAggregateInputType = {
    planPrice?: true
  }

  export type UserSubscriptionSumAggregateInputType = {
    planPrice?: true
  }

  export type UserSubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    planPrice?: true
    status?: true
    startDate?: true
    endDate?: true
    autoRenew?: true
    paymentMethod?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    planPrice?: true
    status?: true
    startDate?: true
    endDate?: true
    autoRenew?: true
    paymentMethod?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    planPrice?: true
    status?: true
    startDate?: true
    endDate?: true
    autoRenew?: true
    paymentMethod?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubscription to aggregate.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSubscriptions
    **/
    _count?: true | UserSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSubscriptionMaxAggregateInputType
  }

  export type GetUserSubscriptionAggregateType<T extends UserSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSubscription[P]>
      : GetScalarType<T[P], AggregateUserSubscription[P]>
  }




  export type UserSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubscriptionWhereInput
    orderBy?: UserSubscriptionOrderByWithAggregationInput | UserSubscriptionOrderByWithAggregationInput[]
    by: UserSubscriptionScalarFieldEnum[] | UserSubscriptionScalarFieldEnum
    having?: UserSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSubscriptionCountAggregateInputType | true
    _avg?: UserSubscriptionAvgAggregateInputType
    _sum?: UserSubscriptionSumAggregateInputType
    _min?: UserSubscriptionMinAggregateInputType
    _max?: UserSubscriptionMaxAggregateInputType
  }

  export type UserSubscriptionGroupByOutputType = {
    id: string
    userId: string
    planId: string
    planPrice: Decimal
    status: $Enums.SubscriptionStatus
    startDate: Date
    endDate: Date
    autoRenew: boolean
    paymentMethod: string
    cancelledAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserSubscriptionCountAggregateOutputType | null
    _avg: UserSubscriptionAvgAggregateOutputType | null
    _sum: UserSubscriptionSumAggregateOutputType | null
    _min: UserSubscriptionMinAggregateOutputType | null
    _max: UserSubscriptionMaxAggregateOutputType | null
  }

  type GetUserSubscriptionGroupByPayload<T extends UserSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type UserSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    planPrice?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    planPrice?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    planPrice?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    planId?: boolean
    planPrice?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "planId" | "planPrice" | "status" | "startDate" | "endDate" | "autoRenew" | "paymentMethod" | "cancelledAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userSubscription"]>
  export type UserSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }
  export type UserSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }
  export type UserSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }

  export type $UserSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSubscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      plan: Prisma.$SubscriptionPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      planId: string
      planPrice: Prisma.Decimal
      status: $Enums.SubscriptionStatus
      startDate: Date
      endDate: Date
      autoRenew: boolean
      paymentMethod: string
      cancelledAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSubscription"]>
    composites: {}
  }

  type UserSubscriptionGetPayload<S extends boolean | null | undefined | UserSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$UserSubscriptionPayload, S>

  type UserSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSubscriptionCountAggregateInputType | true
    }

  export interface UserSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSubscription'], meta: { name: 'UserSubscription' } }
    /**
     * Find zero or one UserSubscription that matches the filter.
     * @param {UserSubscriptionFindUniqueArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSubscriptionFindUniqueArgs>(args: SelectSubset<T, UserSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindFirstArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSubscriptionFindFirstArgs>(args?: SelectSubset<T, UserSubscriptionFindFirstArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindFirstOrThrowArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSubscriptions
     * const userSubscriptions = await prisma.userSubscription.findMany()
     * 
     * // Get first 10 UserSubscriptions
     * const userSubscriptions = await prisma.userSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSubscriptionFindManyArgs>(args?: SelectSubset<T, UserSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSubscription.
     * @param {UserSubscriptionCreateArgs} args - Arguments to create a UserSubscription.
     * @example
     * // Create one UserSubscription
     * const UserSubscription = await prisma.userSubscription.create({
     *   data: {
     *     // ... data to create a UserSubscription
     *   }
     * })
     * 
     */
    create<T extends UserSubscriptionCreateArgs>(args: SelectSubset<T, UserSubscriptionCreateArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSubscriptions.
     * @param {UserSubscriptionCreateManyArgs} args - Arguments to create many UserSubscriptions.
     * @example
     * // Create many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSubscriptionCreateManyArgs>(args?: SelectSubset<T, UserSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSubscriptions and returns the data saved in the database.
     * @param {UserSubscriptionCreateManyAndReturnArgs} args - Arguments to create many UserSubscriptions.
     * @example
     * // Create many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSubscriptions and only return the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSubscription.
     * @param {UserSubscriptionDeleteArgs} args - Arguments to delete one UserSubscription.
     * @example
     * // Delete one UserSubscription
     * const UserSubscription = await prisma.userSubscription.delete({
     *   where: {
     *     // ... filter to delete one UserSubscription
     *   }
     * })
     * 
     */
    delete<T extends UserSubscriptionDeleteArgs>(args: SelectSubset<T, UserSubscriptionDeleteArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSubscription.
     * @param {UserSubscriptionUpdateArgs} args - Arguments to update one UserSubscription.
     * @example
     * // Update one UserSubscription
     * const userSubscription = await prisma.userSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSubscriptionUpdateArgs>(args: SelectSubset<T, UserSubscriptionUpdateArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSubscriptions.
     * @param {UserSubscriptionDeleteManyArgs} args - Arguments to filter UserSubscriptions to delete.
     * @example
     * // Delete a few UserSubscriptions
     * const { count } = await prisma.userSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSubscriptionDeleteManyArgs>(args?: SelectSubset<T, UserSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSubscriptionUpdateManyArgs>(args: SelectSubset<T, UserSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSubscriptions and returns the data updated in the database.
     * @param {UserSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many UserSubscriptions.
     * @example
     * // Update many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSubscriptions and only return the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSubscription.
     * @param {UserSubscriptionUpsertArgs} args - Arguments to update or create a UserSubscription.
     * @example
     * // Update or create a UserSubscription
     * const userSubscription = await prisma.userSubscription.upsert({
     *   create: {
     *     // ... data to create a UserSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSubscription we want to update
     *   }
     * })
     */
    upsert<T extends UserSubscriptionUpsertArgs>(args: SelectSubset<T, UserSubscriptionUpsertArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionCountArgs} args - Arguments to filter UserSubscriptions to count.
     * @example
     * // Count the number of UserSubscriptions
     * const count = await prisma.userSubscription.count({
     *   where: {
     *     // ... the filter for the UserSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends UserSubscriptionCountArgs>(
      args?: Subset<T, UserSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSubscriptionAggregateArgs>(args: Subset<T, UserSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetUserSubscriptionAggregateType<T>>

    /**
     * Group by UserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: UserSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSubscription model
   */
  readonly fields: UserSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends SubscriptionPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlanDefaultArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSubscription model
   */
  interface UserSubscriptionFieldRefs {
    readonly id: FieldRef<"UserSubscription", 'String'>
    readonly userId: FieldRef<"UserSubscription", 'String'>
    readonly planId: FieldRef<"UserSubscription", 'String'>
    readonly planPrice: FieldRef<"UserSubscription", 'Decimal'>
    readonly status: FieldRef<"UserSubscription", 'SubscriptionStatus'>
    readonly startDate: FieldRef<"UserSubscription", 'DateTime'>
    readonly endDate: FieldRef<"UserSubscription", 'DateTime'>
    readonly autoRenew: FieldRef<"UserSubscription", 'Boolean'>
    readonly paymentMethod: FieldRef<"UserSubscription", 'String'>
    readonly cancelledAt: FieldRef<"UserSubscription", 'DateTime'>
    readonly createdAt: FieldRef<"UserSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSubscription findUnique
   */
  export type UserSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription findUniqueOrThrow
   */
  export type UserSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription findFirst
   */
  export type UserSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubscriptions.
     */
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription findFirstOrThrow
   */
  export type UserSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubscriptions.
     */
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription findMany
   */
  export type UserSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscriptions to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription create
   */
  export type UserSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSubscription.
     */
    data: XOR<UserSubscriptionCreateInput, UserSubscriptionUncheckedCreateInput>
  }

  /**
   * UserSubscription createMany
   */
  export type UserSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSubscriptions.
     */
    data: UserSubscriptionCreateManyInput | UserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSubscription createManyAndReturn
   */
  export type UserSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSubscriptions.
     */
    data: UserSubscriptionCreateManyInput | UserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSubscription update
   */
  export type UserSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSubscription.
     */
    data: XOR<UserSubscriptionUpdateInput, UserSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which UserSubscription to update.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription updateMany
   */
  export type UserSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSubscriptions.
     */
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which UserSubscriptions to update
     */
    where?: UserSubscriptionWhereInput
    /**
     * Limit how many UserSubscriptions to update.
     */
    limit?: number
  }

  /**
   * UserSubscription updateManyAndReturn
   */
  export type UserSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update UserSubscriptions.
     */
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which UserSubscriptions to update
     */
    where?: UserSubscriptionWhereInput
    /**
     * Limit how many UserSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSubscription upsert
   */
  export type UserSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSubscription to update in case it exists.
     */
    where: UserSubscriptionWhereUniqueInput
    /**
     * In case the UserSubscription found by the `where` argument doesn't exist, create a new UserSubscription with this data.
     */
    create: XOR<UserSubscriptionCreateInput, UserSubscriptionUncheckedCreateInput>
    /**
     * In case the UserSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSubscriptionUpdateInput, UserSubscriptionUncheckedUpdateInput>
  }

  /**
   * UserSubscription delete
   */
  export type UserSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which UserSubscription to delete.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription deleteMany
   */
  export type UserSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubscriptions to delete
     */
    where?: UserSubscriptionWhereInput
    /**
     * Limit how many UserSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * UserSubscription without action
   */
  export type UserSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model ApiPartner
   */

  export type AggregateApiPartner = {
    _count: ApiPartnerCountAggregateOutputType | null
    _min: ApiPartnerMinAggregateOutputType | null
    _max: ApiPartnerMaxAggregateOutputType | null
  }

  export type ApiPartnerMinAggregateOutputType = {
    id: string | null
    companyName: string | null
    contactEmail: string | null
    apiKeyName: string | null
    apiKey: string | null
    status: $Enums.PartnerStatus | null
    apiKeyLastGenerated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiPartnerMaxAggregateOutputType = {
    id: string | null
    companyName: string | null
    contactEmail: string | null
    apiKeyName: string | null
    apiKey: string | null
    status: $Enums.PartnerStatus | null
    apiKeyLastGenerated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiPartnerCountAggregateOutputType = {
    id: number
    companyName: number
    contactEmail: number
    apiKeyName: number
    apiKey: number
    status: number
    permissions: number
    apiKeyLastGenerated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApiPartnerMinAggregateInputType = {
    id?: true
    companyName?: true
    contactEmail?: true
    apiKeyName?: true
    apiKey?: true
    status?: true
    apiKeyLastGenerated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiPartnerMaxAggregateInputType = {
    id?: true
    companyName?: true
    contactEmail?: true
    apiKeyName?: true
    apiKey?: true
    status?: true
    apiKeyLastGenerated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiPartnerCountAggregateInputType = {
    id?: true
    companyName?: true
    contactEmail?: true
    apiKeyName?: true
    apiKey?: true
    status?: true
    permissions?: true
    apiKeyLastGenerated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApiPartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiPartner to aggregate.
     */
    where?: ApiPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiPartners to fetch.
     */
    orderBy?: ApiPartnerOrderByWithRelationInput | ApiPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiPartners
    **/
    _count?: true | ApiPartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiPartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiPartnerMaxAggregateInputType
  }

  export type GetApiPartnerAggregateType<T extends ApiPartnerAggregateArgs> = {
        [P in keyof T & keyof AggregateApiPartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiPartner[P]>
      : GetScalarType<T[P], AggregateApiPartner[P]>
  }




  export type ApiPartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiPartnerWhereInput
    orderBy?: ApiPartnerOrderByWithAggregationInput | ApiPartnerOrderByWithAggregationInput[]
    by: ApiPartnerScalarFieldEnum[] | ApiPartnerScalarFieldEnum
    having?: ApiPartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiPartnerCountAggregateInputType | true
    _min?: ApiPartnerMinAggregateInputType
    _max?: ApiPartnerMaxAggregateInputType
  }

  export type ApiPartnerGroupByOutputType = {
    id: string
    companyName: string
    contactEmail: string
    apiKeyName: string
    apiKey: string | null
    status: $Enums.PartnerStatus
    permissions: string[]
    apiKeyLastGenerated: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ApiPartnerCountAggregateOutputType | null
    _min: ApiPartnerMinAggregateOutputType | null
    _max: ApiPartnerMaxAggregateOutputType | null
  }

  type GetApiPartnerGroupByPayload<T extends ApiPartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiPartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiPartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiPartnerGroupByOutputType[P]>
            : GetScalarType<T[P], ApiPartnerGroupByOutputType[P]>
        }
      >
    >


  export type ApiPartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactEmail?: boolean
    apiKeyName?: boolean
    apiKey?: boolean
    status?: boolean
    permissions?: boolean
    apiKeyLastGenerated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["apiPartner"]>

  export type ApiPartnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactEmail?: boolean
    apiKeyName?: boolean
    apiKey?: boolean
    status?: boolean
    permissions?: boolean
    apiKeyLastGenerated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["apiPartner"]>

  export type ApiPartnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactEmail?: boolean
    apiKeyName?: boolean
    apiKey?: boolean
    status?: boolean
    permissions?: boolean
    apiKeyLastGenerated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["apiPartner"]>

  export type ApiPartnerSelectScalar = {
    id?: boolean
    companyName?: boolean
    contactEmail?: boolean
    apiKeyName?: boolean
    apiKey?: boolean
    status?: boolean
    permissions?: boolean
    apiKeyLastGenerated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApiPartnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyName" | "contactEmail" | "apiKeyName" | "apiKey" | "status" | "permissions" | "apiKeyLastGenerated" | "createdAt" | "updatedAt", ExtArgs["result"]["apiPartner"]>

  export type $ApiPartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiPartner"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyName: string
      contactEmail: string
      apiKeyName: string
      apiKey: string | null
      status: $Enums.PartnerStatus
      permissions: string[]
      apiKeyLastGenerated: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["apiPartner"]>
    composites: {}
  }

  type ApiPartnerGetPayload<S extends boolean | null | undefined | ApiPartnerDefaultArgs> = $Result.GetResult<Prisma.$ApiPartnerPayload, S>

  type ApiPartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiPartnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiPartnerCountAggregateInputType | true
    }

  export interface ApiPartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiPartner'], meta: { name: 'ApiPartner' } }
    /**
     * Find zero or one ApiPartner that matches the filter.
     * @param {ApiPartnerFindUniqueArgs} args - Arguments to find a ApiPartner
     * @example
     * // Get one ApiPartner
     * const apiPartner = await prisma.apiPartner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiPartnerFindUniqueArgs>(args: SelectSubset<T, ApiPartnerFindUniqueArgs<ExtArgs>>): Prisma__ApiPartnerClient<$Result.GetResult<Prisma.$ApiPartnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiPartner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiPartnerFindUniqueOrThrowArgs} args - Arguments to find a ApiPartner
     * @example
     * // Get one ApiPartner
     * const apiPartner = await prisma.apiPartner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiPartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiPartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiPartnerClient<$Result.GetResult<Prisma.$ApiPartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiPartner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiPartnerFindFirstArgs} args - Arguments to find a ApiPartner
     * @example
     * // Get one ApiPartner
     * const apiPartner = await prisma.apiPartner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiPartnerFindFirstArgs>(args?: SelectSubset<T, ApiPartnerFindFirstArgs<ExtArgs>>): Prisma__ApiPartnerClient<$Result.GetResult<Prisma.$ApiPartnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiPartner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiPartnerFindFirstOrThrowArgs} args - Arguments to find a ApiPartner
     * @example
     * // Get one ApiPartner
     * const apiPartner = await prisma.apiPartner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiPartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiPartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiPartnerClient<$Result.GetResult<Prisma.$ApiPartnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiPartners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiPartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiPartners
     * const apiPartners = await prisma.apiPartner.findMany()
     * 
     * // Get first 10 ApiPartners
     * const apiPartners = await prisma.apiPartner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiPartnerWithIdOnly = await prisma.apiPartner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiPartnerFindManyArgs>(args?: SelectSubset<T, ApiPartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiPartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiPartner.
     * @param {ApiPartnerCreateArgs} args - Arguments to create a ApiPartner.
     * @example
     * // Create one ApiPartner
     * const ApiPartner = await prisma.apiPartner.create({
     *   data: {
     *     // ... data to create a ApiPartner
     *   }
     * })
     * 
     */
    create<T extends ApiPartnerCreateArgs>(args: SelectSubset<T, ApiPartnerCreateArgs<ExtArgs>>): Prisma__ApiPartnerClient<$Result.GetResult<Prisma.$ApiPartnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiPartners.
     * @param {ApiPartnerCreateManyArgs} args - Arguments to create many ApiPartners.
     * @example
     * // Create many ApiPartners
     * const apiPartner = await prisma.apiPartner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiPartnerCreateManyArgs>(args?: SelectSubset<T, ApiPartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiPartners and returns the data saved in the database.
     * @param {ApiPartnerCreateManyAndReturnArgs} args - Arguments to create many ApiPartners.
     * @example
     * // Create many ApiPartners
     * const apiPartner = await prisma.apiPartner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiPartners and only return the `id`
     * const apiPartnerWithIdOnly = await prisma.apiPartner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiPartnerCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiPartnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiPartnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiPartner.
     * @param {ApiPartnerDeleteArgs} args - Arguments to delete one ApiPartner.
     * @example
     * // Delete one ApiPartner
     * const ApiPartner = await prisma.apiPartner.delete({
     *   where: {
     *     // ... filter to delete one ApiPartner
     *   }
     * })
     * 
     */
    delete<T extends ApiPartnerDeleteArgs>(args: SelectSubset<T, ApiPartnerDeleteArgs<ExtArgs>>): Prisma__ApiPartnerClient<$Result.GetResult<Prisma.$ApiPartnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiPartner.
     * @param {ApiPartnerUpdateArgs} args - Arguments to update one ApiPartner.
     * @example
     * // Update one ApiPartner
     * const apiPartner = await prisma.apiPartner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiPartnerUpdateArgs>(args: SelectSubset<T, ApiPartnerUpdateArgs<ExtArgs>>): Prisma__ApiPartnerClient<$Result.GetResult<Prisma.$ApiPartnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiPartners.
     * @param {ApiPartnerDeleteManyArgs} args - Arguments to filter ApiPartners to delete.
     * @example
     * // Delete a few ApiPartners
     * const { count } = await prisma.apiPartner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiPartnerDeleteManyArgs>(args?: SelectSubset<T, ApiPartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiPartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiPartners
     * const apiPartner = await prisma.apiPartner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiPartnerUpdateManyArgs>(args: SelectSubset<T, ApiPartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiPartners and returns the data updated in the database.
     * @param {ApiPartnerUpdateManyAndReturnArgs} args - Arguments to update many ApiPartners.
     * @example
     * // Update many ApiPartners
     * const apiPartner = await prisma.apiPartner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiPartners and only return the `id`
     * const apiPartnerWithIdOnly = await prisma.apiPartner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiPartnerUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiPartnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiPartnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiPartner.
     * @param {ApiPartnerUpsertArgs} args - Arguments to update or create a ApiPartner.
     * @example
     * // Update or create a ApiPartner
     * const apiPartner = await prisma.apiPartner.upsert({
     *   create: {
     *     // ... data to create a ApiPartner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiPartner we want to update
     *   }
     * })
     */
    upsert<T extends ApiPartnerUpsertArgs>(args: SelectSubset<T, ApiPartnerUpsertArgs<ExtArgs>>): Prisma__ApiPartnerClient<$Result.GetResult<Prisma.$ApiPartnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiPartnerCountArgs} args - Arguments to filter ApiPartners to count.
     * @example
     * // Count the number of ApiPartners
     * const count = await prisma.apiPartner.count({
     *   where: {
     *     // ... the filter for the ApiPartners we want to count
     *   }
     * })
    **/
    count<T extends ApiPartnerCountArgs>(
      args?: Subset<T, ApiPartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiPartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiPartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiPartnerAggregateArgs>(args: Subset<T, ApiPartnerAggregateArgs>): Prisma.PrismaPromise<GetApiPartnerAggregateType<T>>

    /**
     * Group by ApiPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiPartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiPartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiPartnerGroupByArgs['orderBy'] }
        : { orderBy?: ApiPartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiPartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiPartner model
   */
  readonly fields: ApiPartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiPartner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiPartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiPartner model
   */
  interface ApiPartnerFieldRefs {
    readonly id: FieldRef<"ApiPartner", 'String'>
    readonly companyName: FieldRef<"ApiPartner", 'String'>
    readonly contactEmail: FieldRef<"ApiPartner", 'String'>
    readonly apiKeyName: FieldRef<"ApiPartner", 'String'>
    readonly apiKey: FieldRef<"ApiPartner", 'String'>
    readonly status: FieldRef<"ApiPartner", 'PartnerStatus'>
    readonly permissions: FieldRef<"ApiPartner", 'String[]'>
    readonly apiKeyLastGenerated: FieldRef<"ApiPartner", 'DateTime'>
    readonly createdAt: FieldRef<"ApiPartner", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiPartner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiPartner findUnique
   */
  export type ApiPartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiPartner
     */
    select?: ApiPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiPartner
     */
    omit?: ApiPartnerOmit<ExtArgs> | null
    /**
     * Filter, which ApiPartner to fetch.
     */
    where: ApiPartnerWhereUniqueInput
  }

  /**
   * ApiPartner findUniqueOrThrow
   */
  export type ApiPartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiPartner
     */
    select?: ApiPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiPartner
     */
    omit?: ApiPartnerOmit<ExtArgs> | null
    /**
     * Filter, which ApiPartner to fetch.
     */
    where: ApiPartnerWhereUniqueInput
  }

  /**
   * ApiPartner findFirst
   */
  export type ApiPartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiPartner
     */
    select?: ApiPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiPartner
     */
    omit?: ApiPartnerOmit<ExtArgs> | null
    /**
     * Filter, which ApiPartner to fetch.
     */
    where?: ApiPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiPartners to fetch.
     */
    orderBy?: ApiPartnerOrderByWithRelationInput | ApiPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiPartners.
     */
    cursor?: ApiPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiPartners.
     */
    distinct?: ApiPartnerScalarFieldEnum | ApiPartnerScalarFieldEnum[]
  }

  /**
   * ApiPartner findFirstOrThrow
   */
  export type ApiPartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiPartner
     */
    select?: ApiPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiPartner
     */
    omit?: ApiPartnerOmit<ExtArgs> | null
    /**
     * Filter, which ApiPartner to fetch.
     */
    where?: ApiPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiPartners to fetch.
     */
    orderBy?: ApiPartnerOrderByWithRelationInput | ApiPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiPartners.
     */
    cursor?: ApiPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiPartners.
     */
    distinct?: ApiPartnerScalarFieldEnum | ApiPartnerScalarFieldEnum[]
  }

  /**
   * ApiPartner findMany
   */
  export type ApiPartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiPartner
     */
    select?: ApiPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiPartner
     */
    omit?: ApiPartnerOmit<ExtArgs> | null
    /**
     * Filter, which ApiPartners to fetch.
     */
    where?: ApiPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiPartners to fetch.
     */
    orderBy?: ApiPartnerOrderByWithRelationInput | ApiPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiPartners.
     */
    cursor?: ApiPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiPartners.
     */
    skip?: number
    distinct?: ApiPartnerScalarFieldEnum | ApiPartnerScalarFieldEnum[]
  }

  /**
   * ApiPartner create
   */
  export type ApiPartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiPartner
     */
    select?: ApiPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiPartner
     */
    omit?: ApiPartnerOmit<ExtArgs> | null
    /**
     * The data needed to create a ApiPartner.
     */
    data: XOR<ApiPartnerCreateInput, ApiPartnerUncheckedCreateInput>
  }

  /**
   * ApiPartner createMany
   */
  export type ApiPartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiPartners.
     */
    data: ApiPartnerCreateManyInput | ApiPartnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiPartner createManyAndReturn
   */
  export type ApiPartnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiPartner
     */
    select?: ApiPartnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiPartner
     */
    omit?: ApiPartnerOmit<ExtArgs> | null
    /**
     * The data used to create many ApiPartners.
     */
    data: ApiPartnerCreateManyInput | ApiPartnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiPartner update
   */
  export type ApiPartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiPartner
     */
    select?: ApiPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiPartner
     */
    omit?: ApiPartnerOmit<ExtArgs> | null
    /**
     * The data needed to update a ApiPartner.
     */
    data: XOR<ApiPartnerUpdateInput, ApiPartnerUncheckedUpdateInput>
    /**
     * Choose, which ApiPartner to update.
     */
    where: ApiPartnerWhereUniqueInput
  }

  /**
   * ApiPartner updateMany
   */
  export type ApiPartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiPartners.
     */
    data: XOR<ApiPartnerUpdateManyMutationInput, ApiPartnerUncheckedUpdateManyInput>
    /**
     * Filter which ApiPartners to update
     */
    where?: ApiPartnerWhereInput
    /**
     * Limit how many ApiPartners to update.
     */
    limit?: number
  }

  /**
   * ApiPartner updateManyAndReturn
   */
  export type ApiPartnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiPartner
     */
    select?: ApiPartnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiPartner
     */
    omit?: ApiPartnerOmit<ExtArgs> | null
    /**
     * The data used to update ApiPartners.
     */
    data: XOR<ApiPartnerUpdateManyMutationInput, ApiPartnerUncheckedUpdateManyInput>
    /**
     * Filter which ApiPartners to update
     */
    where?: ApiPartnerWhereInput
    /**
     * Limit how many ApiPartners to update.
     */
    limit?: number
  }

  /**
   * ApiPartner upsert
   */
  export type ApiPartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiPartner
     */
    select?: ApiPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiPartner
     */
    omit?: ApiPartnerOmit<ExtArgs> | null
    /**
     * The filter to search for the ApiPartner to update in case it exists.
     */
    where: ApiPartnerWhereUniqueInput
    /**
     * In case the ApiPartner found by the `where` argument doesn't exist, create a new ApiPartner with this data.
     */
    create: XOR<ApiPartnerCreateInput, ApiPartnerUncheckedCreateInput>
    /**
     * In case the ApiPartner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiPartnerUpdateInput, ApiPartnerUncheckedUpdateInput>
  }

  /**
   * ApiPartner delete
   */
  export type ApiPartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiPartner
     */
    select?: ApiPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiPartner
     */
    omit?: ApiPartnerOmit<ExtArgs> | null
    /**
     * Filter which ApiPartner to delete.
     */
    where: ApiPartnerWhereUniqueInput
  }

  /**
   * ApiPartner deleteMany
   */
  export type ApiPartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiPartners to delete
     */
    where?: ApiPartnerWhereInput
    /**
     * Limit how many ApiPartners to delete.
     */
    limit?: number
  }

  /**
   * ApiPartner without action
   */
  export type ApiPartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiPartner
     */
    select?: ApiPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiPartner
     */
    omit?: ApiPartnerOmit<ExtArgs> | null
  }


  /**
   * Model WishlistItem
   */

  export type AggregateWishlistItem = {
    _count: WishlistItemCountAggregateOutputType | null
    _min: WishlistItemMinAggregateOutputType | null
    _max: WishlistItemMaxAggregateOutputType | null
  }

  export type WishlistItemMinAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    addedAt: Date | null
  }

  export type WishlistItemMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    addedAt: Date | null
  }

  export type WishlistItemCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    addedAt: number
    _all: number
  }


  export type WishlistItemMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    addedAt?: true
  }

  export type WishlistItemMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    addedAt?: true
  }

  export type WishlistItemCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    addedAt?: true
    _all?: true
  }

  export type WishlistItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WishlistItem to aggregate.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WishlistItems
    **/
    _count?: true | WishlistItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WishlistItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WishlistItemMaxAggregateInputType
  }

  export type GetWishlistItemAggregateType<T extends WishlistItemAggregateArgs> = {
        [P in keyof T & keyof AggregateWishlistItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishlistItem[P]>
      : GetScalarType<T[P], AggregateWishlistItem[P]>
  }




  export type WishlistItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput
    orderBy?: WishlistItemOrderByWithAggregationInput | WishlistItemOrderByWithAggregationInput[]
    by: WishlistItemScalarFieldEnum[] | WishlistItemScalarFieldEnum
    having?: WishlistItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WishlistItemCountAggregateInputType | true
    _min?: WishlistItemMinAggregateInputType
    _max?: WishlistItemMaxAggregateInputType
  }

  export type WishlistItemGroupByOutputType = {
    id: string
    userId: string
    productId: string
    addedAt: Date
    _count: WishlistItemCountAggregateOutputType | null
    _min: WishlistItemMinAggregateOutputType | null
    _max: WishlistItemMaxAggregateOutputType | null
  }

  type GetWishlistItemGroupByPayload<T extends WishlistItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WishlistItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WishlistItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WishlistItemGroupByOutputType[P]>
            : GetScalarType<T[P], WishlistItemGroupByOutputType[P]>
        }
      >
    >


  export type WishlistItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlistItem"]>

  export type WishlistItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlistItem"]>

  export type WishlistItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlistItem"]>

  export type WishlistItemSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    addedAt?: boolean
  }

  export type WishlistItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "productId" | "addedAt", ExtArgs["result"]["wishlistItem"]>
  export type WishlistItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type WishlistItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type WishlistItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $WishlistItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WishlistItem"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      productId: string
      addedAt: Date
    }, ExtArgs["result"]["wishlistItem"]>
    composites: {}
  }

  type WishlistItemGetPayload<S extends boolean | null | undefined | WishlistItemDefaultArgs> = $Result.GetResult<Prisma.$WishlistItemPayload, S>

  type WishlistItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WishlistItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WishlistItemCountAggregateInputType | true
    }

  export interface WishlistItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WishlistItem'], meta: { name: 'WishlistItem' } }
    /**
     * Find zero or one WishlistItem that matches the filter.
     * @param {WishlistItemFindUniqueArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WishlistItemFindUniqueArgs>(args: SelectSubset<T, WishlistItemFindUniqueArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WishlistItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WishlistItemFindUniqueOrThrowArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WishlistItemFindUniqueOrThrowArgs>(args: SelectSubset<T, WishlistItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WishlistItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindFirstArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WishlistItemFindFirstArgs>(args?: SelectSubset<T, WishlistItemFindFirstArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WishlistItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindFirstOrThrowArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WishlistItemFindFirstOrThrowArgs>(args?: SelectSubset<T, WishlistItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WishlistItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WishlistItems
     * const wishlistItems = await prisma.wishlistItem.findMany()
     * 
     * // Get first 10 WishlistItems
     * const wishlistItems = await prisma.wishlistItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wishlistItemWithIdOnly = await prisma.wishlistItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WishlistItemFindManyArgs>(args?: SelectSubset<T, WishlistItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WishlistItem.
     * @param {WishlistItemCreateArgs} args - Arguments to create a WishlistItem.
     * @example
     * // Create one WishlistItem
     * const WishlistItem = await prisma.wishlistItem.create({
     *   data: {
     *     // ... data to create a WishlistItem
     *   }
     * })
     * 
     */
    create<T extends WishlistItemCreateArgs>(args: SelectSubset<T, WishlistItemCreateArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WishlistItems.
     * @param {WishlistItemCreateManyArgs} args - Arguments to create many WishlistItems.
     * @example
     * // Create many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WishlistItemCreateManyArgs>(args?: SelectSubset<T, WishlistItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WishlistItems and returns the data saved in the database.
     * @param {WishlistItemCreateManyAndReturnArgs} args - Arguments to create many WishlistItems.
     * @example
     * // Create many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WishlistItems and only return the `id`
     * const wishlistItemWithIdOnly = await prisma.wishlistItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WishlistItemCreateManyAndReturnArgs>(args?: SelectSubset<T, WishlistItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WishlistItem.
     * @param {WishlistItemDeleteArgs} args - Arguments to delete one WishlistItem.
     * @example
     * // Delete one WishlistItem
     * const WishlistItem = await prisma.wishlistItem.delete({
     *   where: {
     *     // ... filter to delete one WishlistItem
     *   }
     * })
     * 
     */
    delete<T extends WishlistItemDeleteArgs>(args: SelectSubset<T, WishlistItemDeleteArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WishlistItem.
     * @param {WishlistItemUpdateArgs} args - Arguments to update one WishlistItem.
     * @example
     * // Update one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WishlistItemUpdateArgs>(args: SelectSubset<T, WishlistItemUpdateArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WishlistItems.
     * @param {WishlistItemDeleteManyArgs} args - Arguments to filter WishlistItems to delete.
     * @example
     * // Delete a few WishlistItems
     * const { count } = await prisma.wishlistItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WishlistItemDeleteManyArgs>(args?: SelectSubset<T, WishlistItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WishlistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WishlistItemUpdateManyArgs>(args: SelectSubset<T, WishlistItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WishlistItems and returns the data updated in the database.
     * @param {WishlistItemUpdateManyAndReturnArgs} args - Arguments to update many WishlistItems.
     * @example
     * // Update many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WishlistItems and only return the `id`
     * const wishlistItemWithIdOnly = await prisma.wishlistItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WishlistItemUpdateManyAndReturnArgs>(args: SelectSubset<T, WishlistItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WishlistItem.
     * @param {WishlistItemUpsertArgs} args - Arguments to update or create a WishlistItem.
     * @example
     * // Update or create a WishlistItem
     * const wishlistItem = await prisma.wishlistItem.upsert({
     *   create: {
     *     // ... data to create a WishlistItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WishlistItem we want to update
     *   }
     * })
     */
    upsert<T extends WishlistItemUpsertArgs>(args: SelectSubset<T, WishlistItemUpsertArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WishlistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemCountArgs} args - Arguments to filter WishlistItems to count.
     * @example
     * // Count the number of WishlistItems
     * const count = await prisma.wishlistItem.count({
     *   where: {
     *     // ... the filter for the WishlistItems we want to count
     *   }
     * })
    **/
    count<T extends WishlistItemCountArgs>(
      args?: Subset<T, WishlistItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WishlistItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WishlistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WishlistItemAggregateArgs>(args: Subset<T, WishlistItemAggregateArgs>): Prisma.PrismaPromise<GetWishlistItemAggregateType<T>>

    /**
     * Group by WishlistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WishlistItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishlistItemGroupByArgs['orderBy'] }
        : { orderBy?: WishlistItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WishlistItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWishlistItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WishlistItem model
   */
  readonly fields: WishlistItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WishlistItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WishlistItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WishlistItem model
   */
  interface WishlistItemFieldRefs {
    readonly id: FieldRef<"WishlistItem", 'String'>
    readonly userId: FieldRef<"WishlistItem", 'String'>
    readonly productId: FieldRef<"WishlistItem", 'String'>
    readonly addedAt: FieldRef<"WishlistItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WishlistItem findUnique
   */
  export type WishlistItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem findUniqueOrThrow
   */
  export type WishlistItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem findFirst
   */
  export type WishlistItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WishlistItems.
     */
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * WishlistItem findFirstOrThrow
   */
  export type WishlistItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WishlistItems.
     */
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * WishlistItem findMany
   */
  export type WishlistItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItems to fetch.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * WishlistItem create
   */
  export type WishlistItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * The data needed to create a WishlistItem.
     */
    data: XOR<WishlistItemCreateInput, WishlistItemUncheckedCreateInput>
  }

  /**
   * WishlistItem createMany
   */
  export type WishlistItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WishlistItems.
     */
    data: WishlistItemCreateManyInput | WishlistItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WishlistItem createManyAndReturn
   */
  export type WishlistItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * The data used to create many WishlistItems.
     */
    data: WishlistItemCreateManyInput | WishlistItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WishlistItem update
   */
  export type WishlistItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * The data needed to update a WishlistItem.
     */
    data: XOR<WishlistItemUpdateInput, WishlistItemUncheckedUpdateInput>
    /**
     * Choose, which WishlistItem to update.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem updateMany
   */
  export type WishlistItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WishlistItems.
     */
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyInput>
    /**
     * Filter which WishlistItems to update
     */
    where?: WishlistItemWhereInput
    /**
     * Limit how many WishlistItems to update.
     */
    limit?: number
  }

  /**
   * WishlistItem updateManyAndReturn
   */
  export type WishlistItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * The data used to update WishlistItems.
     */
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyInput>
    /**
     * Filter which WishlistItems to update
     */
    where?: WishlistItemWhereInput
    /**
     * Limit how many WishlistItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WishlistItem upsert
   */
  export type WishlistItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * The filter to search for the WishlistItem to update in case it exists.
     */
    where: WishlistItemWhereUniqueInput
    /**
     * In case the WishlistItem found by the `where` argument doesn't exist, create a new WishlistItem with this data.
     */
    create: XOR<WishlistItemCreateInput, WishlistItemUncheckedCreateInput>
    /**
     * In case the WishlistItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WishlistItemUpdateInput, WishlistItemUncheckedUpdateInput>
  }

  /**
   * WishlistItem delete
   */
  export type WishlistItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter which WishlistItem to delete.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem deleteMany
   */
  export type WishlistItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WishlistItems to delete
     */
    where?: WishlistItemWhereInput
    /**
     * Limit how many WishlistItems to delete.
     */
    limit?: number
  }

  /**
   * WishlistItem without action
   */
  export type WishlistItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$TeamMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Team$membersArgs<ExtArgs> = {}>(args?: Subset<T, Team$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly description: FieldRef<"Team", 'String'>
    readonly createdById: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    userId: string | null
    role: string | null
    invitedBy: string | null
    joinedAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    userId: string | null
    role: string | null
    invitedBy: string | null
    joinedAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    teamId: number
    userId: number
    role: number
    invitedBy: number
    joinedAt: number
    _all: number
  }


  export type TeamMemberMinAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    invitedBy?: true
    joinedAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    invitedBy?: true
    joinedAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    invitedBy?: true
    joinedAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: string
    teamId: string
    userId: string
    role: string
    invitedBy: string | null
    joinedAt: Date
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    invitedBy?: boolean
    joinedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    invitedBy?: boolean
    joinedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    invitedBy?: boolean
    joinedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectScalar = {
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    invitedBy?: boolean
    joinedAt?: boolean
  }

  export type TeamMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "userId" | "role" | "invitedBy" | "joinedAt", ExtArgs["result"]["teamMember"]>
  export type TeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      userId: string
      role: string
      invitedBy: string | null
      joinedAt: Date
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamMembers and returns the data saved in the database.
     * @param {TeamMemberCreateManyAndReturnArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers and returns the data updated in the database.
     * @param {TeamMemberUpdateManyAndReturnArgs} args - Arguments to update many TeamMembers.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", 'String'>
    readonly teamId: FieldRef<"TeamMember", 'String'>
    readonly userId: FieldRef<"TeamMember", 'String'>
    readonly role: FieldRef<"TeamMember", 'String'>
    readonly invitedBy: FieldRef<"TeamMember", 'String'>
    readonly joinedAt: FieldRef<"TeamMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMember createManyAndReturn
   */
  export type TeamMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
  }

  /**
   * TeamMember updateManyAndReturn
   */
  export type TeamMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to delete.
     */
    limit?: number
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    metadata: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    metadata?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    entityType: string
    entityId: string | null
    metadata: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entityType" | "entityId" | "metadata" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entityType: string
      entityId: string | null
      metadata: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    city: 'city',
    country: 'country',
    phone: 'phone',
    sellerHandle: 'sellerHandle',
    shopName: 'shopName',
    shopLogoUrl: 'shopLogoUrl',
    shopBannerUrl: 'shopBannerUrl',
    shopBio: 'shopBio',
    ratingAvg: 'ratingAvg',
    ratingCount: 'ratingCount',
    bio: 'bio',
    notifyEmail: 'notifyEmail',
    notifySms: 'notifySms',
    notifyPush: 'notifyPush',
    timezone: 'timezone',
    quietHoursStart: 'quietHoursStart',
    quietHoursEnd: 'quietHoursEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    sellerId: 'sellerId',
    title: 'title',
    description: 'description',
    price: 'price',
    currency: 'currency',
    imageUrl: 'imageUrl',
    category: 'category',
    ratingAvg: 'ratingAvg',
    ratingCount: 'ratingCount',
    viewCount: 'viewCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    quantity: 'quantity',
    updatedAt: 'updatedAt'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const CartScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    anonKey: 'anonKey',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


  export const CartItemScalarFieldEnum: {
    id: 'id',
    cartId: 'cartId',
    productId: 'productId',
    qty: 'qty',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CartItemScalarFieldEnum = (typeof CartItemScalarFieldEnum)[keyof typeof CartItemScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    total: 'total',
    currency: 'currency',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    paymentRef: 'paymentRef',
    shippingAdr: 'shippingAdr',
    buyerName: 'buyerName',
    buyerPhone: 'buyerPhone',
    buyerEmail: 'buyerEmail'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    qty: 'qty',
    price: 'price',
    sellerId: 'sellerId',
    grossAmount: 'grossAmount',
    feeAmount: 'feeAmount',
    netAmount: 'netAmount',
    payoutStatus: 'payoutStatus',
    payoutBatchId: 'payoutBatchId',
    paidAt: 'paidAt',
    currency: 'currency',
    fulfillmentStatus: 'fulfillmentStatus',
    shippedAt: 'shippedAt',
    deliveredAt: 'deliveredAt',
    trackingCode: 'trackingCode',
    carrier: 'carrier',
    deliveryProofUrl: 'deliveryProofUrl',
    notes: 'notes',
    exceptionNotified: 'exceptionNotified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    provider: 'provider',
    externalRef: 'externalRef',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const FulfillmentSettingsScalarFieldEnum: {
    id: 'id',
    sellerId: 'sellerId',
    usesMicroFulfillment: 'usesMicroFulfillment',
    microFulfillmentPartnerId: 'microFulfillmentPartnerId',
    microFulfillmentOptInDate: 'microFulfillmentOptInDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FulfillmentSettingsScalarFieldEnum = (typeof FulfillmentSettingsScalarFieldEnum)[keyof typeof FulfillmentSettingsScalarFieldEnum]


  export const KYCDocumentScalarFieldEnum: {
    id: 'id',
    sellerId: 'sellerId',
    documentType: 'documentType',
    documentNumber: 'documentNumber',
    documentUrl: 'documentUrl',
    country: 'country',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KYCDocumentScalarFieldEnum = (typeof KYCDocumentScalarFieldEnum)[keyof typeof KYCDocumentScalarFieldEnum]


  export const TaxRegistrationScalarFieldEnum: {
    id: 'id',
    sellerId: 'sellerId',
    taxId: 'taxId',
    country: 'country',
    status: 'status',
    expiryDate: 'expiryDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaxRegistrationScalarFieldEnum = (typeof TaxRegistrationScalarFieldEnum)[keyof typeof TaxRegistrationScalarFieldEnum]


  export const CounterfeitReportScalarFieldEnum: {
    id: 'id',
    reporterId: 'reporterId',
    productId: 'productId',
    reason: 'reason',
    evidenceUrl: 'evidenceUrl',
    status: 'status',
    resolution: 'resolution',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CounterfeitReportScalarFieldEnum = (typeof CounterfeitReportScalarFieldEnum)[keyof typeof CounterfeitReportScalarFieldEnum]


  export const SellerApplicationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    businessName: 'businessName',
    phone: 'phone',
    country: 'country',
    city: 'city',
    storefrontDesc: 'storefrontDesc',
    bankName: 'bankName',
    accountNumber: 'accountNumber',
    accountName: 'accountName',
    bankCode: 'bankCode',
    status: 'status',
    adminNote: 'adminNote',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SellerApplicationScalarFieldEnum = (typeof SellerApplicationScalarFieldEnum)[keyof typeof SellerApplicationScalarFieldEnum]


  export const DisputeScalarFieldEnum: {
    id: 'id',
    orderItemId: 'orderItemId',
    buyerId: 'buyerId',
    reasonCode: 'reasonCode',
    description: 'description',
    photoProofUrl: 'photoProofUrl',
    status: 'status',
    resolutionNote: 'resolutionNote',
    resolvedById: 'resolvedById',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DisputeScalarFieldEnum = (typeof DisputeScalarFieldEnum)[keyof typeof DisputeScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    orderItemId: 'orderItemId',
    sellerId: 'sellerId',
    buyerId: 'buyerId',
    productId: 'productId',
    rating: 'rating',
    comment: 'comment',
    isVisible: 'isVisible',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    body: 'body',
    message: 'message',
    type: 'type',
    isRead: 'isRead',
    readAt: 'readAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const CommunityStoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    content: 'content',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt'
  };

  export type CommunityStoryScalarFieldEnum = (typeof CommunityStoryScalarFieldEnum)[keyof typeof CommunityStoryScalarFieldEnum]


  export const ProductViewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    timestamp: 'timestamp'
  };

  export type ProductViewScalarFieldEnum = (typeof ProductViewScalarFieldEnum)[keyof typeof ProductViewScalarFieldEnum]


  export const SponsoredPlacementScalarFieldEnum: {
    id: 'id',
    sellerId: 'sellerId',
    productId: 'productId',
    categorySlug: 'categorySlug',
    searchTerm: 'searchTerm',
    bidAmount: 'bidAmount',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SponsoredPlacementScalarFieldEnum = (typeof SponsoredPlacementScalarFieldEnum)[keyof typeof SponsoredPlacementScalarFieldEnum]


  export const SellerServiceScalarFieldEnum: {
    id: 'id',
    sellerId: 'sellerId',
    title: 'title',
    description: 'description',
    price: 'price',
    currency: 'currency',
    category: 'category',
    deliveryTime: 'deliveryTime',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SellerServiceScalarFieldEnum = (typeof SellerServiceScalarFieldEnum)[keyof typeof SellerServiceScalarFieldEnum]


  export const ServiceOrderScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    buyerId: 'buyerId',
    sellerId: 'sellerId',
    message: 'message',
    price: 'price',
    currency: 'currency',
    status: 'status',
    note: 'note',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceOrderScalarFieldEnum = (typeof ServiceOrderScalarFieldEnum)[keyof typeof ServiceOrderScalarFieldEnum]


  export const SubscriptionPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    currency: 'currency',
    features: 'features',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionPlanScalarFieldEnum = (typeof SubscriptionPlanScalarFieldEnum)[keyof typeof SubscriptionPlanScalarFieldEnum]


  export const UserSubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    planId: 'planId',
    planPrice: 'planPrice',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    autoRenew: 'autoRenew',
    paymentMethod: 'paymentMethod',
    cancelledAt: 'cancelledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSubscriptionScalarFieldEnum = (typeof UserSubscriptionScalarFieldEnum)[keyof typeof UserSubscriptionScalarFieldEnum]


  export const ApiPartnerScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    contactEmail: 'contactEmail',
    apiKeyName: 'apiKeyName',
    apiKey: 'apiKey',
    status: 'status',
    permissions: 'permissions',
    apiKeyLastGenerated: 'apiKeyLastGenerated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApiPartnerScalarFieldEnum = (typeof ApiPartnerScalarFieldEnum)[keyof typeof ApiPartnerScalarFieldEnum]


  export const WishlistItemScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    addedAt: 'addedAt'
  };

  export type WishlistItemScalarFieldEnum = (typeof WishlistItemScalarFieldEnum)[keyof typeof WishlistItemScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    userId: 'userId',
    role: 'role',
    invitedBy: 'invitedBy',
    joinedAt: 'joinedAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    metadata: 'metadata',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'PayoutStatus'
   */
  export type EnumPayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutStatus'>
    


  /**
   * Reference to a field of type 'PayoutStatus[]'
   */
  export type ListEnumPayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutStatus[]'>
    


  /**
   * Reference to a field of type 'FulfillmentStatus'
   */
  export type EnumFulfillmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FulfillmentStatus'>
    


  /**
   * Reference to a field of type 'FulfillmentStatus[]'
   */
  export type ListEnumFulfillmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FulfillmentStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'KYCStatus'
   */
  export type EnumKYCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCStatus'>
    


  /**
   * Reference to a field of type 'KYCStatus[]'
   */
  export type ListEnumKYCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCStatus[]'>
    


  /**
   * Reference to a field of type 'TaxStatus'
   */
  export type EnumTaxStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaxStatus'>
    


  /**
   * Reference to a field of type 'TaxStatus[]'
   */
  export type ListEnumTaxStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaxStatus[]'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'ReportStatus[]'
   */
  export type ListEnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus[]'>
    


  /**
   * Reference to a field of type 'ApplicationStatus'
   */
  export type EnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus'>
    


  /**
   * Reference to a field of type 'ApplicationStatus[]'
   */
  export type ListEnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus[]'>
    


  /**
   * Reference to a field of type 'DisputeReason'
   */
  export type EnumDisputeReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisputeReason'>
    


  /**
   * Reference to a field of type 'DisputeReason[]'
   */
  export type ListEnumDisputeReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisputeReason[]'>
    


  /**
   * Reference to a field of type 'DisputeStatus'
   */
  export type EnumDisputeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisputeStatus'>
    


  /**
   * Reference to a field of type 'DisputeStatus[]'
   */
  export type ListEnumDisputeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisputeStatus[]'>
    


  /**
   * Reference to a field of type 'SponsoredPlacementStatus'
   */
  export type EnumSponsoredPlacementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SponsoredPlacementStatus'>
    


  /**
   * Reference to a field of type 'SponsoredPlacementStatus[]'
   */
  export type ListEnumSponsoredPlacementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SponsoredPlacementStatus[]'>
    


  /**
   * Reference to a field of type 'ServiceOrderStatus'
   */
  export type EnumServiceOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceOrderStatus'>
    


  /**
   * Reference to a field of type 'ServiceOrderStatus[]'
   */
  export type ListEnumServiceOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceOrderStatus[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'PartnerStatus'
   */
  export type EnumPartnerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerStatus'>
    


  /**
   * Reference to a field of type 'PartnerStatus[]'
   */
  export type ListEnumPartnerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    city?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    sellerHandle?: StringNullableFilter<"User"> | string | null
    shopName?: StringNullableFilter<"User"> | string | null
    shopLogoUrl?: StringNullableFilter<"User"> | string | null
    shopBannerUrl?: StringNullableFilter<"User"> | string | null
    shopBio?: StringNullableFilter<"User"> | string | null
    ratingAvg?: FloatNullableFilter<"User"> | number | null
    ratingCount?: IntNullableFilter<"User"> | number | null
    bio?: StringNullableFilter<"User"> | string | null
    notifyEmail?: BoolFilter<"User"> | boolean
    notifySms?: BoolFilter<"User"> | boolean
    notifyPush?: BoolFilter<"User"> | boolean
    timezone?: StringNullableFilter<"User"> | string | null
    quietHoursStart?: IntNullableFilter<"User"> | number | null
    quietHoursEnd?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    carts?: CartListRelationFilter
    orders?: OrderListRelationFilter
    products?: ProductListRelationFilter
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    reviews?: ReviewListRelationFilter
    notifications?: NotificationListRelationFilter
    stories?: CommunityStoryListRelationFilter
    sellerReviews?: ReviewListRelationFilter
    reportedProducts?: CounterfeitReportListRelationFilter
    sellerApplications?: SellerApplicationListRelationFilter
    disputes?: DisputeListRelationFilter
    fulfillmentSettings?: FulfillmentSettingsListRelationFilter
    kycDocuments?: KYCDocumentListRelationFilter
    taxRegistrations?: TaxRegistrationListRelationFilter
    productViews?: ProductViewListRelationFilter
    sponsoredPlacements?: SponsoredPlacementListRelationFilter
    serviceOrdersAsBuyer?: ServiceOrderListRelationFilter
    serviceOrdersAsSeller?: ServiceOrderListRelationFilter
    sellerServices?: SellerServiceListRelationFilter
    subscriptions?: UserSubscriptionListRelationFilter
    wishlistItems?: WishlistItemListRelationFilter
    createdTeams?: TeamListRelationFilter
    teamMemberships?: TeamMemberListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    sellerHandle?: SortOrderInput | SortOrder
    shopName?: SortOrderInput | SortOrder
    shopLogoUrl?: SortOrderInput | SortOrder
    shopBannerUrl?: SortOrderInput | SortOrder
    shopBio?: SortOrderInput | SortOrder
    ratingAvg?: SortOrderInput | SortOrder
    ratingCount?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    notifyEmail?: SortOrder
    notifySms?: SortOrder
    notifyPush?: SortOrder
    timezone?: SortOrderInput | SortOrder
    quietHoursStart?: SortOrderInput | SortOrder
    quietHoursEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    carts?: CartOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    stories?: CommunityStoryOrderByRelationAggregateInput
    sellerReviews?: ReviewOrderByRelationAggregateInput
    reportedProducts?: CounterfeitReportOrderByRelationAggregateInput
    sellerApplications?: SellerApplicationOrderByRelationAggregateInput
    disputes?: DisputeOrderByRelationAggregateInput
    fulfillmentSettings?: FulfillmentSettingsOrderByRelationAggregateInput
    kycDocuments?: KYCDocumentOrderByRelationAggregateInput
    taxRegistrations?: TaxRegistrationOrderByRelationAggregateInput
    productViews?: ProductViewOrderByRelationAggregateInput
    sponsoredPlacements?: SponsoredPlacementOrderByRelationAggregateInput
    serviceOrdersAsBuyer?: ServiceOrderOrderByRelationAggregateInput
    serviceOrdersAsSeller?: ServiceOrderOrderByRelationAggregateInput
    sellerServices?: SellerServiceOrderByRelationAggregateInput
    subscriptions?: UserSubscriptionOrderByRelationAggregateInput
    wishlistItems?: WishlistItemOrderByRelationAggregateInput
    createdTeams?: TeamOrderByRelationAggregateInput
    teamMemberships?: TeamMemberOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    city?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    sellerHandle?: StringNullableFilter<"User"> | string | null
    shopName?: StringNullableFilter<"User"> | string | null
    shopLogoUrl?: StringNullableFilter<"User"> | string | null
    shopBannerUrl?: StringNullableFilter<"User"> | string | null
    shopBio?: StringNullableFilter<"User"> | string | null
    ratingAvg?: FloatNullableFilter<"User"> | number | null
    ratingCount?: IntNullableFilter<"User"> | number | null
    bio?: StringNullableFilter<"User"> | string | null
    notifyEmail?: BoolFilter<"User"> | boolean
    notifySms?: BoolFilter<"User"> | boolean
    notifyPush?: BoolFilter<"User"> | boolean
    timezone?: StringNullableFilter<"User"> | string | null
    quietHoursStart?: IntNullableFilter<"User"> | number | null
    quietHoursEnd?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    carts?: CartListRelationFilter
    orders?: OrderListRelationFilter
    products?: ProductListRelationFilter
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    reviews?: ReviewListRelationFilter
    notifications?: NotificationListRelationFilter
    stories?: CommunityStoryListRelationFilter
    sellerReviews?: ReviewListRelationFilter
    reportedProducts?: CounterfeitReportListRelationFilter
    sellerApplications?: SellerApplicationListRelationFilter
    disputes?: DisputeListRelationFilter
    fulfillmentSettings?: FulfillmentSettingsListRelationFilter
    kycDocuments?: KYCDocumentListRelationFilter
    taxRegistrations?: TaxRegistrationListRelationFilter
    productViews?: ProductViewListRelationFilter
    sponsoredPlacements?: SponsoredPlacementListRelationFilter
    serviceOrdersAsBuyer?: ServiceOrderListRelationFilter
    serviceOrdersAsSeller?: ServiceOrderListRelationFilter
    sellerServices?: SellerServiceListRelationFilter
    subscriptions?: UserSubscriptionListRelationFilter
    wishlistItems?: WishlistItemListRelationFilter
    createdTeams?: TeamListRelationFilter
    teamMemberships?: TeamMemberListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    sellerHandle?: SortOrderInput | SortOrder
    shopName?: SortOrderInput | SortOrder
    shopLogoUrl?: SortOrderInput | SortOrder
    shopBannerUrl?: SortOrderInput | SortOrder
    shopBio?: SortOrderInput | SortOrder
    ratingAvg?: SortOrderInput | SortOrder
    ratingCount?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    notifyEmail?: SortOrder
    notifySms?: SortOrder
    notifyPush?: SortOrder
    timezone?: SortOrderInput | SortOrder
    quietHoursStart?: SortOrderInput | SortOrder
    quietHoursEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    sellerHandle?: StringNullableWithAggregatesFilter<"User"> | string | null
    shopName?: StringNullableWithAggregatesFilter<"User"> | string | null
    shopLogoUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    shopBannerUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    shopBio?: StringNullableWithAggregatesFilter<"User"> | string | null
    ratingAvg?: FloatNullableWithAggregatesFilter<"User"> | number | null
    ratingCount?: IntNullableWithAggregatesFilter<"User"> | number | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    notifyEmail?: BoolWithAggregatesFilter<"User"> | boolean
    notifySms?: BoolWithAggregatesFilter<"User"> | boolean
    notifyPush?: BoolWithAggregatesFilter<"User"> | boolean
    timezone?: StringNullableWithAggregatesFilter<"User"> | string | null
    quietHoursStart?: IntNullableWithAggregatesFilter<"User"> | number | null
    quietHoursEnd?: IntNullableWithAggregatesFilter<"User"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    sellerId?: StringFilter<"Product"> | string
    title?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Product"> | string
    imageUrl?: StringNullableFilter<"Product"> | string | null
    category?: StringNullableFilter<"Product"> | string | null
    ratingAvg?: FloatNullableFilter<"Product"> | number | null
    ratingCount?: IntNullableFilter<"Product"> | number | null
    viewCount?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
    inventory?: XOR<InventoryNullableScalarRelationFilter, InventoryWhereInput> | null
    views?: ProductViewListRelationFilter
    cartItems?: CartItemListRelationFilter
    orderItems?: OrderItemListRelationFilter
    productReviews?: ReviewListRelationFilter
    stories?: CommunityStoryListRelationFilter
    reportedIn?: CounterfeitReportListRelationFilter
    sponsoredPlacements?: SponsoredPlacementListRelationFilter
    wishlistItems?: WishlistItemListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    sellerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    ratingAvg?: SortOrderInput | SortOrder
    ratingCount?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seller?: UserOrderByWithRelationInput
    inventory?: InventoryOrderByWithRelationInput
    views?: ProductViewOrderByRelationAggregateInput
    cartItems?: CartItemOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    productReviews?: ReviewOrderByRelationAggregateInput
    stories?: CommunityStoryOrderByRelationAggregateInput
    reportedIn?: CounterfeitReportOrderByRelationAggregateInput
    sponsoredPlacements?: SponsoredPlacementOrderByRelationAggregateInput
    wishlistItems?: WishlistItemOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    sellerId?: StringFilter<"Product"> | string
    title?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Product"> | string
    imageUrl?: StringNullableFilter<"Product"> | string | null
    category?: StringNullableFilter<"Product"> | string | null
    ratingAvg?: FloatNullableFilter<"Product"> | number | null
    ratingCount?: IntNullableFilter<"Product"> | number | null
    viewCount?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
    inventory?: XOR<InventoryNullableScalarRelationFilter, InventoryWhereInput> | null
    views?: ProductViewListRelationFilter
    cartItems?: CartItemListRelationFilter
    orderItems?: OrderItemListRelationFilter
    productReviews?: ReviewListRelationFilter
    stories?: CommunityStoryListRelationFilter
    reportedIn?: CounterfeitReportListRelationFilter
    sponsoredPlacements?: SponsoredPlacementListRelationFilter
    wishlistItems?: WishlistItemListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    sellerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    ratingAvg?: SortOrderInput | SortOrder
    ratingCount?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    sellerId?: StringWithAggregatesFilter<"Product"> | string
    title?: StringWithAggregatesFilter<"Product"> | string
    description?: StringWithAggregatesFilter<"Product"> | string
    price?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Product"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    category?: StringNullableWithAggregatesFilter<"Product"> | string | null
    ratingAvg?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    ratingCount?: IntNullableWithAggregatesFilter<"Product"> | number | null
    viewCount?: IntWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: StringFilter<"Inventory"> | string
    productId?: StringFilter<"Inventory"> | string
    quantity?: IntFilter<"Inventory"> | number
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId?: string
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    quantity?: IntFilter<"Inventory"> | number
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "productId">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inventory"> | string
    productId?: StringWithAggregatesFilter<"Inventory"> | string
    quantity?: IntWithAggregatesFilter<"Inventory"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
  }

  export type CartWhereInput = {
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    id?: StringFilter<"Cart"> | string
    userId?: StringNullableFilter<"Cart"> | string | null
    anonKey?: StringNullableFilter<"Cart"> | string | null
    version?: IntFilter<"Cart"> | number
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: CartItemListRelationFilter
  }

  export type CartOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    anonKey?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    items?: CartItemOrderByRelationAggregateInput
  }

  export type CartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    anonKey?: string
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    userId?: StringNullableFilter<"Cart"> | string | null
    version?: IntFilter<"Cart"> | number
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: CartItemListRelationFilter
  }, "id" | "anonKey">

  export type CartOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    anonKey?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CartCountOrderByAggregateInput
    _avg?: CartAvgOrderByAggregateInput
    _max?: CartMaxOrderByAggregateInput
    _min?: CartMinOrderByAggregateInput
    _sum?: CartSumOrderByAggregateInput
  }

  export type CartScalarWhereWithAggregatesInput = {
    AND?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    OR?: CartScalarWhereWithAggregatesInput[]
    NOT?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cart"> | string
    userId?: StringNullableWithAggregatesFilter<"Cart"> | string | null
    anonKey?: StringNullableWithAggregatesFilter<"Cart"> | string | null
    version?: IntWithAggregatesFilter<"Cart"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
  }

  export type CartItemWhereInput = {
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    qty?: IntFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type CartItemOrderByWithRelationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    qty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cart?: CartOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type CartItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cartId_productId?: CartItemCartIdProductIdCompoundUniqueInput
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    qty?: IntFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "cartId_productId">

  export type CartItemOrderByWithAggregationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    qty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CartItemCountOrderByAggregateInput
    _avg?: CartItemAvgOrderByAggregateInput
    _max?: CartItemMaxOrderByAggregateInput
    _min?: CartItemMinOrderByAggregateInput
    _sum?: CartItemSumOrderByAggregateInput
  }

  export type CartItemScalarWhereWithAggregatesInput = {
    AND?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    OR?: CartItemScalarWhereWithAggregatesInput[]
    NOT?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CartItem"> | string
    cartId?: StringWithAggregatesFilter<"CartItem"> | string
    productId?: StringWithAggregatesFilter<"CartItem"> | string
    qty?: IntWithAggregatesFilter<"CartItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    total?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    paymentRef?: StringNullableFilter<"Order"> | string | null
    shippingAdr?: StringNullableFilter<"Order"> | string | null
    buyerName?: StringNullableFilter<"Order"> | string | null
    buyerPhone?: StringNullableFilter<"Order"> | string | null
    buyerEmail?: StringNullableFilter<"Order"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: OrderItemListRelationFilter
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentRef?: SortOrderInput | SortOrder
    shippingAdr?: SortOrderInput | SortOrder
    buyerName?: SortOrderInput | SortOrder
    buyerPhone?: SortOrderInput | SortOrder
    buyerEmail?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
    payment?: PaymentOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    userId?: StringFilter<"Order"> | string
    total?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    paymentRef?: StringNullableFilter<"Order"> | string | null
    shippingAdr?: StringNullableFilter<"Order"> | string | null
    buyerName?: StringNullableFilter<"Order"> | string | null
    buyerPhone?: StringNullableFilter<"Order"> | string | null
    buyerEmail?: StringNullableFilter<"Order"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: OrderItemListRelationFilter
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentRef?: SortOrderInput | SortOrder
    shippingAdr?: SortOrderInput | SortOrder
    buyerName?: SortOrderInput | SortOrder
    buyerPhone?: SortOrderInput | SortOrder
    buyerEmail?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    userId?: StringWithAggregatesFilter<"Order"> | string
    total?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Order"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    paymentRef?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shippingAdr?: StringNullableWithAggregatesFilter<"Order"> | string | null
    buyerName?: StringNullableWithAggregatesFilter<"Order"> | string | null
    buyerPhone?: StringNullableWithAggregatesFilter<"Order"> | string | null
    buyerEmail?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    qty?: IntFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    sellerId?: StringFilter<"OrderItem"> | string
    grossAmount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    payoutStatus?: EnumPayoutStatusFilter<"OrderItem"> | $Enums.PayoutStatus
    payoutBatchId?: StringNullableFilter<"OrderItem"> | string | null
    paidAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    currency?: StringFilter<"OrderItem"> | string
    fulfillmentStatus?: EnumFulfillmentStatusFilter<"OrderItem"> | $Enums.FulfillmentStatus
    shippedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    trackingCode?: StringNullableFilter<"OrderItem"> | string | null
    carrier?: StringNullableFilter<"OrderItem"> | string | null
    deliveryProofUrl?: StringNullableFilter<"OrderItem"> | string | null
    notes?: StringNullableFilter<"OrderItem"> | string | null
    exceptionNotified?: BoolNullableFilter<"OrderItem"> | boolean | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    disputes?: DisputeListRelationFilter
    reviews?: ReviewListRelationFilter
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    sellerId?: SortOrder
    grossAmount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    payoutStatus?: SortOrder
    payoutBatchId?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    currency?: SortOrder
    fulfillmentStatus?: SortOrder
    shippedAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    trackingCode?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    deliveryProofUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    exceptionNotified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    disputes?: DisputeOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    qty?: IntFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    sellerId?: StringFilter<"OrderItem"> | string
    grossAmount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    payoutStatus?: EnumPayoutStatusFilter<"OrderItem"> | $Enums.PayoutStatus
    payoutBatchId?: StringNullableFilter<"OrderItem"> | string | null
    paidAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    currency?: StringFilter<"OrderItem"> | string
    fulfillmentStatus?: EnumFulfillmentStatusFilter<"OrderItem"> | $Enums.FulfillmentStatus
    shippedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    trackingCode?: StringNullableFilter<"OrderItem"> | string | null
    carrier?: StringNullableFilter<"OrderItem"> | string | null
    deliveryProofUrl?: StringNullableFilter<"OrderItem"> | string | null
    notes?: StringNullableFilter<"OrderItem"> | string | null
    exceptionNotified?: BoolNullableFilter<"OrderItem"> | boolean | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    disputes?: DisputeListRelationFilter
    reviews?: ReviewListRelationFilter
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    sellerId?: SortOrder
    grossAmount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    payoutStatus?: SortOrder
    payoutBatchId?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    currency?: SortOrder
    fulfillmentStatus?: SortOrder
    shippedAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    trackingCode?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    deliveryProofUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    exceptionNotified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    productId?: StringWithAggregatesFilter<"OrderItem"> | string
    qty?: IntWithAggregatesFilter<"OrderItem"> | number
    price?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    sellerId?: StringWithAggregatesFilter<"OrderItem"> | string
    grossAmount?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    payoutStatus?: EnumPayoutStatusWithAggregatesFilter<"OrderItem"> | $Enums.PayoutStatus
    payoutBatchId?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"OrderItem"> | Date | string | null
    currency?: StringWithAggregatesFilter<"OrderItem"> | string
    fulfillmentStatus?: EnumFulfillmentStatusWithAggregatesFilter<"OrderItem"> | $Enums.FulfillmentStatus
    shippedAt?: DateTimeNullableWithAggregatesFilter<"OrderItem"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"OrderItem"> | Date | string | null
    trackingCode?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    carrier?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    deliveryProofUrl?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    notes?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    exceptionNotified?: BoolNullableWithAggregatesFilter<"OrderItem"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    orderId?: StringFilter<"Payment"> | string
    provider?: StringFilter<"Payment"> | string
    externalRef?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    externalRef?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    provider?: StringFilter<"Payment"> | string
    externalRef?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id" | "orderId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    externalRef?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    orderId?: StringWithAggregatesFilter<"Payment"> | string
    provider?: StringWithAggregatesFilter<"Payment"> | string
    externalRef?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type FulfillmentSettingsWhereInput = {
    AND?: FulfillmentSettingsWhereInput | FulfillmentSettingsWhereInput[]
    OR?: FulfillmentSettingsWhereInput[]
    NOT?: FulfillmentSettingsWhereInput | FulfillmentSettingsWhereInput[]
    id?: StringFilter<"FulfillmentSettings"> | string
    sellerId?: StringFilter<"FulfillmentSettings"> | string
    usesMicroFulfillment?: BoolFilter<"FulfillmentSettings"> | boolean
    microFulfillmentPartnerId?: StringNullableFilter<"FulfillmentSettings"> | string | null
    microFulfillmentOptInDate?: DateTimeNullableFilter<"FulfillmentSettings"> | Date | string | null
    createdAt?: DateTimeFilter<"FulfillmentSettings"> | Date | string
    updatedAt?: DateTimeFilter<"FulfillmentSettings"> | Date | string
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FulfillmentSettingsOrderByWithRelationInput = {
    id?: SortOrder
    sellerId?: SortOrder
    usesMicroFulfillment?: SortOrder
    microFulfillmentPartnerId?: SortOrderInput | SortOrder
    microFulfillmentOptInDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seller?: UserOrderByWithRelationInput
  }

  export type FulfillmentSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sellerId?: string
    AND?: FulfillmentSettingsWhereInput | FulfillmentSettingsWhereInput[]
    OR?: FulfillmentSettingsWhereInput[]
    NOT?: FulfillmentSettingsWhereInput | FulfillmentSettingsWhereInput[]
    usesMicroFulfillment?: BoolFilter<"FulfillmentSettings"> | boolean
    microFulfillmentPartnerId?: StringNullableFilter<"FulfillmentSettings"> | string | null
    microFulfillmentOptInDate?: DateTimeNullableFilter<"FulfillmentSettings"> | Date | string | null
    createdAt?: DateTimeFilter<"FulfillmentSettings"> | Date | string
    updatedAt?: DateTimeFilter<"FulfillmentSettings"> | Date | string
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sellerId">

  export type FulfillmentSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    sellerId?: SortOrder
    usesMicroFulfillment?: SortOrder
    microFulfillmentPartnerId?: SortOrderInput | SortOrder
    microFulfillmentOptInDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FulfillmentSettingsCountOrderByAggregateInput
    _max?: FulfillmentSettingsMaxOrderByAggregateInput
    _min?: FulfillmentSettingsMinOrderByAggregateInput
  }

  export type FulfillmentSettingsScalarWhereWithAggregatesInput = {
    AND?: FulfillmentSettingsScalarWhereWithAggregatesInput | FulfillmentSettingsScalarWhereWithAggregatesInput[]
    OR?: FulfillmentSettingsScalarWhereWithAggregatesInput[]
    NOT?: FulfillmentSettingsScalarWhereWithAggregatesInput | FulfillmentSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FulfillmentSettings"> | string
    sellerId?: StringWithAggregatesFilter<"FulfillmentSettings"> | string
    usesMicroFulfillment?: BoolWithAggregatesFilter<"FulfillmentSettings"> | boolean
    microFulfillmentPartnerId?: StringNullableWithAggregatesFilter<"FulfillmentSettings"> | string | null
    microFulfillmentOptInDate?: DateTimeNullableWithAggregatesFilter<"FulfillmentSettings"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FulfillmentSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FulfillmentSettings"> | Date | string
  }

  export type KYCDocumentWhereInput = {
    AND?: KYCDocumentWhereInput | KYCDocumentWhereInput[]
    OR?: KYCDocumentWhereInput[]
    NOT?: KYCDocumentWhereInput | KYCDocumentWhereInput[]
    id?: StringFilter<"KYCDocument"> | string
    sellerId?: StringFilter<"KYCDocument"> | string
    documentType?: StringFilter<"KYCDocument"> | string
    documentNumber?: StringFilter<"KYCDocument"> | string
    documentUrl?: StringFilter<"KYCDocument"> | string
    country?: StringFilter<"KYCDocument"> | string
    status?: EnumKYCStatusFilter<"KYCDocument"> | $Enums.KYCStatus
    notes?: StringNullableFilter<"KYCDocument"> | string | null
    createdAt?: DateTimeFilter<"KYCDocument"> | Date | string
    updatedAt?: DateTimeFilter<"KYCDocument"> | Date | string
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type KYCDocumentOrderByWithRelationInput = {
    id?: SortOrder
    sellerId?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    documentUrl?: SortOrder
    country?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seller?: UserOrderByWithRelationInput
  }

  export type KYCDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KYCDocumentWhereInput | KYCDocumentWhereInput[]
    OR?: KYCDocumentWhereInput[]
    NOT?: KYCDocumentWhereInput | KYCDocumentWhereInput[]
    sellerId?: StringFilter<"KYCDocument"> | string
    documentType?: StringFilter<"KYCDocument"> | string
    documentNumber?: StringFilter<"KYCDocument"> | string
    documentUrl?: StringFilter<"KYCDocument"> | string
    country?: StringFilter<"KYCDocument"> | string
    status?: EnumKYCStatusFilter<"KYCDocument"> | $Enums.KYCStatus
    notes?: StringNullableFilter<"KYCDocument"> | string | null
    createdAt?: DateTimeFilter<"KYCDocument"> | Date | string
    updatedAt?: DateTimeFilter<"KYCDocument"> | Date | string
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type KYCDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    sellerId?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    documentUrl?: SortOrder
    country?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KYCDocumentCountOrderByAggregateInput
    _max?: KYCDocumentMaxOrderByAggregateInput
    _min?: KYCDocumentMinOrderByAggregateInput
  }

  export type KYCDocumentScalarWhereWithAggregatesInput = {
    AND?: KYCDocumentScalarWhereWithAggregatesInput | KYCDocumentScalarWhereWithAggregatesInput[]
    OR?: KYCDocumentScalarWhereWithAggregatesInput[]
    NOT?: KYCDocumentScalarWhereWithAggregatesInput | KYCDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KYCDocument"> | string
    sellerId?: StringWithAggregatesFilter<"KYCDocument"> | string
    documentType?: StringWithAggregatesFilter<"KYCDocument"> | string
    documentNumber?: StringWithAggregatesFilter<"KYCDocument"> | string
    documentUrl?: StringWithAggregatesFilter<"KYCDocument"> | string
    country?: StringWithAggregatesFilter<"KYCDocument"> | string
    status?: EnumKYCStatusWithAggregatesFilter<"KYCDocument"> | $Enums.KYCStatus
    notes?: StringNullableWithAggregatesFilter<"KYCDocument"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"KYCDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KYCDocument"> | Date | string
  }

  export type TaxRegistrationWhereInput = {
    AND?: TaxRegistrationWhereInput | TaxRegistrationWhereInput[]
    OR?: TaxRegistrationWhereInput[]
    NOT?: TaxRegistrationWhereInput | TaxRegistrationWhereInput[]
    id?: StringFilter<"TaxRegistration"> | string
    sellerId?: StringFilter<"TaxRegistration"> | string
    taxId?: StringFilter<"TaxRegistration"> | string
    country?: StringFilter<"TaxRegistration"> | string
    status?: EnumTaxStatusFilter<"TaxRegistration"> | $Enums.TaxStatus
    expiryDate?: DateTimeNullableFilter<"TaxRegistration"> | Date | string | null
    createdAt?: DateTimeFilter<"TaxRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"TaxRegistration"> | Date | string
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TaxRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    sellerId?: SortOrder
    taxId?: SortOrder
    country?: SortOrder
    status?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seller?: UserOrderByWithRelationInput
  }

  export type TaxRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaxRegistrationWhereInput | TaxRegistrationWhereInput[]
    OR?: TaxRegistrationWhereInput[]
    NOT?: TaxRegistrationWhereInput | TaxRegistrationWhereInput[]
    sellerId?: StringFilter<"TaxRegistration"> | string
    taxId?: StringFilter<"TaxRegistration"> | string
    country?: StringFilter<"TaxRegistration"> | string
    status?: EnumTaxStatusFilter<"TaxRegistration"> | $Enums.TaxStatus
    expiryDate?: DateTimeNullableFilter<"TaxRegistration"> | Date | string | null
    createdAt?: DateTimeFilter<"TaxRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"TaxRegistration"> | Date | string
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TaxRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    sellerId?: SortOrder
    taxId?: SortOrder
    country?: SortOrder
    status?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaxRegistrationCountOrderByAggregateInput
    _max?: TaxRegistrationMaxOrderByAggregateInput
    _min?: TaxRegistrationMinOrderByAggregateInput
  }

  export type TaxRegistrationScalarWhereWithAggregatesInput = {
    AND?: TaxRegistrationScalarWhereWithAggregatesInput | TaxRegistrationScalarWhereWithAggregatesInput[]
    OR?: TaxRegistrationScalarWhereWithAggregatesInput[]
    NOT?: TaxRegistrationScalarWhereWithAggregatesInput | TaxRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaxRegistration"> | string
    sellerId?: StringWithAggregatesFilter<"TaxRegistration"> | string
    taxId?: StringWithAggregatesFilter<"TaxRegistration"> | string
    country?: StringWithAggregatesFilter<"TaxRegistration"> | string
    status?: EnumTaxStatusWithAggregatesFilter<"TaxRegistration"> | $Enums.TaxStatus
    expiryDate?: DateTimeNullableWithAggregatesFilter<"TaxRegistration"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TaxRegistration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaxRegistration"> | Date | string
  }

  export type CounterfeitReportWhereInput = {
    AND?: CounterfeitReportWhereInput | CounterfeitReportWhereInput[]
    OR?: CounterfeitReportWhereInput[]
    NOT?: CounterfeitReportWhereInput | CounterfeitReportWhereInput[]
    id?: StringFilter<"CounterfeitReport"> | string
    reporterId?: StringFilter<"CounterfeitReport"> | string
    productId?: StringFilter<"CounterfeitReport"> | string
    reason?: StringFilter<"CounterfeitReport"> | string
    evidenceUrl?: StringNullableFilter<"CounterfeitReport"> | string | null
    status?: EnumReportStatusFilter<"CounterfeitReport"> | $Enums.ReportStatus
    resolution?: StringNullableFilter<"CounterfeitReport"> | string | null
    createdAt?: DateTimeFilter<"CounterfeitReport"> | Date | string
    updatedAt?: DateTimeFilter<"CounterfeitReport"> | Date | string
    reporter?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type CounterfeitReportOrderByWithRelationInput = {
    id?: SortOrder
    reporterId?: SortOrder
    productId?: SortOrder
    reason?: SortOrder
    evidenceUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    resolution?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reporter?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type CounterfeitReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CounterfeitReportWhereInput | CounterfeitReportWhereInput[]
    OR?: CounterfeitReportWhereInput[]
    NOT?: CounterfeitReportWhereInput | CounterfeitReportWhereInput[]
    reporterId?: StringFilter<"CounterfeitReport"> | string
    productId?: StringFilter<"CounterfeitReport"> | string
    reason?: StringFilter<"CounterfeitReport"> | string
    evidenceUrl?: StringNullableFilter<"CounterfeitReport"> | string | null
    status?: EnumReportStatusFilter<"CounterfeitReport"> | $Enums.ReportStatus
    resolution?: StringNullableFilter<"CounterfeitReport"> | string | null
    createdAt?: DateTimeFilter<"CounterfeitReport"> | Date | string
    updatedAt?: DateTimeFilter<"CounterfeitReport"> | Date | string
    reporter?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type CounterfeitReportOrderByWithAggregationInput = {
    id?: SortOrder
    reporterId?: SortOrder
    productId?: SortOrder
    reason?: SortOrder
    evidenceUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    resolution?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CounterfeitReportCountOrderByAggregateInput
    _max?: CounterfeitReportMaxOrderByAggregateInput
    _min?: CounterfeitReportMinOrderByAggregateInput
  }

  export type CounterfeitReportScalarWhereWithAggregatesInput = {
    AND?: CounterfeitReportScalarWhereWithAggregatesInput | CounterfeitReportScalarWhereWithAggregatesInput[]
    OR?: CounterfeitReportScalarWhereWithAggregatesInput[]
    NOT?: CounterfeitReportScalarWhereWithAggregatesInput | CounterfeitReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CounterfeitReport"> | string
    reporterId?: StringWithAggregatesFilter<"CounterfeitReport"> | string
    productId?: StringWithAggregatesFilter<"CounterfeitReport"> | string
    reason?: StringWithAggregatesFilter<"CounterfeitReport"> | string
    evidenceUrl?: StringNullableWithAggregatesFilter<"CounterfeitReport"> | string | null
    status?: EnumReportStatusWithAggregatesFilter<"CounterfeitReport"> | $Enums.ReportStatus
    resolution?: StringNullableWithAggregatesFilter<"CounterfeitReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CounterfeitReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CounterfeitReport"> | Date | string
  }

  export type SellerApplicationWhereInput = {
    AND?: SellerApplicationWhereInput | SellerApplicationWhereInput[]
    OR?: SellerApplicationWhereInput[]
    NOT?: SellerApplicationWhereInput | SellerApplicationWhereInput[]
    id?: StringFilter<"SellerApplication"> | string
    userId?: StringFilter<"SellerApplication"> | string
    businessName?: StringFilter<"SellerApplication"> | string
    phone?: StringFilter<"SellerApplication"> | string
    country?: StringFilter<"SellerApplication"> | string
    city?: StringFilter<"SellerApplication"> | string
    storefrontDesc?: StringFilter<"SellerApplication"> | string
    bankName?: StringNullableFilter<"SellerApplication"> | string | null
    accountNumber?: StringNullableFilter<"SellerApplication"> | string | null
    accountName?: StringNullableFilter<"SellerApplication"> | string | null
    bankCode?: StringNullableFilter<"SellerApplication"> | string | null
    status?: EnumApplicationStatusFilter<"SellerApplication"> | $Enums.ApplicationStatus
    adminNote?: StringNullableFilter<"SellerApplication"> | string | null
    reviewedAt?: DateTimeNullableFilter<"SellerApplication"> | Date | string | null
    createdAt?: DateTimeFilter<"SellerApplication"> | Date | string
    updatedAt?: DateTimeFilter<"SellerApplication"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SellerApplicationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    city?: SortOrder
    storefrontDesc?: SortOrder
    bankName?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    accountName?: SortOrderInput | SortOrder
    bankCode?: SortOrderInput | SortOrder
    status?: SortOrder
    adminNote?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SellerApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SellerApplicationWhereInput | SellerApplicationWhereInput[]
    OR?: SellerApplicationWhereInput[]
    NOT?: SellerApplicationWhereInput | SellerApplicationWhereInput[]
    businessName?: StringFilter<"SellerApplication"> | string
    phone?: StringFilter<"SellerApplication"> | string
    country?: StringFilter<"SellerApplication"> | string
    city?: StringFilter<"SellerApplication"> | string
    storefrontDesc?: StringFilter<"SellerApplication"> | string
    bankName?: StringNullableFilter<"SellerApplication"> | string | null
    accountNumber?: StringNullableFilter<"SellerApplication"> | string | null
    accountName?: StringNullableFilter<"SellerApplication"> | string | null
    bankCode?: StringNullableFilter<"SellerApplication"> | string | null
    status?: EnumApplicationStatusFilter<"SellerApplication"> | $Enums.ApplicationStatus
    adminNote?: StringNullableFilter<"SellerApplication"> | string | null
    reviewedAt?: DateTimeNullableFilter<"SellerApplication"> | Date | string | null
    createdAt?: DateTimeFilter<"SellerApplication"> | Date | string
    updatedAt?: DateTimeFilter<"SellerApplication"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type SellerApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    city?: SortOrder
    storefrontDesc?: SortOrder
    bankName?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    accountName?: SortOrderInput | SortOrder
    bankCode?: SortOrderInput | SortOrder
    status?: SortOrder
    adminNote?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SellerApplicationCountOrderByAggregateInput
    _max?: SellerApplicationMaxOrderByAggregateInput
    _min?: SellerApplicationMinOrderByAggregateInput
  }

  export type SellerApplicationScalarWhereWithAggregatesInput = {
    AND?: SellerApplicationScalarWhereWithAggregatesInput | SellerApplicationScalarWhereWithAggregatesInput[]
    OR?: SellerApplicationScalarWhereWithAggregatesInput[]
    NOT?: SellerApplicationScalarWhereWithAggregatesInput | SellerApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SellerApplication"> | string
    userId?: StringWithAggregatesFilter<"SellerApplication"> | string
    businessName?: StringWithAggregatesFilter<"SellerApplication"> | string
    phone?: StringWithAggregatesFilter<"SellerApplication"> | string
    country?: StringWithAggregatesFilter<"SellerApplication"> | string
    city?: StringWithAggregatesFilter<"SellerApplication"> | string
    storefrontDesc?: StringWithAggregatesFilter<"SellerApplication"> | string
    bankName?: StringNullableWithAggregatesFilter<"SellerApplication"> | string | null
    accountNumber?: StringNullableWithAggregatesFilter<"SellerApplication"> | string | null
    accountName?: StringNullableWithAggregatesFilter<"SellerApplication"> | string | null
    bankCode?: StringNullableWithAggregatesFilter<"SellerApplication"> | string | null
    status?: EnumApplicationStatusWithAggregatesFilter<"SellerApplication"> | $Enums.ApplicationStatus
    adminNote?: StringNullableWithAggregatesFilter<"SellerApplication"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"SellerApplication"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SellerApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SellerApplication"> | Date | string
  }

  export type DisputeWhereInput = {
    AND?: DisputeWhereInput | DisputeWhereInput[]
    OR?: DisputeWhereInput[]
    NOT?: DisputeWhereInput | DisputeWhereInput[]
    id?: StringFilter<"Dispute"> | string
    orderItemId?: StringFilter<"Dispute"> | string
    buyerId?: StringFilter<"Dispute"> | string
    reasonCode?: EnumDisputeReasonFilter<"Dispute"> | $Enums.DisputeReason
    description?: StringFilter<"Dispute"> | string
    photoProofUrl?: StringNullableFilter<"Dispute"> | string | null
    status?: EnumDisputeStatusFilter<"Dispute"> | $Enums.DisputeStatus
    resolutionNote?: StringNullableFilter<"Dispute"> | string | null
    resolvedById?: StringNullableFilter<"Dispute"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Dispute"> | Date | string | null
    createdAt?: DateTimeFilter<"Dispute"> | Date | string
    updatedAt?: DateTimeFilter<"Dispute"> | Date | string
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
    buyer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DisputeOrderByWithRelationInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    buyerId?: SortOrder
    reasonCode?: SortOrder
    description?: SortOrder
    photoProofUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    resolutionNote?: SortOrderInput | SortOrder
    resolvedById?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderItem?: OrderItemOrderByWithRelationInput
    buyer?: UserOrderByWithRelationInput
  }

  export type DisputeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DisputeWhereInput | DisputeWhereInput[]
    OR?: DisputeWhereInput[]
    NOT?: DisputeWhereInput | DisputeWhereInput[]
    orderItemId?: StringFilter<"Dispute"> | string
    buyerId?: StringFilter<"Dispute"> | string
    reasonCode?: EnumDisputeReasonFilter<"Dispute"> | $Enums.DisputeReason
    description?: StringFilter<"Dispute"> | string
    photoProofUrl?: StringNullableFilter<"Dispute"> | string | null
    status?: EnumDisputeStatusFilter<"Dispute"> | $Enums.DisputeStatus
    resolutionNote?: StringNullableFilter<"Dispute"> | string | null
    resolvedById?: StringNullableFilter<"Dispute"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Dispute"> | Date | string | null
    createdAt?: DateTimeFilter<"Dispute"> | Date | string
    updatedAt?: DateTimeFilter<"Dispute"> | Date | string
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
    buyer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DisputeOrderByWithAggregationInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    buyerId?: SortOrder
    reasonCode?: SortOrder
    description?: SortOrder
    photoProofUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    resolutionNote?: SortOrderInput | SortOrder
    resolvedById?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DisputeCountOrderByAggregateInput
    _max?: DisputeMaxOrderByAggregateInput
    _min?: DisputeMinOrderByAggregateInput
  }

  export type DisputeScalarWhereWithAggregatesInput = {
    AND?: DisputeScalarWhereWithAggregatesInput | DisputeScalarWhereWithAggregatesInput[]
    OR?: DisputeScalarWhereWithAggregatesInput[]
    NOT?: DisputeScalarWhereWithAggregatesInput | DisputeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dispute"> | string
    orderItemId?: StringWithAggregatesFilter<"Dispute"> | string
    buyerId?: StringWithAggregatesFilter<"Dispute"> | string
    reasonCode?: EnumDisputeReasonWithAggregatesFilter<"Dispute"> | $Enums.DisputeReason
    description?: StringWithAggregatesFilter<"Dispute"> | string
    photoProofUrl?: StringNullableWithAggregatesFilter<"Dispute"> | string | null
    status?: EnumDisputeStatusWithAggregatesFilter<"Dispute"> | $Enums.DisputeStatus
    resolutionNote?: StringNullableWithAggregatesFilter<"Dispute"> | string | null
    resolvedById?: StringNullableWithAggregatesFilter<"Dispute"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Dispute"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Dispute"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Dispute"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    orderItemId?: StringFilter<"Review"> | string
    sellerId?: StringFilter<"Review"> | string
    buyerId?: StringFilter<"Review"> | string
    productId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringFilter<"Review"> | string
    isVisible?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
    buyer?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    isVisible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderItem?: OrderItemOrderByWithRelationInput
    seller?: UserOrderByWithRelationInput
    buyer?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    orderItemId?: StringFilter<"Review"> | string
    sellerId?: StringFilter<"Review"> | string
    buyerId?: StringFilter<"Review"> | string
    productId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringFilter<"Review"> | string
    isVisible?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
    buyer?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    isVisible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    orderItemId?: StringWithAggregatesFilter<"Review"> | string
    sellerId?: StringWithAggregatesFilter<"Review"> | string
    buyerId?: StringWithAggregatesFilter<"Review"> | string
    productId?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringWithAggregatesFilter<"Review"> | string
    isVisible?: BoolWithAggregatesFilter<"Review"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type CommunityStoryWhereInput = {
    AND?: CommunityStoryWhereInput | CommunityStoryWhereInput[]
    OR?: CommunityStoryWhereInput[]
    NOT?: CommunityStoryWhereInput | CommunityStoryWhereInput[]
    id?: StringFilter<"CommunityStory"> | string
    userId?: StringFilter<"CommunityStory"> | string
    productId?: StringFilter<"CommunityStory"> | string
    content?: StringFilter<"CommunityStory"> | string
    imageUrl?: StringNullableFilter<"CommunityStory"> | string | null
    createdAt?: DateTimeFilter<"CommunityStory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type CommunityStoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type CommunityStoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommunityStoryWhereInput | CommunityStoryWhereInput[]
    OR?: CommunityStoryWhereInput[]
    NOT?: CommunityStoryWhereInput | CommunityStoryWhereInput[]
    userId?: StringFilter<"CommunityStory"> | string
    productId?: StringFilter<"CommunityStory"> | string
    content?: StringFilter<"CommunityStory"> | string
    imageUrl?: StringNullableFilter<"CommunityStory"> | string | null
    createdAt?: DateTimeFilter<"CommunityStory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type CommunityStoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CommunityStoryCountOrderByAggregateInput
    _max?: CommunityStoryMaxOrderByAggregateInput
    _min?: CommunityStoryMinOrderByAggregateInput
  }

  export type CommunityStoryScalarWhereWithAggregatesInput = {
    AND?: CommunityStoryScalarWhereWithAggregatesInput | CommunityStoryScalarWhereWithAggregatesInput[]
    OR?: CommunityStoryScalarWhereWithAggregatesInput[]
    NOT?: CommunityStoryScalarWhereWithAggregatesInput | CommunityStoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommunityStory"> | string
    userId?: StringWithAggregatesFilter<"CommunityStory"> | string
    productId?: StringWithAggregatesFilter<"CommunityStory"> | string
    content?: StringWithAggregatesFilter<"CommunityStory"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"CommunityStory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CommunityStory"> | Date | string
  }

  export type ProductViewWhereInput = {
    AND?: ProductViewWhereInput | ProductViewWhereInput[]
    OR?: ProductViewWhereInput[]
    NOT?: ProductViewWhereInput | ProductViewWhereInput[]
    id?: StringFilter<"ProductView"> | string
    userId?: StringFilter<"ProductView"> | string
    productId?: StringFilter<"ProductView"> | string
    timestamp?: DateTimeFilter<"ProductView"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductViewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ProductViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductViewWhereInput | ProductViewWhereInput[]
    OR?: ProductViewWhereInput[]
    NOT?: ProductViewWhereInput | ProductViewWhereInput[]
    userId?: StringFilter<"ProductView"> | string
    productId?: StringFilter<"ProductView"> | string
    timestamp?: DateTimeFilter<"ProductView"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductViewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    timestamp?: SortOrder
    _count?: ProductViewCountOrderByAggregateInput
    _max?: ProductViewMaxOrderByAggregateInput
    _min?: ProductViewMinOrderByAggregateInput
  }

  export type ProductViewScalarWhereWithAggregatesInput = {
    AND?: ProductViewScalarWhereWithAggregatesInput | ProductViewScalarWhereWithAggregatesInput[]
    OR?: ProductViewScalarWhereWithAggregatesInput[]
    NOT?: ProductViewScalarWhereWithAggregatesInput | ProductViewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductView"> | string
    userId?: StringWithAggregatesFilter<"ProductView"> | string
    productId?: StringWithAggregatesFilter<"ProductView"> | string
    timestamp?: DateTimeWithAggregatesFilter<"ProductView"> | Date | string
  }

  export type SponsoredPlacementWhereInput = {
    AND?: SponsoredPlacementWhereInput | SponsoredPlacementWhereInput[]
    OR?: SponsoredPlacementWhereInput[]
    NOT?: SponsoredPlacementWhereInput | SponsoredPlacementWhereInput[]
    id?: StringFilter<"SponsoredPlacement"> | string
    sellerId?: StringFilter<"SponsoredPlacement"> | string
    productId?: StringFilter<"SponsoredPlacement"> | string
    categorySlug?: StringNullableFilter<"SponsoredPlacement"> | string | null
    searchTerm?: StringNullableFilter<"SponsoredPlacement"> | string | null
    bidAmount?: DecimalFilter<"SponsoredPlacement"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFilter<"SponsoredPlacement"> | Date | string
    endDate?: DateTimeFilter<"SponsoredPlacement"> | Date | string
    status?: EnumSponsoredPlacementStatusFilter<"SponsoredPlacement"> | $Enums.SponsoredPlacementStatus
    createdAt?: DateTimeFilter<"SponsoredPlacement"> | Date | string
    updatedAt?: DateTimeFilter<"SponsoredPlacement"> | Date | string
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type SponsoredPlacementOrderByWithRelationInput = {
    id?: SortOrder
    sellerId?: SortOrder
    productId?: SortOrder
    categorySlug?: SortOrderInput | SortOrder
    searchTerm?: SortOrderInput | SortOrder
    bidAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seller?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type SponsoredPlacementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SponsoredPlacementWhereInput | SponsoredPlacementWhereInput[]
    OR?: SponsoredPlacementWhereInput[]
    NOT?: SponsoredPlacementWhereInput | SponsoredPlacementWhereInput[]
    sellerId?: StringFilter<"SponsoredPlacement"> | string
    productId?: StringFilter<"SponsoredPlacement"> | string
    categorySlug?: StringNullableFilter<"SponsoredPlacement"> | string | null
    searchTerm?: StringNullableFilter<"SponsoredPlacement"> | string | null
    bidAmount?: DecimalFilter<"SponsoredPlacement"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFilter<"SponsoredPlacement"> | Date | string
    endDate?: DateTimeFilter<"SponsoredPlacement"> | Date | string
    status?: EnumSponsoredPlacementStatusFilter<"SponsoredPlacement"> | $Enums.SponsoredPlacementStatus
    createdAt?: DateTimeFilter<"SponsoredPlacement"> | Date | string
    updatedAt?: DateTimeFilter<"SponsoredPlacement"> | Date | string
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type SponsoredPlacementOrderByWithAggregationInput = {
    id?: SortOrder
    sellerId?: SortOrder
    productId?: SortOrder
    categorySlug?: SortOrderInput | SortOrder
    searchTerm?: SortOrderInput | SortOrder
    bidAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SponsoredPlacementCountOrderByAggregateInput
    _avg?: SponsoredPlacementAvgOrderByAggregateInput
    _max?: SponsoredPlacementMaxOrderByAggregateInput
    _min?: SponsoredPlacementMinOrderByAggregateInput
    _sum?: SponsoredPlacementSumOrderByAggregateInput
  }

  export type SponsoredPlacementScalarWhereWithAggregatesInput = {
    AND?: SponsoredPlacementScalarWhereWithAggregatesInput | SponsoredPlacementScalarWhereWithAggregatesInput[]
    OR?: SponsoredPlacementScalarWhereWithAggregatesInput[]
    NOT?: SponsoredPlacementScalarWhereWithAggregatesInput | SponsoredPlacementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SponsoredPlacement"> | string
    sellerId?: StringWithAggregatesFilter<"SponsoredPlacement"> | string
    productId?: StringWithAggregatesFilter<"SponsoredPlacement"> | string
    categorySlug?: StringNullableWithAggregatesFilter<"SponsoredPlacement"> | string | null
    searchTerm?: StringNullableWithAggregatesFilter<"SponsoredPlacement"> | string | null
    bidAmount?: DecimalWithAggregatesFilter<"SponsoredPlacement"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeWithAggregatesFilter<"SponsoredPlacement"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"SponsoredPlacement"> | Date | string
    status?: EnumSponsoredPlacementStatusWithAggregatesFilter<"SponsoredPlacement"> | $Enums.SponsoredPlacementStatus
    createdAt?: DateTimeWithAggregatesFilter<"SponsoredPlacement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SponsoredPlacement"> | Date | string
  }

  export type SellerServiceWhereInput = {
    AND?: SellerServiceWhereInput | SellerServiceWhereInput[]
    OR?: SellerServiceWhereInput[]
    NOT?: SellerServiceWhereInput | SellerServiceWhereInput[]
    id?: StringFilter<"SellerService"> | string
    sellerId?: StringFilter<"SellerService"> | string
    title?: StringFilter<"SellerService"> | string
    description?: StringFilter<"SellerService"> | string
    price?: DecimalFilter<"SellerService"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SellerService"> | string
    category?: StringFilter<"SellerService"> | string
    deliveryTime?: IntFilter<"SellerService"> | number
    active?: BoolFilter<"SellerService"> | boolean
    createdAt?: DateTimeFilter<"SellerService"> | Date | string
    updatedAt?: DateTimeFilter<"SellerService"> | Date | string
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
    orders?: ServiceOrderListRelationFilter
  }

  export type SellerServiceOrderByWithRelationInput = {
    id?: SortOrder
    sellerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    category?: SortOrder
    deliveryTime?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seller?: UserOrderByWithRelationInput
    orders?: ServiceOrderOrderByRelationAggregateInput
  }

  export type SellerServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SellerServiceWhereInput | SellerServiceWhereInput[]
    OR?: SellerServiceWhereInput[]
    NOT?: SellerServiceWhereInput | SellerServiceWhereInput[]
    sellerId?: StringFilter<"SellerService"> | string
    title?: StringFilter<"SellerService"> | string
    description?: StringFilter<"SellerService"> | string
    price?: DecimalFilter<"SellerService"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SellerService"> | string
    category?: StringFilter<"SellerService"> | string
    deliveryTime?: IntFilter<"SellerService"> | number
    active?: BoolFilter<"SellerService"> | boolean
    createdAt?: DateTimeFilter<"SellerService"> | Date | string
    updatedAt?: DateTimeFilter<"SellerService"> | Date | string
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
    orders?: ServiceOrderListRelationFilter
  }, "id">

  export type SellerServiceOrderByWithAggregationInput = {
    id?: SortOrder
    sellerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    category?: SortOrder
    deliveryTime?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SellerServiceCountOrderByAggregateInput
    _avg?: SellerServiceAvgOrderByAggregateInput
    _max?: SellerServiceMaxOrderByAggregateInput
    _min?: SellerServiceMinOrderByAggregateInput
    _sum?: SellerServiceSumOrderByAggregateInput
  }

  export type SellerServiceScalarWhereWithAggregatesInput = {
    AND?: SellerServiceScalarWhereWithAggregatesInput | SellerServiceScalarWhereWithAggregatesInput[]
    OR?: SellerServiceScalarWhereWithAggregatesInput[]
    NOT?: SellerServiceScalarWhereWithAggregatesInput | SellerServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SellerService"> | string
    sellerId?: StringWithAggregatesFilter<"SellerService"> | string
    title?: StringWithAggregatesFilter<"SellerService"> | string
    description?: StringWithAggregatesFilter<"SellerService"> | string
    price?: DecimalWithAggregatesFilter<"SellerService"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"SellerService"> | string
    category?: StringWithAggregatesFilter<"SellerService"> | string
    deliveryTime?: IntWithAggregatesFilter<"SellerService"> | number
    active?: BoolWithAggregatesFilter<"SellerService"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SellerService"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SellerService"> | Date | string
  }

  export type ServiceOrderWhereInput = {
    AND?: ServiceOrderWhereInput | ServiceOrderWhereInput[]
    OR?: ServiceOrderWhereInput[]
    NOT?: ServiceOrderWhereInput | ServiceOrderWhereInput[]
    id?: StringFilter<"ServiceOrder"> | string
    serviceId?: StringFilter<"ServiceOrder"> | string
    buyerId?: StringFilter<"ServiceOrder"> | string
    sellerId?: StringFilter<"ServiceOrder"> | string
    message?: StringFilter<"ServiceOrder"> | string
    price?: DecimalFilter<"ServiceOrder"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"ServiceOrder"> | string
    status?: EnumServiceOrderStatusFilter<"ServiceOrder"> | $Enums.ServiceOrderStatus
    note?: StringNullableFilter<"ServiceOrder"> | string | null
    createdAt?: DateTimeFilter<"ServiceOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceOrder"> | Date | string
    service?: XOR<SellerServiceScalarRelationFilter, SellerServiceWhereInput>
    buyer?: XOR<UserScalarRelationFilter, UserWhereInput>
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ServiceOrderOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    message?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    service?: SellerServiceOrderByWithRelationInput
    buyer?: UserOrderByWithRelationInput
    seller?: UserOrderByWithRelationInput
  }

  export type ServiceOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceOrderWhereInput | ServiceOrderWhereInput[]
    OR?: ServiceOrderWhereInput[]
    NOT?: ServiceOrderWhereInput | ServiceOrderWhereInput[]
    serviceId?: StringFilter<"ServiceOrder"> | string
    buyerId?: StringFilter<"ServiceOrder"> | string
    sellerId?: StringFilter<"ServiceOrder"> | string
    message?: StringFilter<"ServiceOrder"> | string
    price?: DecimalFilter<"ServiceOrder"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"ServiceOrder"> | string
    status?: EnumServiceOrderStatusFilter<"ServiceOrder"> | $Enums.ServiceOrderStatus
    note?: StringNullableFilter<"ServiceOrder"> | string | null
    createdAt?: DateTimeFilter<"ServiceOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceOrder"> | Date | string
    service?: XOR<SellerServiceScalarRelationFilter, SellerServiceWhereInput>
    buyer?: XOR<UserScalarRelationFilter, UserWhereInput>
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ServiceOrderOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    message?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceOrderCountOrderByAggregateInput
    _avg?: ServiceOrderAvgOrderByAggregateInput
    _max?: ServiceOrderMaxOrderByAggregateInput
    _min?: ServiceOrderMinOrderByAggregateInput
    _sum?: ServiceOrderSumOrderByAggregateInput
  }

  export type ServiceOrderScalarWhereWithAggregatesInput = {
    AND?: ServiceOrderScalarWhereWithAggregatesInput | ServiceOrderScalarWhereWithAggregatesInput[]
    OR?: ServiceOrderScalarWhereWithAggregatesInput[]
    NOT?: ServiceOrderScalarWhereWithAggregatesInput | ServiceOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceOrder"> | string
    serviceId?: StringWithAggregatesFilter<"ServiceOrder"> | string
    buyerId?: StringWithAggregatesFilter<"ServiceOrder"> | string
    sellerId?: StringWithAggregatesFilter<"ServiceOrder"> | string
    message?: StringWithAggregatesFilter<"ServiceOrder"> | string
    price?: DecimalWithAggregatesFilter<"ServiceOrder"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"ServiceOrder"> | string
    status?: EnumServiceOrderStatusWithAggregatesFilter<"ServiceOrder"> | $Enums.ServiceOrderStatus
    note?: StringNullableWithAggregatesFilter<"ServiceOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceOrder"> | Date | string
  }

  export type SubscriptionPlanWhereInput = {
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    id?: StringFilter<"SubscriptionPlan"> | string
    name?: StringFilter<"SubscriptionPlan"> | string
    description?: StringFilter<"SubscriptionPlan"> | string
    price?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SubscriptionPlan"> | string
    features?: StringNullableListFilter<"SubscriptionPlan">
    active?: BoolFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    subscriptions?: UserSubscriptionListRelationFilter
  }

  export type SubscriptionPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    features?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptions?: UserSubscriptionOrderByRelationAggregateInput
  }

  export type SubscriptionPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    name?: StringFilter<"SubscriptionPlan"> | string
    description?: StringFilter<"SubscriptionPlan"> | string
    price?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SubscriptionPlan"> | string
    features?: StringNullableListFilter<"SubscriptionPlan">
    active?: BoolFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    subscriptions?: UserSubscriptionListRelationFilter
  }, "id">

  export type SubscriptionPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    features?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionPlanCountOrderByAggregateInput
    _avg?: SubscriptionPlanAvgOrderByAggregateInput
    _max?: SubscriptionPlanMaxOrderByAggregateInput
    _min?: SubscriptionPlanMinOrderByAggregateInput
    _sum?: SubscriptionPlanSumOrderByAggregateInput
  }

  export type SubscriptionPlanScalarWhereWithAggregatesInput = {
    AND?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    OR?: SubscriptionPlanScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    name?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    description?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    price?: DecimalWithAggregatesFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    features?: StringNullableListFilter<"SubscriptionPlan">
    active?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
  }

  export type UserSubscriptionWhereInput = {
    AND?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    OR?: UserSubscriptionWhereInput[]
    NOT?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    id?: StringFilter<"UserSubscription"> | string
    userId?: StringFilter<"UserSubscription"> | string
    planId?: StringFilter<"UserSubscription"> | string
    planPrice?: DecimalFilter<"UserSubscription"> | Decimal | DecimalJsLike | number | string
    status?: EnumSubscriptionStatusFilter<"UserSubscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeFilter<"UserSubscription"> | Date | string
    autoRenew?: BoolFilter<"UserSubscription"> | boolean
    paymentMethod?: StringFilter<"UserSubscription"> | string
    cancelledAt?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    createdAt?: DateTimeFilter<"UserSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"UserSubscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    plan?: XOR<SubscriptionPlanScalarRelationFilter, SubscriptionPlanWhereInput>
  }

  export type UserSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    planPrice?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    plan?: SubscriptionPlanOrderByWithRelationInput
  }

  export type UserSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    OR?: UserSubscriptionWhereInput[]
    NOT?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    userId?: StringFilter<"UserSubscription"> | string
    planId?: StringFilter<"UserSubscription"> | string
    planPrice?: DecimalFilter<"UserSubscription"> | Decimal | DecimalJsLike | number | string
    status?: EnumSubscriptionStatusFilter<"UserSubscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeFilter<"UserSubscription"> | Date | string
    autoRenew?: BoolFilter<"UserSubscription"> | boolean
    paymentMethod?: StringFilter<"UserSubscription"> | string
    cancelledAt?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    createdAt?: DateTimeFilter<"UserSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"UserSubscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    plan?: XOR<SubscriptionPlanScalarRelationFilter, SubscriptionPlanWhereInput>
  }, "id">

  export type UserSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    planPrice?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSubscriptionCountOrderByAggregateInput
    _avg?: UserSubscriptionAvgOrderByAggregateInput
    _max?: UserSubscriptionMaxOrderByAggregateInput
    _min?: UserSubscriptionMinOrderByAggregateInput
    _sum?: UserSubscriptionSumOrderByAggregateInput
  }

  export type UserSubscriptionScalarWhereWithAggregatesInput = {
    AND?: UserSubscriptionScalarWhereWithAggregatesInput | UserSubscriptionScalarWhereWithAggregatesInput[]
    OR?: UserSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: UserSubscriptionScalarWhereWithAggregatesInput | UserSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSubscription"> | string
    userId?: StringWithAggregatesFilter<"UserSubscription"> | string
    planId?: StringWithAggregatesFilter<"UserSubscription"> | string
    planPrice?: DecimalWithAggregatesFilter<"UserSubscription"> | Decimal | DecimalJsLike | number | string
    status?: EnumSubscriptionStatusWithAggregatesFilter<"UserSubscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    autoRenew?: BoolWithAggregatesFilter<"UserSubscription"> | boolean
    paymentMethod?: StringWithAggregatesFilter<"UserSubscription"> | string
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"UserSubscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
  }

  export type ApiPartnerWhereInput = {
    AND?: ApiPartnerWhereInput | ApiPartnerWhereInput[]
    OR?: ApiPartnerWhereInput[]
    NOT?: ApiPartnerWhereInput | ApiPartnerWhereInput[]
    id?: StringFilter<"ApiPartner"> | string
    companyName?: StringFilter<"ApiPartner"> | string
    contactEmail?: StringFilter<"ApiPartner"> | string
    apiKeyName?: StringFilter<"ApiPartner"> | string
    apiKey?: StringNullableFilter<"ApiPartner"> | string | null
    status?: EnumPartnerStatusFilter<"ApiPartner"> | $Enums.PartnerStatus
    permissions?: StringNullableListFilter<"ApiPartner">
    apiKeyLastGenerated?: DateTimeNullableFilter<"ApiPartner"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiPartner"> | Date | string
    updatedAt?: DateTimeFilter<"ApiPartner"> | Date | string
  }

  export type ApiPartnerOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactEmail?: SortOrder
    apiKeyName?: SortOrder
    apiKey?: SortOrderInput | SortOrder
    status?: SortOrder
    permissions?: SortOrder
    apiKeyLastGenerated?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiPartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contactEmail?: string
    apiKey?: string
    AND?: ApiPartnerWhereInput | ApiPartnerWhereInput[]
    OR?: ApiPartnerWhereInput[]
    NOT?: ApiPartnerWhereInput | ApiPartnerWhereInput[]
    companyName?: StringFilter<"ApiPartner"> | string
    apiKeyName?: StringFilter<"ApiPartner"> | string
    status?: EnumPartnerStatusFilter<"ApiPartner"> | $Enums.PartnerStatus
    permissions?: StringNullableListFilter<"ApiPartner">
    apiKeyLastGenerated?: DateTimeNullableFilter<"ApiPartner"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiPartner"> | Date | string
    updatedAt?: DateTimeFilter<"ApiPartner"> | Date | string
  }, "id" | "contactEmail" | "apiKey">

  export type ApiPartnerOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactEmail?: SortOrder
    apiKeyName?: SortOrder
    apiKey?: SortOrderInput | SortOrder
    status?: SortOrder
    permissions?: SortOrder
    apiKeyLastGenerated?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApiPartnerCountOrderByAggregateInput
    _max?: ApiPartnerMaxOrderByAggregateInput
    _min?: ApiPartnerMinOrderByAggregateInput
  }

  export type ApiPartnerScalarWhereWithAggregatesInput = {
    AND?: ApiPartnerScalarWhereWithAggregatesInput | ApiPartnerScalarWhereWithAggregatesInput[]
    OR?: ApiPartnerScalarWhereWithAggregatesInput[]
    NOT?: ApiPartnerScalarWhereWithAggregatesInput | ApiPartnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiPartner"> | string
    companyName?: StringWithAggregatesFilter<"ApiPartner"> | string
    contactEmail?: StringWithAggregatesFilter<"ApiPartner"> | string
    apiKeyName?: StringWithAggregatesFilter<"ApiPartner"> | string
    apiKey?: StringNullableWithAggregatesFilter<"ApiPartner"> | string | null
    status?: EnumPartnerStatusWithAggregatesFilter<"ApiPartner"> | $Enums.PartnerStatus
    permissions?: StringNullableListFilter<"ApiPartner">
    apiKeyLastGenerated?: DateTimeNullableWithAggregatesFilter<"ApiPartner"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ApiPartner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiPartner"> | Date | string
  }

  export type WishlistItemWhereInput = {
    AND?: WishlistItemWhereInput | WishlistItemWhereInput[]
    OR?: WishlistItemWhereInput[]
    NOT?: WishlistItemWhereInput | WishlistItemWhereInput[]
    id?: StringFilter<"WishlistItem"> | string
    userId?: StringFilter<"WishlistItem"> | string
    productId?: StringFilter<"WishlistItem"> | string
    addedAt?: DateTimeFilter<"WishlistItem"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type WishlistItemOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    addedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type WishlistItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_productId?: WishlistItemUserIdProductIdCompoundUniqueInput
    AND?: WishlistItemWhereInput | WishlistItemWhereInput[]
    OR?: WishlistItemWhereInput[]
    NOT?: WishlistItemWhereInput | WishlistItemWhereInput[]
    userId?: StringFilter<"WishlistItem"> | string
    productId?: StringFilter<"WishlistItem"> | string
    addedAt?: DateTimeFilter<"WishlistItem"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "userId_productId">

  export type WishlistItemOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    addedAt?: SortOrder
    _count?: WishlistItemCountOrderByAggregateInput
    _max?: WishlistItemMaxOrderByAggregateInput
    _min?: WishlistItemMinOrderByAggregateInput
  }

  export type WishlistItemScalarWhereWithAggregatesInput = {
    AND?: WishlistItemScalarWhereWithAggregatesInput | WishlistItemScalarWhereWithAggregatesInput[]
    OR?: WishlistItemScalarWhereWithAggregatesInput[]
    NOT?: WishlistItemScalarWhereWithAggregatesInput | WishlistItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WishlistItem"> | string
    userId?: StringWithAggregatesFilter<"WishlistItem"> | string
    productId?: StringWithAggregatesFilter<"WishlistItem"> | string
    addedAt?: DateTimeWithAggregatesFilter<"WishlistItem"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    createdById?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: TeamMemberListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    members?: TeamMemberOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    createdById?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: TeamMemberListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    description?: StringNullableWithAggregatesFilter<"Team"> | string | null
    createdById?: StringWithAggregatesFilter<"Team"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    role?: StringFilter<"TeamMember"> | string
    invitedBy?: StringNullableFilter<"TeamMember"> | string | null
    joinedAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamId_userId?: TeamMemberTeamIdUserIdCompoundUniqueInput
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    role?: StringFilter<"TeamMember"> | string
    invitedBy?: StringNullableFilter<"TeamMember"> | string | null
    joinedAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "teamId_userId">

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamMember"> | string
    teamId?: StringWithAggregatesFilter<"TeamMember"> | string
    userId?: StringWithAggregatesFilter<"TeamMember"> | string
    role?: StringWithAggregatesFilter<"TeamMember"> | string
    invitedBy?: StringNullableWithAggregatesFilter<"TeamMember"> | string | null
    joinedAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutProductsInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productReviews?: ReviewCreateNestedManyWithoutProductInput
    stories?: CommunityStoryCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    sellerId: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportUncheckedCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutProductsNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUncheckedUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    sellerId: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateInput = {
    id?: string
    quantity: number
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: string
    productId: string
    quantity: number
    updatedAt?: Date | string
  }

  export type InventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateManyInput = {
    id?: string
    productId: string
    quantity: number
    updatedAt?: Date | string
  }

  export type InventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartCreateInput = {
    id?: string
    anonKey?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCartsInput
    items?: CartItemCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateInput = {
    id?: string
    userId?: string | null
    anonKey?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonKey?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCartsNestedInput
    items?: CartItemUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonKey?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartCreateManyInput = {
    id?: string
    userId?: string | null
    anonKey?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonKey?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonKey?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateInput = {
    id?: string
    qty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cart: CartCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemUncheckedCreateInput = {
    id?: string
    cartId: string
    productId: string
    qty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutCartItemsNestedInput
  }

  export type CartItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateManyInput = {
    id?: string
    cartId: string
    productId: string
    qty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRef?: string | null
    shippingAdr?: string | null
    buyerName?: string | null
    buyerPhone?: string | null
    buyerEmail?: string | null
    user: UserCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    userId: string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRef?: string | null
    shippingAdr?: string | null
    buyerName?: string | null
    buyerPhone?: string | null
    buyerEmail?: string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAdr?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    buyerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    buyerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAdr?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    buyerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    buyerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    userId: string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRef?: string | null
    shippingAdr?: string | null
    buyerName?: string | null
    buyerPhone?: string | null
    buyerEmail?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAdr?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    buyerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    buyerEmail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAdr?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    buyerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    buyerEmail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateInput = {
    id?: string
    qty: number
    price: Decimal | DecimalJsLike | number | string
    sellerId: string
    grossAmount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutStatus?: $Enums.PayoutStatus
    payoutBatchId?: string | null
    paidAt?: Date | string | null
    currency?: string
    fulfillmentStatus?: $Enums.FulfillmentStatus
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    trackingCode?: string | null
    carrier?: string | null
    deliveryProofUrl?: string | null
    notes?: string | null
    exceptionNotified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
    disputes?: DisputeCreateNestedManyWithoutOrderItemInput
    reviews?: ReviewCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    productId: string
    qty: number
    price: Decimal | DecimalJsLike | number | string
    sellerId: string
    grossAmount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutStatus?: $Enums.PayoutStatus
    payoutBatchId?: string | null
    paidAt?: Date | string | null
    currency?: string
    fulfillmentStatus?: $Enums.FulfillmentStatus
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    trackingCode?: string | null
    carrier?: string | null
    deliveryProofUrl?: string | null
    notes?: string | null
    exceptionNotified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disputes?: DisputeUncheckedCreateNestedManyWithoutOrderItemInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerId?: StringFieldUpdateOperationsInput | string
    grossAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutStatus?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fulfillmentStatus?: EnumFulfillmentStatusFieldUpdateOperationsInput | $Enums.FulfillmentStatus
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
    disputes?: DisputeUpdateManyWithoutOrderItemNestedInput
    reviews?: ReviewUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerId?: StringFieldUpdateOperationsInput | string
    grossAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutStatus?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fulfillmentStatus?: EnumFulfillmentStatusFieldUpdateOperationsInput | $Enums.FulfillmentStatus
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disputes?: DisputeUncheckedUpdateManyWithoutOrderItemNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    productId: string
    qty: number
    price: Decimal | DecimalJsLike | number | string
    sellerId: string
    grossAmount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutStatus?: $Enums.PayoutStatus
    payoutBatchId?: string | null
    paidAt?: Date | string | null
    currency?: string
    fulfillmentStatus?: $Enums.FulfillmentStatus
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    trackingCode?: string | null
    carrier?: string | null
    deliveryProofUrl?: string | null
    notes?: string | null
    exceptionNotified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerId?: StringFieldUpdateOperationsInput | string
    grossAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutStatus?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fulfillmentStatus?: EnumFulfillmentStatusFieldUpdateOperationsInput | $Enums.FulfillmentStatus
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerId?: StringFieldUpdateOperationsInput | string
    grossAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutStatus?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fulfillmentStatus?: EnumFulfillmentStatusFieldUpdateOperationsInput | $Enums.FulfillmentStatus
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    provider: string
    externalRef?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    orderId: string
    provider: string
    externalRef?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    orderId: string
    provider: string
    externalRef?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FulfillmentSettingsCreateInput = {
    id?: string
    usesMicroFulfillment?: boolean
    microFulfillmentPartnerId?: string | null
    microFulfillmentOptInDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutFulfillmentSettingsInput
  }

  export type FulfillmentSettingsUncheckedCreateInput = {
    id?: string
    sellerId: string
    usesMicroFulfillment?: boolean
    microFulfillmentPartnerId?: string | null
    microFulfillmentOptInDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FulfillmentSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usesMicroFulfillment?: BoolFieldUpdateOperationsInput | boolean
    microFulfillmentPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    microFulfillmentOptInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutFulfillmentSettingsNestedInput
  }

  export type FulfillmentSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    usesMicroFulfillment?: BoolFieldUpdateOperationsInput | boolean
    microFulfillmentPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    microFulfillmentOptInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FulfillmentSettingsCreateManyInput = {
    id?: string
    sellerId: string
    usesMicroFulfillment?: boolean
    microFulfillmentPartnerId?: string | null
    microFulfillmentOptInDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FulfillmentSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usesMicroFulfillment?: BoolFieldUpdateOperationsInput | boolean
    microFulfillmentPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    microFulfillmentOptInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FulfillmentSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    usesMicroFulfillment?: BoolFieldUpdateOperationsInput | boolean
    microFulfillmentPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    microFulfillmentOptInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCDocumentCreateInput = {
    id?: string
    documentType: string
    documentNumber: string
    documentUrl: string
    country: string
    status?: $Enums.KYCStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutKycDocumentsInput
  }

  export type KYCDocumentUncheckedCreateInput = {
    id?: string
    sellerId: string
    documentType: string
    documentNumber: string
    documentUrl: string
    country: string
    status?: $Enums.KYCStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KYCDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutKycDocumentsNestedInput
  }

  export type KYCDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCDocumentCreateManyInput = {
    id?: string
    sellerId: string
    documentType: string
    documentNumber: string
    documentUrl: string
    country: string
    status?: $Enums.KYCStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KYCDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRegistrationCreateInput = {
    id?: string
    taxId: string
    country: string
    status?: $Enums.TaxStatus
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutTaxRegistrationsInput
  }

  export type TaxRegistrationUncheckedCreateInput = {
    id?: string
    sellerId: string
    taxId: string
    country: string
    status?: $Enums.TaxStatus
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxId?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: EnumTaxStatusFieldUpdateOperationsInput | $Enums.TaxStatus
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutTaxRegistrationsNestedInput
  }

  export type TaxRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    taxId?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: EnumTaxStatusFieldUpdateOperationsInput | $Enums.TaxStatus
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRegistrationCreateManyInput = {
    id?: string
    sellerId: string
    taxId: string
    country: string
    status?: $Enums.TaxStatus
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxId?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: EnumTaxStatusFieldUpdateOperationsInput | $Enums.TaxStatus
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    taxId?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: EnumTaxStatusFieldUpdateOperationsInput | $Enums.TaxStatus
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CounterfeitReportCreateInput = {
    id?: string
    reason: string
    evidenceUrl?: string | null
    status?: $Enums.ReportStatus
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportedProductsInput
    product: ProductCreateNestedOneWithoutReportedInInput
  }

  export type CounterfeitReportUncheckedCreateInput = {
    id?: string
    reporterId: string
    productId: string
    reason: string
    evidenceUrl?: string | null
    status?: $Enums.ReportStatus
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CounterfeitReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportedProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutReportedInNestedInput
  }

  export type CounterfeitReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CounterfeitReportCreateManyInput = {
    id?: string
    reporterId: string
    productId: string
    reason: string
    evidenceUrl?: string | null
    status?: $Enums.ReportStatus
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CounterfeitReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CounterfeitReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerApplicationCreateInput = {
    id?: string
    businessName: string
    phone: string
    country: string
    city: string
    storefrontDesc: string
    bankName?: string | null
    accountNumber?: string | null
    accountName?: string | null
    bankCode?: string | null
    status?: $Enums.ApplicationStatus
    adminNote?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSellerApplicationsInput
  }

  export type SellerApplicationUncheckedCreateInput = {
    id?: string
    userId: string
    businessName: string
    phone: string
    country: string
    city: string
    storefrontDesc: string
    bankName?: string | null
    accountNumber?: string | null
    accountName?: string | null
    bankCode?: string | null
    status?: $Enums.ApplicationStatus
    adminNote?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellerApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    storefrontDesc?: StringFieldUpdateOperationsInput | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSellerApplicationsNestedInput
  }

  export type SellerApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    storefrontDesc?: StringFieldUpdateOperationsInput | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerApplicationCreateManyInput = {
    id?: string
    userId: string
    businessName: string
    phone: string
    country: string
    city: string
    storefrontDesc: string
    bankName?: string | null
    accountNumber?: string | null
    accountName?: string | null
    bankCode?: string | null
    status?: $Enums.ApplicationStatus
    adminNote?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellerApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    storefrontDesc?: StringFieldUpdateOperationsInput | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    storefrontDesc?: StringFieldUpdateOperationsInput | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeCreateInput = {
    id?: string
    reasonCode: $Enums.DisputeReason
    description: string
    photoProofUrl?: string | null
    status?: $Enums.DisputeStatus
    resolutionNote?: string | null
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem: OrderItemCreateNestedOneWithoutDisputesInput
    buyer: UserCreateNestedOneWithoutDisputesInput
  }

  export type DisputeUncheckedCreateInput = {
    id?: string
    orderItemId: string
    buyerId: string
    reasonCode: $Enums.DisputeReason
    description: string
    photoProofUrl?: string | null
    status?: $Enums.DisputeStatus
    resolutionNote?: string | null
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisputeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumDisputeReasonFieldUpdateOperationsInput | $Enums.DisputeReason
    description?: StringFieldUpdateOperationsInput | string
    photoProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUpdateOneRequiredWithoutDisputesNestedInput
    buyer?: UserUpdateOneRequiredWithoutDisputesNestedInput
  }

  export type DisputeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumDisputeReasonFieldUpdateOperationsInput | $Enums.DisputeReason
    description?: StringFieldUpdateOperationsInput | string
    photoProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeCreateManyInput = {
    id?: string
    orderItemId: string
    buyerId: string
    reasonCode: $Enums.DisputeReason
    description: string
    photoProofUrl?: string | null
    status?: $Enums.DisputeStatus
    resolutionNote?: string | null
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisputeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumDisputeReasonFieldUpdateOperationsInput | $Enums.DisputeReason
    description?: StringFieldUpdateOperationsInput | string
    photoProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumDisputeReasonFieldUpdateOperationsInput | $Enums.DisputeReason
    description?: StringFieldUpdateOperationsInput | string
    photoProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem: OrderItemCreateNestedOneWithoutReviewsInput
    seller: UserCreateNestedOneWithoutSellerReviewsInput
    buyer: UserCreateNestedOneWithoutReviewsInput
    product: ProductCreateNestedOneWithoutProductReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    orderItemId: string
    sellerId: string
    buyerId: string
    productId: string
    rating: number
    comment: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUpdateOneRequiredWithoutReviewsNestedInput
    seller?: UserUpdateOneRequiredWithoutSellerReviewsNestedInput
    buyer?: UserUpdateOneRequiredWithoutReviewsNestedInput
    product?: ProductUpdateOneRequiredWithoutProductReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    orderItemId: string
    sellerId: string
    buyerId: string
    productId: string
    rating: number
    comment: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    body: string
    message: string
    type: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    body: string
    message: string
    type: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    body: string
    message: string
    type: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityStoryCreateInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStoriesInput
    product: ProductCreateNestedOneWithoutStoriesInput
  }

  export type CommunityStoryUncheckedCreateInput = {
    id?: string
    userId: string
    productId: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type CommunityStoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStoriesNestedInput
    product?: ProductUpdateOneRequiredWithoutStoriesNestedInput
  }

  export type CommunityStoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityStoryCreateManyInput = {
    id?: string
    userId: string
    productId: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type CommunityStoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityStoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductViewCreateInput = {
    id?: string
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutProductViewsInput
    product: ProductCreateNestedOneWithoutViewsInput
  }

  export type ProductViewUncheckedCreateInput = {
    id?: string
    userId: string
    productId: string
    timestamp?: Date | string
  }

  export type ProductViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProductViewsNestedInput
    product?: ProductUpdateOneRequiredWithoutViewsNestedInput
  }

  export type ProductViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductViewCreateManyInput = {
    id?: string
    userId: string
    productId: string
    timestamp?: Date | string
  }

  export type ProductViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SponsoredPlacementCreateInput = {
    id?: string
    categorySlug?: string | null
    searchTerm?: string | null
    bidAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SponsoredPlacementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutSponsoredPlacementsInput
    product: ProductCreateNestedOneWithoutSponsoredPlacementsInput
  }

  export type SponsoredPlacementUncheckedCreateInput = {
    id?: string
    sellerId: string
    productId: string
    categorySlug?: string | null
    searchTerm?: string | null
    bidAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SponsoredPlacementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SponsoredPlacementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categorySlug?: NullableStringFieldUpdateOperationsInput | string | null
    searchTerm?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSponsoredPlacementStatusFieldUpdateOperationsInput | $Enums.SponsoredPlacementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutSponsoredPlacementsNestedInput
    product?: ProductUpdateOneRequiredWithoutSponsoredPlacementsNestedInput
  }

  export type SponsoredPlacementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    categorySlug?: NullableStringFieldUpdateOperationsInput | string | null
    searchTerm?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSponsoredPlacementStatusFieldUpdateOperationsInput | $Enums.SponsoredPlacementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SponsoredPlacementCreateManyInput = {
    id?: string
    sellerId: string
    productId: string
    categorySlug?: string | null
    searchTerm?: string | null
    bidAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SponsoredPlacementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SponsoredPlacementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    categorySlug?: NullableStringFieldUpdateOperationsInput | string | null
    searchTerm?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSponsoredPlacementStatusFieldUpdateOperationsInput | $Enums.SponsoredPlacementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SponsoredPlacementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    categorySlug?: NullableStringFieldUpdateOperationsInput | string | null
    searchTerm?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSponsoredPlacementStatusFieldUpdateOperationsInput | $Enums.SponsoredPlacementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerServiceCreateInput = {
    id?: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    category: string
    deliveryTime: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutSellerServicesInput
    orders?: ServiceOrderCreateNestedManyWithoutServiceInput
  }

  export type SellerServiceUncheckedCreateInput = {
    id?: string
    sellerId: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    category: string
    deliveryTime: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: ServiceOrderUncheckedCreateNestedManyWithoutServiceInput
  }

  export type SellerServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutSellerServicesNestedInput
    orders?: ServiceOrderUpdateManyWithoutServiceNestedInput
  }

  export type SellerServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: ServiceOrderUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type SellerServiceCreateManyInput = {
    id?: string
    sellerId: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    category: string
    deliveryTime: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellerServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceOrderCreateInput = {
    id?: string
    message: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.ServiceOrderStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service: SellerServiceCreateNestedOneWithoutOrdersInput
    buyer: UserCreateNestedOneWithoutServiceOrdersAsBuyerInput
    seller: UserCreateNestedOneWithoutServiceOrdersAsSellerInput
  }

  export type ServiceOrderUncheckedCreateInput = {
    id?: string
    serviceId: string
    buyerId: string
    sellerId: string
    message: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.ServiceOrderStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceOrderStatusFieldUpdateOperationsInput | $Enums.ServiceOrderStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: SellerServiceUpdateOneRequiredWithoutOrdersNestedInput
    buyer?: UserUpdateOneRequiredWithoutServiceOrdersAsBuyerNestedInput
    seller?: UserUpdateOneRequiredWithoutServiceOrdersAsSellerNestedInput
  }

  export type ServiceOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceOrderStatusFieldUpdateOperationsInput | $Enums.ServiceOrderStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceOrderCreateManyInput = {
    id?: string
    serviceId: string
    buyerId: string
    sellerId: string
    message: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.ServiceOrderStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceOrderStatusFieldUpdateOperationsInput | $Enums.ServiceOrderStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceOrderStatusFieldUpdateOperationsInput | $Enums.ServiceOrderStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanCreateInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    features?: SubscriptionPlanCreatefeaturesInput | string[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: UserSubscriptionCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    features?: SubscriptionPlanCreatefeaturesInput | string[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    features?: SubscriptionPlanUpdatefeaturesInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: UserSubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    features?: SubscriptionPlanUpdatefeaturesInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanCreateManyInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    features?: SubscriptionPlanCreatefeaturesInput | string[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    features?: SubscriptionPlanUpdatefeaturesInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    features?: SubscriptionPlanUpdatefeaturesInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionCreateInput = {
    id?: string
    planPrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    endDate: Date | string
    autoRenew?: boolean
    paymentMethod: string
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type UserSubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    planId: string
    planPrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    endDate: Date | string
    autoRenew?: boolean
    paymentMethod: string
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type UserSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    planPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionCreateManyInput = {
    id?: string
    userId: string
    planId: string
    planPrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    endDate: Date | string
    autoRenew?: boolean
    paymentMethod: string
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    planPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    planPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiPartnerCreateInput = {
    id?: string
    companyName: string
    contactEmail: string
    apiKeyName: string
    apiKey?: string | null
    status?: $Enums.PartnerStatus
    permissions?: ApiPartnerCreatepermissionsInput | string[]
    apiKeyLastGenerated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiPartnerUncheckedCreateInput = {
    id?: string
    companyName: string
    contactEmail: string
    apiKeyName: string
    apiKey?: string | null
    status?: $Enums.PartnerStatus
    permissions?: ApiPartnerCreatepermissionsInput | string[]
    apiKeyLastGenerated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiPartnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    apiKeyName?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    permissions?: ApiPartnerUpdatepermissionsInput | string[]
    apiKeyLastGenerated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiPartnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    apiKeyName?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    permissions?: ApiPartnerUpdatepermissionsInput | string[]
    apiKeyLastGenerated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiPartnerCreateManyInput = {
    id?: string
    companyName: string
    contactEmail: string
    apiKeyName: string
    apiKey?: string | null
    status?: $Enums.PartnerStatus
    permissions?: ApiPartnerCreatepermissionsInput | string[]
    apiKeyLastGenerated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiPartnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    apiKeyName?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    permissions?: ApiPartnerUpdatepermissionsInput | string[]
    apiKeyLastGenerated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiPartnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    apiKeyName?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPartnerStatusFieldUpdateOperationsInput | $Enums.PartnerStatus
    permissions?: ApiPartnerUpdatepermissionsInput | string[]
    apiKeyLastGenerated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemCreateInput = {
    id?: string
    addedAt?: Date | string
    user: UserCreateNestedOneWithoutWishlistItemsInput
    product: ProductCreateNestedOneWithoutWishlistItemsInput
  }

  export type WishlistItemUncheckedCreateInput = {
    id?: string
    userId: string
    productId: string
    addedAt?: Date | string
  }

  export type WishlistItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWishlistItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutWishlistItemsNestedInput
  }

  export type WishlistItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemCreateManyInput = {
    id?: string
    userId: string
    productId: string
    addedAt?: Date | string
  }

  export type WishlistItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateInput = {
    id?: string
    role?: string
    invitedBy?: string | null
    joinedAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: string
    teamId: string
    userId: string
    role?: string
    invitedBy?: string | null
    joinedAt?: Date | string
  }

  export type TeamMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyInput = {
    id?: string
    teamId: string
    userId: string
    role?: string
    invitedBy?: string | null
    joinedAt?: Date | string
  }

  export type TeamMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CartListRelationFilter = {
    every?: CartWhereInput
    some?: CartWhereInput
    none?: CartWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type CommunityStoryListRelationFilter = {
    every?: CommunityStoryWhereInput
    some?: CommunityStoryWhereInput
    none?: CommunityStoryWhereInput
  }

  export type CounterfeitReportListRelationFilter = {
    every?: CounterfeitReportWhereInput
    some?: CounterfeitReportWhereInput
    none?: CounterfeitReportWhereInput
  }

  export type SellerApplicationListRelationFilter = {
    every?: SellerApplicationWhereInput
    some?: SellerApplicationWhereInput
    none?: SellerApplicationWhereInput
  }

  export type DisputeListRelationFilter = {
    every?: DisputeWhereInput
    some?: DisputeWhereInput
    none?: DisputeWhereInput
  }

  export type FulfillmentSettingsListRelationFilter = {
    every?: FulfillmentSettingsWhereInput
    some?: FulfillmentSettingsWhereInput
    none?: FulfillmentSettingsWhereInput
  }

  export type KYCDocumentListRelationFilter = {
    every?: KYCDocumentWhereInput
    some?: KYCDocumentWhereInput
    none?: KYCDocumentWhereInput
  }

  export type TaxRegistrationListRelationFilter = {
    every?: TaxRegistrationWhereInput
    some?: TaxRegistrationWhereInput
    none?: TaxRegistrationWhereInput
  }

  export type ProductViewListRelationFilter = {
    every?: ProductViewWhereInput
    some?: ProductViewWhereInput
    none?: ProductViewWhereInput
  }

  export type SponsoredPlacementListRelationFilter = {
    every?: SponsoredPlacementWhereInput
    some?: SponsoredPlacementWhereInput
    none?: SponsoredPlacementWhereInput
  }

  export type ServiceOrderListRelationFilter = {
    every?: ServiceOrderWhereInput
    some?: ServiceOrderWhereInput
    none?: ServiceOrderWhereInput
  }

  export type SellerServiceListRelationFilter = {
    every?: SellerServiceWhereInput
    some?: SellerServiceWhereInput
    none?: SellerServiceWhereInput
  }

  export type UserSubscriptionListRelationFilter = {
    every?: UserSubscriptionWhereInput
    some?: UserSubscriptionWhereInput
    none?: UserSubscriptionWhereInput
  }

  export type WishlistItemListRelationFilter = {
    every?: WishlistItemWhereInput
    some?: WishlistItemWhereInput
    none?: WishlistItemWhereInput
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput
    some?: TeamMemberWhereInput
    none?: TeamMemberWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityStoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CounterfeitReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SellerApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DisputeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FulfillmentSettingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KYCDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaxRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SponsoredPlacementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SellerServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WishlistItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    city?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    sellerHandle?: SortOrder
    shopName?: SortOrder
    shopLogoUrl?: SortOrder
    shopBannerUrl?: SortOrder
    shopBio?: SortOrder
    ratingAvg?: SortOrder
    ratingCount?: SortOrder
    bio?: SortOrder
    notifyEmail?: SortOrder
    notifySms?: SortOrder
    notifyPush?: SortOrder
    timezone?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    ratingAvg?: SortOrder
    ratingCount?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    city?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    sellerHandle?: SortOrder
    shopName?: SortOrder
    shopLogoUrl?: SortOrder
    shopBannerUrl?: SortOrder
    shopBio?: SortOrder
    ratingAvg?: SortOrder
    ratingCount?: SortOrder
    bio?: SortOrder
    notifyEmail?: SortOrder
    notifySms?: SortOrder
    notifyPush?: SortOrder
    timezone?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    city?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    sellerHandle?: SortOrder
    shopName?: SortOrder
    shopLogoUrl?: SortOrder
    shopBannerUrl?: SortOrder
    shopBio?: SortOrder
    ratingAvg?: SortOrder
    ratingCount?: SortOrder
    bio?: SortOrder
    notifyEmail?: SortOrder
    notifySms?: SortOrder
    notifyPush?: SortOrder
    timezone?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    ratingAvg?: SortOrder
    ratingCount?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type InventoryNullableScalarRelationFilter = {
    is?: InventoryWhereInput | null
    isNot?: InventoryWhereInput | null
  }

  export type CartItemListRelationFilter = {
    every?: CartItemWhereInput
    some?: CartItemWhereInput
    none?: CartItemWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type CartItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    ratingAvg?: SortOrder
    ratingCount?: SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    ratingAvg?: SortOrder
    ratingCount?: SortOrder
    viewCount?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    ratingAvg?: SortOrder
    ratingCount?: SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    ratingAvg?: SortOrder
    ratingCount?: SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    ratingAvg?: SortOrder
    ratingCount?: SortOrder
    viewCount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CartCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    anonKey?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type CartMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    anonKey?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    anonKey?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type CartScalarRelationFilter = {
    is?: CartWhereInput
    isNot?: CartWhereInput
  }

  export type CartItemCartIdProductIdCompoundUniqueInput = {
    cartId: string
    productId: string
  }

  export type CartItemCountOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    qty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemAvgOrderByAggregateInput = {
    qty?: SortOrder
  }

  export type CartItemMaxOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    qty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemMinOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    qty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemSumOrderByAggregateInput = {
    qty?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type PaymentNullableScalarRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentRef?: SortOrder
    shippingAdr?: SortOrder
    buyerName?: SortOrder
    buyerPhone?: SortOrder
    buyerEmail?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    total?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentRef?: SortOrder
    shippingAdr?: SortOrder
    buyerName?: SortOrder
    buyerPhone?: SortOrder
    buyerEmail?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentRef?: SortOrder
    shippingAdr?: SortOrder
    buyerName?: SortOrder
    buyerPhone?: SortOrder
    buyerEmail?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    total?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumPayoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusFilter<$PrismaModel> | $Enums.PayoutStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumFulfillmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FulfillmentStatus | EnumFulfillmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FulfillmentStatus[] | ListEnumFulfillmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FulfillmentStatus[] | ListEnumFulfillmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFulfillmentStatusFilter<$PrismaModel> | $Enums.FulfillmentStatus
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    sellerId?: SortOrder
    grossAmount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    payoutStatus?: SortOrder
    payoutBatchId?: SortOrder
    paidAt?: SortOrder
    currency?: SortOrder
    fulfillmentStatus?: SortOrder
    shippedAt?: SortOrder
    deliveredAt?: SortOrder
    trackingCode?: SortOrder
    carrier?: SortOrder
    deliveryProofUrl?: SortOrder
    notes?: SortOrder
    exceptionNotified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    qty?: SortOrder
    price?: SortOrder
    grossAmount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    sellerId?: SortOrder
    grossAmount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    payoutStatus?: SortOrder
    payoutBatchId?: SortOrder
    paidAt?: SortOrder
    currency?: SortOrder
    fulfillmentStatus?: SortOrder
    shippedAt?: SortOrder
    deliveredAt?: SortOrder
    trackingCode?: SortOrder
    carrier?: SortOrder
    deliveryProofUrl?: SortOrder
    notes?: SortOrder
    exceptionNotified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    sellerId?: SortOrder
    grossAmount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    payoutStatus?: SortOrder
    payoutBatchId?: SortOrder
    paidAt?: SortOrder
    currency?: SortOrder
    fulfillmentStatus?: SortOrder
    shippedAt?: SortOrder
    deliveredAt?: SortOrder
    trackingCode?: SortOrder
    carrier?: SortOrder
    deliveryProofUrl?: SortOrder
    notes?: SortOrder
    exceptionNotified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    qty?: SortOrder
    price?: SortOrder
    grossAmount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
  }

  export type EnumPayoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutStatusFilter<$PrismaModel>
    _max?: NestedEnumPayoutStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumFulfillmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FulfillmentStatus | EnumFulfillmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FulfillmentStatus[] | ListEnumFulfillmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FulfillmentStatus[] | ListEnumFulfillmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFulfillmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.FulfillmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFulfillmentStatusFilter<$PrismaModel>
    _max?: NestedEnumFulfillmentStatusFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    externalRef?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    externalRef?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    externalRef?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type FulfillmentSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    usesMicroFulfillment?: SortOrder
    microFulfillmentPartnerId?: SortOrder
    microFulfillmentOptInDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FulfillmentSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    usesMicroFulfillment?: SortOrder
    microFulfillmentPartnerId?: SortOrder
    microFulfillmentOptInDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FulfillmentSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    usesMicroFulfillment?: SortOrder
    microFulfillmentPartnerId?: SortOrder
    microFulfillmentOptInDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumKYCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusFilter<$PrismaModel> | $Enums.KYCStatus
  }

  export type KYCDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    documentUrl?: SortOrder
    country?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KYCDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    documentUrl?: SortOrder
    country?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KYCDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    documentUrl?: SortOrder
    country?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumKYCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel> | $Enums.KYCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCStatusFilter<$PrismaModel>
    _max?: NestedEnumKYCStatusFilter<$PrismaModel>
  }

  export type EnumTaxStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxStatus | EnumTaxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaxStatus[] | ListEnumTaxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxStatus[] | ListEnumTaxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxStatusFilter<$PrismaModel> | $Enums.TaxStatus
  }

  export type TaxRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    taxId?: SortOrder
    country?: SortOrder
    status?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    taxId?: SortOrder
    country?: SortOrder
    status?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    taxId?: SortOrder
    country?: SortOrder
    status?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTaxStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxStatus | EnumTaxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaxStatus[] | ListEnumTaxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxStatus[] | ListEnumTaxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaxStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaxStatusFilter<$PrismaModel>
    _max?: NestedEnumTaxStatusFilter<$PrismaModel>
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type CounterfeitReportCountOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    productId?: SortOrder
    reason?: SortOrder
    evidenceUrl?: SortOrder
    status?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CounterfeitReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    productId?: SortOrder
    reason?: SortOrder
    evidenceUrl?: SortOrder
    status?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CounterfeitReportMinOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    productId?: SortOrder
    reason?: SortOrder
    evidenceUrl?: SortOrder
    status?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type EnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type SellerApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    city?: SortOrder
    storefrontDesc?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    bankCode?: SortOrder
    status?: SortOrder
    adminNote?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellerApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    city?: SortOrder
    storefrontDesc?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    bankCode?: SortOrder
    status?: SortOrder
    adminNote?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellerApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    city?: SortOrder
    storefrontDesc?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    bankCode?: SortOrder
    status?: SortOrder
    adminNote?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type EnumDisputeReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeReason | EnumDisputeReasonFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeReason[] | ListEnumDisputeReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeReason[] | ListEnumDisputeReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeReasonFilter<$PrismaModel> | $Enums.DisputeReason
  }

  export type EnumDisputeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeStatus | EnumDisputeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeStatusFilter<$PrismaModel> | $Enums.DisputeStatus
  }

  export type OrderItemScalarRelationFilter = {
    is?: OrderItemWhereInput
    isNot?: OrderItemWhereInput
  }

  export type DisputeCountOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    buyerId?: SortOrder
    reasonCode?: SortOrder
    description?: SortOrder
    photoProofUrl?: SortOrder
    status?: SortOrder
    resolutionNote?: SortOrder
    resolvedById?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisputeMaxOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    buyerId?: SortOrder
    reasonCode?: SortOrder
    description?: SortOrder
    photoProofUrl?: SortOrder
    status?: SortOrder
    resolutionNote?: SortOrder
    resolvedById?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisputeMinOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    buyerId?: SortOrder
    reasonCode?: SortOrder
    description?: SortOrder
    photoProofUrl?: SortOrder
    status?: SortOrder
    resolutionNote?: SortOrder
    resolvedById?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDisputeReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeReason | EnumDisputeReasonFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeReason[] | ListEnumDisputeReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeReason[] | ListEnumDisputeReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeReasonWithAggregatesFilter<$PrismaModel> | $Enums.DisputeReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDisputeReasonFilter<$PrismaModel>
    _max?: NestedEnumDisputeReasonFilter<$PrismaModel>
  }

  export type EnumDisputeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeStatus | EnumDisputeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeStatusWithAggregatesFilter<$PrismaModel> | $Enums.DisputeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDisputeStatusFilter<$PrismaModel>
    _max?: NestedEnumDisputeStatusFilter<$PrismaModel>
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    isVisible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    isVisible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    sellerId?: SortOrder
    buyerId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    isVisible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityStoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityStoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityStoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductViewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    timestamp?: SortOrder
  }

  export type ProductViewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    timestamp?: SortOrder
  }

  export type ProductViewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumSponsoredPlacementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SponsoredPlacementStatus | EnumSponsoredPlacementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SponsoredPlacementStatus[] | ListEnumSponsoredPlacementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SponsoredPlacementStatus[] | ListEnumSponsoredPlacementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSponsoredPlacementStatusFilter<$PrismaModel> | $Enums.SponsoredPlacementStatus
  }

  export type SponsoredPlacementCountOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    productId?: SortOrder
    categorySlug?: SortOrder
    searchTerm?: SortOrder
    bidAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SponsoredPlacementAvgOrderByAggregateInput = {
    bidAmount?: SortOrder
  }

  export type SponsoredPlacementMaxOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    productId?: SortOrder
    categorySlug?: SortOrder
    searchTerm?: SortOrder
    bidAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SponsoredPlacementMinOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    productId?: SortOrder
    categorySlug?: SortOrder
    searchTerm?: SortOrder
    bidAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SponsoredPlacementSumOrderByAggregateInput = {
    bidAmount?: SortOrder
  }

  export type EnumSponsoredPlacementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SponsoredPlacementStatus | EnumSponsoredPlacementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SponsoredPlacementStatus[] | ListEnumSponsoredPlacementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SponsoredPlacementStatus[] | ListEnumSponsoredPlacementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSponsoredPlacementStatusWithAggregatesFilter<$PrismaModel> | $Enums.SponsoredPlacementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSponsoredPlacementStatusFilter<$PrismaModel>
    _max?: NestedEnumSponsoredPlacementStatusFilter<$PrismaModel>
  }

  export type SellerServiceCountOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    category?: SortOrder
    deliveryTime?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellerServiceAvgOrderByAggregateInput = {
    price?: SortOrder
    deliveryTime?: SortOrder
  }

  export type SellerServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    category?: SortOrder
    deliveryTime?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellerServiceMinOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    category?: SortOrder
    deliveryTime?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellerServiceSumOrderByAggregateInput = {
    price?: SortOrder
    deliveryTime?: SortOrder
  }

  export type EnumServiceOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceOrderStatus | EnumServiceOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceOrderStatus[] | ListEnumServiceOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceOrderStatus[] | ListEnumServiceOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceOrderStatusFilter<$PrismaModel> | $Enums.ServiceOrderStatus
  }

  export type SellerServiceScalarRelationFilter = {
    is?: SellerServiceWhereInput
    isNot?: SellerServiceWhereInput
  }

  export type ServiceOrderCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    message?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceOrderAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ServiceOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    message?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceOrderMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    message?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceOrderSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumServiceOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceOrderStatus | EnumServiceOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceOrderStatus[] | ListEnumServiceOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceOrderStatus[] | ListEnumServiceOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumServiceOrderStatusFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type SubscriptionPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    features?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type SubscriptionPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type SubscriptionPlanScalarRelationFilter = {
    is?: SubscriptionPlanWhereInput
    isNot?: SubscriptionPlanWhereInput
  }

  export type UserSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    planPrice?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSubscriptionAvgOrderByAggregateInput = {
    planPrice?: SortOrder
  }

  export type UserSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    planPrice?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    planPrice?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSubscriptionSumOrderByAggregateInput = {
    planPrice?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type EnumPartnerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerStatus | EnumPartnerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerStatusFilter<$PrismaModel> | $Enums.PartnerStatus
  }

  export type ApiPartnerCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactEmail?: SortOrder
    apiKeyName?: SortOrder
    apiKey?: SortOrder
    status?: SortOrder
    permissions?: SortOrder
    apiKeyLastGenerated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiPartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactEmail?: SortOrder
    apiKeyName?: SortOrder
    apiKey?: SortOrder
    status?: SortOrder
    apiKeyLastGenerated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiPartnerMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactEmail?: SortOrder
    apiKeyName?: SortOrder
    apiKey?: SortOrder
    status?: SortOrder
    apiKeyLastGenerated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPartnerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerStatus | EnumPartnerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerStatusWithAggregatesFilter<$PrismaModel> | $Enums.PartnerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartnerStatusFilter<$PrismaModel>
    _max?: NestedEnumPartnerStatusFilter<$PrismaModel>
  }

  export type WishlistItemUserIdProductIdCompoundUniqueInput = {
    userId: string
    productId: string
  }

  export type WishlistItemCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    addedAt?: SortOrder
  }

  export type WishlistItemMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    addedAt?: SortOrder
  }

  export type WishlistItemMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    addedAt?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type TeamMemberTeamIdUserIdCompoundUniqueInput = {
    teamId: string
    userId: string
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    invitedBy?: SortOrder
    joinedAt?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    invitedBy?: SortOrder
    joinedAt?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    invitedBy?: SortOrder
    joinedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type CartCreateNestedManyWithoutUserInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutSellerInput = {
    create?: XOR<ProductCreateWithoutSellerInput, ProductUncheckedCreateWithoutSellerInput> | ProductCreateWithoutSellerInput[] | ProductUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSellerInput | ProductCreateOrConnectWithoutSellerInput[]
    createMany?: ProductCreateManySellerInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutBuyerInput = {
    create?: XOR<ReviewCreateWithoutBuyerInput, ReviewUncheckedCreateWithoutBuyerInput> | ReviewCreateWithoutBuyerInput[] | ReviewUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBuyerInput | ReviewCreateOrConnectWithoutBuyerInput[]
    createMany?: ReviewCreateManyBuyerInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CommunityStoryCreateNestedManyWithoutUserInput = {
    create?: XOR<CommunityStoryCreateWithoutUserInput, CommunityStoryUncheckedCreateWithoutUserInput> | CommunityStoryCreateWithoutUserInput[] | CommunityStoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityStoryCreateOrConnectWithoutUserInput | CommunityStoryCreateOrConnectWithoutUserInput[]
    createMany?: CommunityStoryCreateManyUserInputEnvelope
    connect?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutSellerInput = {
    create?: XOR<ReviewCreateWithoutSellerInput, ReviewUncheckedCreateWithoutSellerInput> | ReviewCreateWithoutSellerInput[] | ReviewUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutSellerInput | ReviewCreateOrConnectWithoutSellerInput[]
    createMany?: ReviewCreateManySellerInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CounterfeitReportCreateNestedManyWithoutReporterInput = {
    create?: XOR<CounterfeitReportCreateWithoutReporterInput, CounterfeitReportUncheckedCreateWithoutReporterInput> | CounterfeitReportCreateWithoutReporterInput[] | CounterfeitReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: CounterfeitReportCreateOrConnectWithoutReporterInput | CounterfeitReportCreateOrConnectWithoutReporterInput[]
    createMany?: CounterfeitReportCreateManyReporterInputEnvelope
    connect?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
  }

  export type SellerApplicationCreateNestedManyWithoutUserInput = {
    create?: XOR<SellerApplicationCreateWithoutUserInput, SellerApplicationUncheckedCreateWithoutUserInput> | SellerApplicationCreateWithoutUserInput[] | SellerApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SellerApplicationCreateOrConnectWithoutUserInput | SellerApplicationCreateOrConnectWithoutUserInput[]
    createMany?: SellerApplicationCreateManyUserInputEnvelope
    connect?: SellerApplicationWhereUniqueInput | SellerApplicationWhereUniqueInput[]
  }

  export type DisputeCreateNestedManyWithoutBuyerInput = {
    create?: XOR<DisputeCreateWithoutBuyerInput, DisputeUncheckedCreateWithoutBuyerInput> | DisputeCreateWithoutBuyerInput[] | DisputeUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutBuyerInput | DisputeCreateOrConnectWithoutBuyerInput[]
    createMany?: DisputeCreateManyBuyerInputEnvelope
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
  }

  export type FulfillmentSettingsCreateNestedManyWithoutSellerInput = {
    create?: XOR<FulfillmentSettingsCreateWithoutSellerInput, FulfillmentSettingsUncheckedCreateWithoutSellerInput> | FulfillmentSettingsCreateWithoutSellerInput[] | FulfillmentSettingsUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: FulfillmentSettingsCreateOrConnectWithoutSellerInput | FulfillmentSettingsCreateOrConnectWithoutSellerInput[]
    createMany?: FulfillmentSettingsCreateManySellerInputEnvelope
    connect?: FulfillmentSettingsWhereUniqueInput | FulfillmentSettingsWhereUniqueInput[]
  }

  export type KYCDocumentCreateNestedManyWithoutSellerInput = {
    create?: XOR<KYCDocumentCreateWithoutSellerInput, KYCDocumentUncheckedCreateWithoutSellerInput> | KYCDocumentCreateWithoutSellerInput[] | KYCDocumentUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: KYCDocumentCreateOrConnectWithoutSellerInput | KYCDocumentCreateOrConnectWithoutSellerInput[]
    createMany?: KYCDocumentCreateManySellerInputEnvelope
    connect?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
  }

  export type TaxRegistrationCreateNestedManyWithoutSellerInput = {
    create?: XOR<TaxRegistrationCreateWithoutSellerInput, TaxRegistrationUncheckedCreateWithoutSellerInput> | TaxRegistrationCreateWithoutSellerInput[] | TaxRegistrationUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: TaxRegistrationCreateOrConnectWithoutSellerInput | TaxRegistrationCreateOrConnectWithoutSellerInput[]
    createMany?: TaxRegistrationCreateManySellerInputEnvelope
    connect?: TaxRegistrationWhereUniqueInput | TaxRegistrationWhereUniqueInput[]
  }

  export type ProductViewCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductViewCreateWithoutUserInput, ProductViewUncheckedCreateWithoutUserInput> | ProductViewCreateWithoutUserInput[] | ProductViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductViewCreateOrConnectWithoutUserInput | ProductViewCreateOrConnectWithoutUserInput[]
    createMany?: ProductViewCreateManyUserInputEnvelope
    connect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
  }

  export type SponsoredPlacementCreateNestedManyWithoutSellerInput = {
    create?: XOR<SponsoredPlacementCreateWithoutSellerInput, SponsoredPlacementUncheckedCreateWithoutSellerInput> | SponsoredPlacementCreateWithoutSellerInput[] | SponsoredPlacementUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SponsoredPlacementCreateOrConnectWithoutSellerInput | SponsoredPlacementCreateOrConnectWithoutSellerInput[]
    createMany?: SponsoredPlacementCreateManySellerInputEnvelope
    connect?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
  }

  export type ServiceOrderCreateNestedManyWithoutBuyerInput = {
    create?: XOR<ServiceOrderCreateWithoutBuyerInput, ServiceOrderUncheckedCreateWithoutBuyerInput> | ServiceOrderCreateWithoutBuyerInput[] | ServiceOrderUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutBuyerInput | ServiceOrderCreateOrConnectWithoutBuyerInput[]
    createMany?: ServiceOrderCreateManyBuyerInputEnvelope
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
  }

  export type ServiceOrderCreateNestedManyWithoutSellerInput = {
    create?: XOR<ServiceOrderCreateWithoutSellerInput, ServiceOrderUncheckedCreateWithoutSellerInput> | ServiceOrderCreateWithoutSellerInput[] | ServiceOrderUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutSellerInput | ServiceOrderCreateOrConnectWithoutSellerInput[]
    createMany?: ServiceOrderCreateManySellerInputEnvelope
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
  }

  export type SellerServiceCreateNestedManyWithoutSellerInput = {
    create?: XOR<SellerServiceCreateWithoutSellerInput, SellerServiceUncheckedCreateWithoutSellerInput> | SellerServiceCreateWithoutSellerInput[] | SellerServiceUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SellerServiceCreateOrConnectWithoutSellerInput | SellerServiceCreateOrConnectWithoutSellerInput[]
    createMany?: SellerServiceCreateManySellerInputEnvelope
    connect?: SellerServiceWhereUniqueInput | SellerServiceWhereUniqueInput[]
  }

  export type UserSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput> | UserSubscriptionCreateWithoutUserInput[] | UserSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput | UserSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: UserSubscriptionCreateManyUserInputEnvelope
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
  }

  export type WishlistItemCreateNestedManyWithoutUserInput = {
    create?: XOR<WishlistItemCreateWithoutUserInput, WishlistItemUncheckedCreateWithoutUserInput> | WishlistItemCreateWithoutUserInput[] | WishlistItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutUserInput | WishlistItemCreateOrConnectWithoutUserInput[]
    createMany?: WishlistItemCreateManyUserInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TeamCreateWithoutCreatedByInput, TeamUncheckedCreateWithoutCreatedByInput> | TeamCreateWithoutCreatedByInput[] | TeamUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatedByInput | TeamCreateOrConnectWithoutCreatedByInput[]
    createMany?: TeamCreateManyCreatedByInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type TeamMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CartUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<ProductCreateWithoutSellerInput, ProductUncheckedCreateWithoutSellerInput> | ProductCreateWithoutSellerInput[] | ProductUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSellerInput | ProductCreateOrConnectWithoutSellerInput[]
    createMany?: ProductCreateManySellerInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutBuyerInput = {
    create?: XOR<ReviewCreateWithoutBuyerInput, ReviewUncheckedCreateWithoutBuyerInput> | ReviewCreateWithoutBuyerInput[] | ReviewUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBuyerInput | ReviewCreateOrConnectWithoutBuyerInput[]
    createMany?: ReviewCreateManyBuyerInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CommunityStoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommunityStoryCreateWithoutUserInput, CommunityStoryUncheckedCreateWithoutUserInput> | CommunityStoryCreateWithoutUserInput[] | CommunityStoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityStoryCreateOrConnectWithoutUserInput | CommunityStoryCreateOrConnectWithoutUserInput[]
    createMany?: CommunityStoryCreateManyUserInputEnvelope
    connect?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<ReviewCreateWithoutSellerInput, ReviewUncheckedCreateWithoutSellerInput> | ReviewCreateWithoutSellerInput[] | ReviewUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutSellerInput | ReviewCreateOrConnectWithoutSellerInput[]
    createMany?: ReviewCreateManySellerInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput = {
    create?: XOR<CounterfeitReportCreateWithoutReporterInput, CounterfeitReportUncheckedCreateWithoutReporterInput> | CounterfeitReportCreateWithoutReporterInput[] | CounterfeitReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: CounterfeitReportCreateOrConnectWithoutReporterInput | CounterfeitReportCreateOrConnectWithoutReporterInput[]
    createMany?: CounterfeitReportCreateManyReporterInputEnvelope
    connect?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
  }

  export type SellerApplicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SellerApplicationCreateWithoutUserInput, SellerApplicationUncheckedCreateWithoutUserInput> | SellerApplicationCreateWithoutUserInput[] | SellerApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SellerApplicationCreateOrConnectWithoutUserInput | SellerApplicationCreateOrConnectWithoutUserInput[]
    createMany?: SellerApplicationCreateManyUserInputEnvelope
    connect?: SellerApplicationWhereUniqueInput | SellerApplicationWhereUniqueInput[]
  }

  export type DisputeUncheckedCreateNestedManyWithoutBuyerInput = {
    create?: XOR<DisputeCreateWithoutBuyerInput, DisputeUncheckedCreateWithoutBuyerInput> | DisputeCreateWithoutBuyerInput[] | DisputeUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutBuyerInput | DisputeCreateOrConnectWithoutBuyerInput[]
    createMany?: DisputeCreateManyBuyerInputEnvelope
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
  }

  export type FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<FulfillmentSettingsCreateWithoutSellerInput, FulfillmentSettingsUncheckedCreateWithoutSellerInput> | FulfillmentSettingsCreateWithoutSellerInput[] | FulfillmentSettingsUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: FulfillmentSettingsCreateOrConnectWithoutSellerInput | FulfillmentSettingsCreateOrConnectWithoutSellerInput[]
    createMany?: FulfillmentSettingsCreateManySellerInputEnvelope
    connect?: FulfillmentSettingsWhereUniqueInput | FulfillmentSettingsWhereUniqueInput[]
  }

  export type KYCDocumentUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<KYCDocumentCreateWithoutSellerInput, KYCDocumentUncheckedCreateWithoutSellerInput> | KYCDocumentCreateWithoutSellerInput[] | KYCDocumentUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: KYCDocumentCreateOrConnectWithoutSellerInput | KYCDocumentCreateOrConnectWithoutSellerInput[]
    createMany?: KYCDocumentCreateManySellerInputEnvelope
    connect?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
  }

  export type TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<TaxRegistrationCreateWithoutSellerInput, TaxRegistrationUncheckedCreateWithoutSellerInput> | TaxRegistrationCreateWithoutSellerInput[] | TaxRegistrationUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: TaxRegistrationCreateOrConnectWithoutSellerInput | TaxRegistrationCreateOrConnectWithoutSellerInput[]
    createMany?: TaxRegistrationCreateManySellerInputEnvelope
    connect?: TaxRegistrationWhereUniqueInput | TaxRegistrationWhereUniqueInput[]
  }

  export type ProductViewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductViewCreateWithoutUserInput, ProductViewUncheckedCreateWithoutUserInput> | ProductViewCreateWithoutUserInput[] | ProductViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductViewCreateOrConnectWithoutUserInput | ProductViewCreateOrConnectWithoutUserInput[]
    createMany?: ProductViewCreateManyUserInputEnvelope
    connect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
  }

  export type SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<SponsoredPlacementCreateWithoutSellerInput, SponsoredPlacementUncheckedCreateWithoutSellerInput> | SponsoredPlacementCreateWithoutSellerInput[] | SponsoredPlacementUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SponsoredPlacementCreateOrConnectWithoutSellerInput | SponsoredPlacementCreateOrConnectWithoutSellerInput[]
    createMany?: SponsoredPlacementCreateManySellerInputEnvelope
    connect?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
  }

  export type ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput = {
    create?: XOR<ServiceOrderCreateWithoutBuyerInput, ServiceOrderUncheckedCreateWithoutBuyerInput> | ServiceOrderCreateWithoutBuyerInput[] | ServiceOrderUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutBuyerInput | ServiceOrderCreateOrConnectWithoutBuyerInput[]
    createMany?: ServiceOrderCreateManyBuyerInputEnvelope
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
  }

  export type ServiceOrderUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<ServiceOrderCreateWithoutSellerInput, ServiceOrderUncheckedCreateWithoutSellerInput> | ServiceOrderCreateWithoutSellerInput[] | ServiceOrderUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutSellerInput | ServiceOrderCreateOrConnectWithoutSellerInput[]
    createMany?: ServiceOrderCreateManySellerInputEnvelope
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
  }

  export type SellerServiceUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<SellerServiceCreateWithoutSellerInput, SellerServiceUncheckedCreateWithoutSellerInput> | SellerServiceCreateWithoutSellerInput[] | SellerServiceUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SellerServiceCreateOrConnectWithoutSellerInput | SellerServiceCreateOrConnectWithoutSellerInput[]
    createMany?: SellerServiceCreateManySellerInputEnvelope
    connect?: SellerServiceWhereUniqueInput | SellerServiceWhereUniqueInput[]
  }

  export type UserSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput> | UserSubscriptionCreateWithoutUserInput[] | UserSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput | UserSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: UserSubscriptionCreateManyUserInputEnvelope
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
  }

  export type WishlistItemUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WishlistItemCreateWithoutUserInput, WishlistItemUncheckedCreateWithoutUserInput> | WishlistItemCreateWithoutUserInput[] | WishlistItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutUserInput | WishlistItemCreateOrConnectWithoutUserInput[]
    createMany?: WishlistItemCreateManyUserInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TeamCreateWithoutCreatedByInput, TeamUncheckedCreateWithoutCreatedByInput> | TeamCreateWithoutCreatedByInput[] | TeamUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatedByInput | TeamCreateOrConnectWithoutCreatedByInput[]
    createMany?: TeamCreateManyCreatedByInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CartUpdateManyWithoutUserNestedInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutUserInput | CartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutUserInput | CartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CartUpdateManyWithWhereWithoutUserInput | CartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutSellerNestedInput = {
    create?: XOR<ProductCreateWithoutSellerInput, ProductUncheckedCreateWithoutSellerInput> | ProductCreateWithoutSellerInput[] | ProductUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSellerInput | ProductCreateOrConnectWithoutSellerInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSellerInput | ProductUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: ProductCreateManySellerInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSellerInput | ProductUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSellerInput | ProductUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<ReviewCreateWithoutBuyerInput, ReviewUncheckedCreateWithoutBuyerInput> | ReviewCreateWithoutBuyerInput[] | ReviewUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBuyerInput | ReviewCreateOrConnectWithoutBuyerInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutBuyerInput | ReviewUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: ReviewCreateManyBuyerInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutBuyerInput | ReviewUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutBuyerInput | ReviewUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CommunityStoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommunityStoryCreateWithoutUserInput, CommunityStoryUncheckedCreateWithoutUserInput> | CommunityStoryCreateWithoutUserInput[] | CommunityStoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityStoryCreateOrConnectWithoutUserInput | CommunityStoryCreateOrConnectWithoutUserInput[]
    upsert?: CommunityStoryUpsertWithWhereUniqueWithoutUserInput | CommunityStoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommunityStoryCreateManyUserInputEnvelope
    set?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
    disconnect?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
    delete?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
    connect?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
    update?: CommunityStoryUpdateWithWhereUniqueWithoutUserInput | CommunityStoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommunityStoryUpdateManyWithWhereWithoutUserInput | CommunityStoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommunityStoryScalarWhereInput | CommunityStoryScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutSellerNestedInput = {
    create?: XOR<ReviewCreateWithoutSellerInput, ReviewUncheckedCreateWithoutSellerInput> | ReviewCreateWithoutSellerInput[] | ReviewUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutSellerInput | ReviewCreateOrConnectWithoutSellerInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutSellerInput | ReviewUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: ReviewCreateManySellerInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutSellerInput | ReviewUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutSellerInput | ReviewUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CounterfeitReportUpdateManyWithoutReporterNestedInput = {
    create?: XOR<CounterfeitReportCreateWithoutReporterInput, CounterfeitReportUncheckedCreateWithoutReporterInput> | CounterfeitReportCreateWithoutReporterInput[] | CounterfeitReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: CounterfeitReportCreateOrConnectWithoutReporterInput | CounterfeitReportCreateOrConnectWithoutReporterInput[]
    upsert?: CounterfeitReportUpsertWithWhereUniqueWithoutReporterInput | CounterfeitReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: CounterfeitReportCreateManyReporterInputEnvelope
    set?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
    disconnect?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
    delete?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
    connect?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
    update?: CounterfeitReportUpdateWithWhereUniqueWithoutReporterInput | CounterfeitReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: CounterfeitReportUpdateManyWithWhereWithoutReporterInput | CounterfeitReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: CounterfeitReportScalarWhereInput | CounterfeitReportScalarWhereInput[]
  }

  export type SellerApplicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<SellerApplicationCreateWithoutUserInput, SellerApplicationUncheckedCreateWithoutUserInput> | SellerApplicationCreateWithoutUserInput[] | SellerApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SellerApplicationCreateOrConnectWithoutUserInput | SellerApplicationCreateOrConnectWithoutUserInput[]
    upsert?: SellerApplicationUpsertWithWhereUniqueWithoutUserInput | SellerApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SellerApplicationCreateManyUserInputEnvelope
    set?: SellerApplicationWhereUniqueInput | SellerApplicationWhereUniqueInput[]
    disconnect?: SellerApplicationWhereUniqueInput | SellerApplicationWhereUniqueInput[]
    delete?: SellerApplicationWhereUniqueInput | SellerApplicationWhereUniqueInput[]
    connect?: SellerApplicationWhereUniqueInput | SellerApplicationWhereUniqueInput[]
    update?: SellerApplicationUpdateWithWhereUniqueWithoutUserInput | SellerApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SellerApplicationUpdateManyWithWhereWithoutUserInput | SellerApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SellerApplicationScalarWhereInput | SellerApplicationScalarWhereInput[]
  }

  export type DisputeUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<DisputeCreateWithoutBuyerInput, DisputeUncheckedCreateWithoutBuyerInput> | DisputeCreateWithoutBuyerInput[] | DisputeUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutBuyerInput | DisputeCreateOrConnectWithoutBuyerInput[]
    upsert?: DisputeUpsertWithWhereUniqueWithoutBuyerInput | DisputeUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: DisputeCreateManyBuyerInputEnvelope
    set?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    disconnect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    delete?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    update?: DisputeUpdateWithWhereUniqueWithoutBuyerInput | DisputeUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: DisputeUpdateManyWithWhereWithoutBuyerInput | DisputeUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: DisputeScalarWhereInput | DisputeScalarWhereInput[]
  }

  export type FulfillmentSettingsUpdateManyWithoutSellerNestedInput = {
    create?: XOR<FulfillmentSettingsCreateWithoutSellerInput, FulfillmentSettingsUncheckedCreateWithoutSellerInput> | FulfillmentSettingsCreateWithoutSellerInput[] | FulfillmentSettingsUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: FulfillmentSettingsCreateOrConnectWithoutSellerInput | FulfillmentSettingsCreateOrConnectWithoutSellerInput[]
    upsert?: FulfillmentSettingsUpsertWithWhereUniqueWithoutSellerInput | FulfillmentSettingsUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: FulfillmentSettingsCreateManySellerInputEnvelope
    set?: FulfillmentSettingsWhereUniqueInput | FulfillmentSettingsWhereUniqueInput[]
    disconnect?: FulfillmentSettingsWhereUniqueInput | FulfillmentSettingsWhereUniqueInput[]
    delete?: FulfillmentSettingsWhereUniqueInput | FulfillmentSettingsWhereUniqueInput[]
    connect?: FulfillmentSettingsWhereUniqueInput | FulfillmentSettingsWhereUniqueInput[]
    update?: FulfillmentSettingsUpdateWithWhereUniqueWithoutSellerInput | FulfillmentSettingsUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: FulfillmentSettingsUpdateManyWithWhereWithoutSellerInput | FulfillmentSettingsUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: FulfillmentSettingsScalarWhereInput | FulfillmentSettingsScalarWhereInput[]
  }

  export type KYCDocumentUpdateManyWithoutSellerNestedInput = {
    create?: XOR<KYCDocumentCreateWithoutSellerInput, KYCDocumentUncheckedCreateWithoutSellerInput> | KYCDocumentCreateWithoutSellerInput[] | KYCDocumentUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: KYCDocumentCreateOrConnectWithoutSellerInput | KYCDocumentCreateOrConnectWithoutSellerInput[]
    upsert?: KYCDocumentUpsertWithWhereUniqueWithoutSellerInput | KYCDocumentUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: KYCDocumentCreateManySellerInputEnvelope
    set?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
    disconnect?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
    delete?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
    connect?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
    update?: KYCDocumentUpdateWithWhereUniqueWithoutSellerInput | KYCDocumentUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: KYCDocumentUpdateManyWithWhereWithoutSellerInput | KYCDocumentUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: KYCDocumentScalarWhereInput | KYCDocumentScalarWhereInput[]
  }

  export type TaxRegistrationUpdateManyWithoutSellerNestedInput = {
    create?: XOR<TaxRegistrationCreateWithoutSellerInput, TaxRegistrationUncheckedCreateWithoutSellerInput> | TaxRegistrationCreateWithoutSellerInput[] | TaxRegistrationUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: TaxRegistrationCreateOrConnectWithoutSellerInput | TaxRegistrationCreateOrConnectWithoutSellerInput[]
    upsert?: TaxRegistrationUpsertWithWhereUniqueWithoutSellerInput | TaxRegistrationUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: TaxRegistrationCreateManySellerInputEnvelope
    set?: TaxRegistrationWhereUniqueInput | TaxRegistrationWhereUniqueInput[]
    disconnect?: TaxRegistrationWhereUniqueInput | TaxRegistrationWhereUniqueInput[]
    delete?: TaxRegistrationWhereUniqueInput | TaxRegistrationWhereUniqueInput[]
    connect?: TaxRegistrationWhereUniqueInput | TaxRegistrationWhereUniqueInput[]
    update?: TaxRegistrationUpdateWithWhereUniqueWithoutSellerInput | TaxRegistrationUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: TaxRegistrationUpdateManyWithWhereWithoutSellerInput | TaxRegistrationUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: TaxRegistrationScalarWhereInput | TaxRegistrationScalarWhereInput[]
  }

  export type ProductViewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductViewCreateWithoutUserInput, ProductViewUncheckedCreateWithoutUserInput> | ProductViewCreateWithoutUserInput[] | ProductViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductViewCreateOrConnectWithoutUserInput | ProductViewCreateOrConnectWithoutUserInput[]
    upsert?: ProductViewUpsertWithWhereUniqueWithoutUserInput | ProductViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductViewCreateManyUserInputEnvelope
    set?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    disconnect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    delete?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    connect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    update?: ProductViewUpdateWithWhereUniqueWithoutUserInput | ProductViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductViewUpdateManyWithWhereWithoutUserInput | ProductViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductViewScalarWhereInput | ProductViewScalarWhereInput[]
  }

  export type SponsoredPlacementUpdateManyWithoutSellerNestedInput = {
    create?: XOR<SponsoredPlacementCreateWithoutSellerInput, SponsoredPlacementUncheckedCreateWithoutSellerInput> | SponsoredPlacementCreateWithoutSellerInput[] | SponsoredPlacementUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SponsoredPlacementCreateOrConnectWithoutSellerInput | SponsoredPlacementCreateOrConnectWithoutSellerInput[]
    upsert?: SponsoredPlacementUpsertWithWhereUniqueWithoutSellerInput | SponsoredPlacementUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: SponsoredPlacementCreateManySellerInputEnvelope
    set?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
    disconnect?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
    delete?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
    connect?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
    update?: SponsoredPlacementUpdateWithWhereUniqueWithoutSellerInput | SponsoredPlacementUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: SponsoredPlacementUpdateManyWithWhereWithoutSellerInput | SponsoredPlacementUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: SponsoredPlacementScalarWhereInput | SponsoredPlacementScalarWhereInput[]
  }

  export type ServiceOrderUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<ServiceOrderCreateWithoutBuyerInput, ServiceOrderUncheckedCreateWithoutBuyerInput> | ServiceOrderCreateWithoutBuyerInput[] | ServiceOrderUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutBuyerInput | ServiceOrderCreateOrConnectWithoutBuyerInput[]
    upsert?: ServiceOrderUpsertWithWhereUniqueWithoutBuyerInput | ServiceOrderUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: ServiceOrderCreateManyBuyerInputEnvelope
    set?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    disconnect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    delete?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    update?: ServiceOrderUpdateWithWhereUniqueWithoutBuyerInput | ServiceOrderUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: ServiceOrderUpdateManyWithWhereWithoutBuyerInput | ServiceOrderUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
  }

  export type ServiceOrderUpdateManyWithoutSellerNestedInput = {
    create?: XOR<ServiceOrderCreateWithoutSellerInput, ServiceOrderUncheckedCreateWithoutSellerInput> | ServiceOrderCreateWithoutSellerInput[] | ServiceOrderUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutSellerInput | ServiceOrderCreateOrConnectWithoutSellerInput[]
    upsert?: ServiceOrderUpsertWithWhereUniqueWithoutSellerInput | ServiceOrderUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: ServiceOrderCreateManySellerInputEnvelope
    set?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    disconnect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    delete?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    update?: ServiceOrderUpdateWithWhereUniqueWithoutSellerInput | ServiceOrderUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: ServiceOrderUpdateManyWithWhereWithoutSellerInput | ServiceOrderUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
  }

  export type SellerServiceUpdateManyWithoutSellerNestedInput = {
    create?: XOR<SellerServiceCreateWithoutSellerInput, SellerServiceUncheckedCreateWithoutSellerInput> | SellerServiceCreateWithoutSellerInput[] | SellerServiceUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SellerServiceCreateOrConnectWithoutSellerInput | SellerServiceCreateOrConnectWithoutSellerInput[]
    upsert?: SellerServiceUpsertWithWhereUniqueWithoutSellerInput | SellerServiceUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: SellerServiceCreateManySellerInputEnvelope
    set?: SellerServiceWhereUniqueInput | SellerServiceWhereUniqueInput[]
    disconnect?: SellerServiceWhereUniqueInput | SellerServiceWhereUniqueInput[]
    delete?: SellerServiceWhereUniqueInput | SellerServiceWhereUniqueInput[]
    connect?: SellerServiceWhereUniqueInput | SellerServiceWhereUniqueInput[]
    update?: SellerServiceUpdateWithWhereUniqueWithoutSellerInput | SellerServiceUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: SellerServiceUpdateManyWithWhereWithoutSellerInput | SellerServiceUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: SellerServiceScalarWhereInput | SellerServiceScalarWhereInput[]
  }

  export type UserSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput> | UserSubscriptionCreateWithoutUserInput[] | UserSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput | UserSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: UserSubscriptionUpsertWithWhereUniqueWithoutUserInput | UserSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSubscriptionCreateManyUserInputEnvelope
    set?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    disconnect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    delete?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    update?: UserSubscriptionUpdateWithWhereUniqueWithoutUserInput | UserSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSubscriptionUpdateManyWithWhereWithoutUserInput | UserSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
  }

  export type WishlistItemUpdateManyWithoutUserNestedInput = {
    create?: XOR<WishlistItemCreateWithoutUserInput, WishlistItemUncheckedCreateWithoutUserInput> | WishlistItemCreateWithoutUserInput[] | WishlistItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutUserInput | WishlistItemCreateOrConnectWithoutUserInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutUserInput | WishlistItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WishlistItemCreateManyUserInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutUserInput | WishlistItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutUserInput | WishlistItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TeamCreateWithoutCreatedByInput, TeamUncheckedCreateWithoutCreatedByInput> | TeamCreateWithoutCreatedByInput[] | TeamUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatedByInput | TeamCreateOrConnectWithoutCreatedByInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutCreatedByInput | TeamUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TeamCreateManyCreatedByInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutCreatedByInput | TeamUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutCreatedByInput | TeamUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type TeamMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CartUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutUserInput | CartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutUserInput | CartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CartUpdateManyWithWhereWithoutUserInput | CartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<ProductCreateWithoutSellerInput, ProductUncheckedCreateWithoutSellerInput> | ProductCreateWithoutSellerInput[] | ProductUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSellerInput | ProductCreateOrConnectWithoutSellerInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSellerInput | ProductUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: ProductCreateManySellerInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSellerInput | ProductUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSellerInput | ProductUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<ReviewCreateWithoutBuyerInput, ReviewUncheckedCreateWithoutBuyerInput> | ReviewCreateWithoutBuyerInput[] | ReviewUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBuyerInput | ReviewCreateOrConnectWithoutBuyerInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutBuyerInput | ReviewUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: ReviewCreateManyBuyerInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutBuyerInput | ReviewUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutBuyerInput | ReviewUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CommunityStoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommunityStoryCreateWithoutUserInput, CommunityStoryUncheckedCreateWithoutUserInput> | CommunityStoryCreateWithoutUserInput[] | CommunityStoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityStoryCreateOrConnectWithoutUserInput | CommunityStoryCreateOrConnectWithoutUserInput[]
    upsert?: CommunityStoryUpsertWithWhereUniqueWithoutUserInput | CommunityStoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommunityStoryCreateManyUserInputEnvelope
    set?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
    disconnect?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
    delete?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
    connect?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
    update?: CommunityStoryUpdateWithWhereUniqueWithoutUserInput | CommunityStoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommunityStoryUpdateManyWithWhereWithoutUserInput | CommunityStoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommunityStoryScalarWhereInput | CommunityStoryScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<ReviewCreateWithoutSellerInput, ReviewUncheckedCreateWithoutSellerInput> | ReviewCreateWithoutSellerInput[] | ReviewUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutSellerInput | ReviewCreateOrConnectWithoutSellerInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutSellerInput | ReviewUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: ReviewCreateManySellerInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutSellerInput | ReviewUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutSellerInput | ReviewUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput = {
    create?: XOR<CounterfeitReportCreateWithoutReporterInput, CounterfeitReportUncheckedCreateWithoutReporterInput> | CounterfeitReportCreateWithoutReporterInput[] | CounterfeitReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: CounterfeitReportCreateOrConnectWithoutReporterInput | CounterfeitReportCreateOrConnectWithoutReporterInput[]
    upsert?: CounterfeitReportUpsertWithWhereUniqueWithoutReporterInput | CounterfeitReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: CounterfeitReportCreateManyReporterInputEnvelope
    set?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
    disconnect?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
    delete?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
    connect?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
    update?: CounterfeitReportUpdateWithWhereUniqueWithoutReporterInput | CounterfeitReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: CounterfeitReportUpdateManyWithWhereWithoutReporterInput | CounterfeitReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: CounterfeitReportScalarWhereInput | CounterfeitReportScalarWhereInput[]
  }

  export type SellerApplicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SellerApplicationCreateWithoutUserInput, SellerApplicationUncheckedCreateWithoutUserInput> | SellerApplicationCreateWithoutUserInput[] | SellerApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SellerApplicationCreateOrConnectWithoutUserInput | SellerApplicationCreateOrConnectWithoutUserInput[]
    upsert?: SellerApplicationUpsertWithWhereUniqueWithoutUserInput | SellerApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SellerApplicationCreateManyUserInputEnvelope
    set?: SellerApplicationWhereUniqueInput | SellerApplicationWhereUniqueInput[]
    disconnect?: SellerApplicationWhereUniqueInput | SellerApplicationWhereUniqueInput[]
    delete?: SellerApplicationWhereUniqueInput | SellerApplicationWhereUniqueInput[]
    connect?: SellerApplicationWhereUniqueInput | SellerApplicationWhereUniqueInput[]
    update?: SellerApplicationUpdateWithWhereUniqueWithoutUserInput | SellerApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SellerApplicationUpdateManyWithWhereWithoutUserInput | SellerApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SellerApplicationScalarWhereInput | SellerApplicationScalarWhereInput[]
  }

  export type DisputeUncheckedUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<DisputeCreateWithoutBuyerInput, DisputeUncheckedCreateWithoutBuyerInput> | DisputeCreateWithoutBuyerInput[] | DisputeUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutBuyerInput | DisputeCreateOrConnectWithoutBuyerInput[]
    upsert?: DisputeUpsertWithWhereUniqueWithoutBuyerInput | DisputeUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: DisputeCreateManyBuyerInputEnvelope
    set?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    disconnect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    delete?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    update?: DisputeUpdateWithWhereUniqueWithoutBuyerInput | DisputeUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: DisputeUpdateManyWithWhereWithoutBuyerInput | DisputeUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: DisputeScalarWhereInput | DisputeScalarWhereInput[]
  }

  export type FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<FulfillmentSettingsCreateWithoutSellerInput, FulfillmentSettingsUncheckedCreateWithoutSellerInput> | FulfillmentSettingsCreateWithoutSellerInput[] | FulfillmentSettingsUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: FulfillmentSettingsCreateOrConnectWithoutSellerInput | FulfillmentSettingsCreateOrConnectWithoutSellerInput[]
    upsert?: FulfillmentSettingsUpsertWithWhereUniqueWithoutSellerInput | FulfillmentSettingsUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: FulfillmentSettingsCreateManySellerInputEnvelope
    set?: FulfillmentSettingsWhereUniqueInput | FulfillmentSettingsWhereUniqueInput[]
    disconnect?: FulfillmentSettingsWhereUniqueInput | FulfillmentSettingsWhereUniqueInput[]
    delete?: FulfillmentSettingsWhereUniqueInput | FulfillmentSettingsWhereUniqueInput[]
    connect?: FulfillmentSettingsWhereUniqueInput | FulfillmentSettingsWhereUniqueInput[]
    update?: FulfillmentSettingsUpdateWithWhereUniqueWithoutSellerInput | FulfillmentSettingsUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: FulfillmentSettingsUpdateManyWithWhereWithoutSellerInput | FulfillmentSettingsUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: FulfillmentSettingsScalarWhereInput | FulfillmentSettingsScalarWhereInput[]
  }

  export type KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<KYCDocumentCreateWithoutSellerInput, KYCDocumentUncheckedCreateWithoutSellerInput> | KYCDocumentCreateWithoutSellerInput[] | KYCDocumentUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: KYCDocumentCreateOrConnectWithoutSellerInput | KYCDocumentCreateOrConnectWithoutSellerInput[]
    upsert?: KYCDocumentUpsertWithWhereUniqueWithoutSellerInput | KYCDocumentUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: KYCDocumentCreateManySellerInputEnvelope
    set?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
    disconnect?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
    delete?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
    connect?: KYCDocumentWhereUniqueInput | KYCDocumentWhereUniqueInput[]
    update?: KYCDocumentUpdateWithWhereUniqueWithoutSellerInput | KYCDocumentUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: KYCDocumentUpdateManyWithWhereWithoutSellerInput | KYCDocumentUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: KYCDocumentScalarWhereInput | KYCDocumentScalarWhereInput[]
  }

  export type TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<TaxRegistrationCreateWithoutSellerInput, TaxRegistrationUncheckedCreateWithoutSellerInput> | TaxRegistrationCreateWithoutSellerInput[] | TaxRegistrationUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: TaxRegistrationCreateOrConnectWithoutSellerInput | TaxRegistrationCreateOrConnectWithoutSellerInput[]
    upsert?: TaxRegistrationUpsertWithWhereUniqueWithoutSellerInput | TaxRegistrationUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: TaxRegistrationCreateManySellerInputEnvelope
    set?: TaxRegistrationWhereUniqueInput | TaxRegistrationWhereUniqueInput[]
    disconnect?: TaxRegistrationWhereUniqueInput | TaxRegistrationWhereUniqueInput[]
    delete?: TaxRegistrationWhereUniqueInput | TaxRegistrationWhereUniqueInput[]
    connect?: TaxRegistrationWhereUniqueInput | TaxRegistrationWhereUniqueInput[]
    update?: TaxRegistrationUpdateWithWhereUniqueWithoutSellerInput | TaxRegistrationUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: TaxRegistrationUpdateManyWithWhereWithoutSellerInput | TaxRegistrationUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: TaxRegistrationScalarWhereInput | TaxRegistrationScalarWhereInput[]
  }

  export type ProductViewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductViewCreateWithoutUserInput, ProductViewUncheckedCreateWithoutUserInput> | ProductViewCreateWithoutUserInput[] | ProductViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductViewCreateOrConnectWithoutUserInput | ProductViewCreateOrConnectWithoutUserInput[]
    upsert?: ProductViewUpsertWithWhereUniqueWithoutUserInput | ProductViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductViewCreateManyUserInputEnvelope
    set?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    disconnect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    delete?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    connect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    update?: ProductViewUpdateWithWhereUniqueWithoutUserInput | ProductViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductViewUpdateManyWithWhereWithoutUserInput | ProductViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductViewScalarWhereInput | ProductViewScalarWhereInput[]
  }

  export type SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<SponsoredPlacementCreateWithoutSellerInput, SponsoredPlacementUncheckedCreateWithoutSellerInput> | SponsoredPlacementCreateWithoutSellerInput[] | SponsoredPlacementUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SponsoredPlacementCreateOrConnectWithoutSellerInput | SponsoredPlacementCreateOrConnectWithoutSellerInput[]
    upsert?: SponsoredPlacementUpsertWithWhereUniqueWithoutSellerInput | SponsoredPlacementUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: SponsoredPlacementCreateManySellerInputEnvelope
    set?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
    disconnect?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
    delete?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
    connect?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
    update?: SponsoredPlacementUpdateWithWhereUniqueWithoutSellerInput | SponsoredPlacementUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: SponsoredPlacementUpdateManyWithWhereWithoutSellerInput | SponsoredPlacementUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: SponsoredPlacementScalarWhereInput | SponsoredPlacementScalarWhereInput[]
  }

  export type ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<ServiceOrderCreateWithoutBuyerInput, ServiceOrderUncheckedCreateWithoutBuyerInput> | ServiceOrderCreateWithoutBuyerInput[] | ServiceOrderUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutBuyerInput | ServiceOrderCreateOrConnectWithoutBuyerInput[]
    upsert?: ServiceOrderUpsertWithWhereUniqueWithoutBuyerInput | ServiceOrderUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: ServiceOrderCreateManyBuyerInputEnvelope
    set?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    disconnect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    delete?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    update?: ServiceOrderUpdateWithWhereUniqueWithoutBuyerInput | ServiceOrderUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: ServiceOrderUpdateManyWithWhereWithoutBuyerInput | ServiceOrderUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
  }

  export type ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<ServiceOrderCreateWithoutSellerInput, ServiceOrderUncheckedCreateWithoutSellerInput> | ServiceOrderCreateWithoutSellerInput[] | ServiceOrderUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutSellerInput | ServiceOrderCreateOrConnectWithoutSellerInput[]
    upsert?: ServiceOrderUpsertWithWhereUniqueWithoutSellerInput | ServiceOrderUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: ServiceOrderCreateManySellerInputEnvelope
    set?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    disconnect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    delete?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    update?: ServiceOrderUpdateWithWhereUniqueWithoutSellerInput | ServiceOrderUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: ServiceOrderUpdateManyWithWhereWithoutSellerInput | ServiceOrderUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
  }

  export type SellerServiceUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<SellerServiceCreateWithoutSellerInput, SellerServiceUncheckedCreateWithoutSellerInput> | SellerServiceCreateWithoutSellerInput[] | SellerServiceUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SellerServiceCreateOrConnectWithoutSellerInput | SellerServiceCreateOrConnectWithoutSellerInput[]
    upsert?: SellerServiceUpsertWithWhereUniqueWithoutSellerInput | SellerServiceUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: SellerServiceCreateManySellerInputEnvelope
    set?: SellerServiceWhereUniqueInput | SellerServiceWhereUniqueInput[]
    disconnect?: SellerServiceWhereUniqueInput | SellerServiceWhereUniqueInput[]
    delete?: SellerServiceWhereUniqueInput | SellerServiceWhereUniqueInput[]
    connect?: SellerServiceWhereUniqueInput | SellerServiceWhereUniqueInput[]
    update?: SellerServiceUpdateWithWhereUniqueWithoutSellerInput | SellerServiceUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: SellerServiceUpdateManyWithWhereWithoutSellerInput | SellerServiceUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: SellerServiceScalarWhereInput | SellerServiceScalarWhereInput[]
  }

  export type UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput> | UserSubscriptionCreateWithoutUserInput[] | UserSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput | UserSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: UserSubscriptionUpsertWithWhereUniqueWithoutUserInput | UserSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSubscriptionCreateManyUserInputEnvelope
    set?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    disconnect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    delete?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    update?: UserSubscriptionUpdateWithWhereUniqueWithoutUserInput | UserSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSubscriptionUpdateManyWithWhereWithoutUserInput | UserSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
  }

  export type WishlistItemUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WishlistItemCreateWithoutUserInput, WishlistItemUncheckedCreateWithoutUserInput> | WishlistItemCreateWithoutUserInput[] | WishlistItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutUserInput | WishlistItemCreateOrConnectWithoutUserInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutUserInput | WishlistItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WishlistItemCreateManyUserInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutUserInput | WishlistItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutUserInput | WishlistItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TeamCreateWithoutCreatedByInput, TeamUncheckedCreateWithoutCreatedByInput> | TeamCreateWithoutCreatedByInput[] | TeamUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatedByInput | TeamCreateOrConnectWithoutCreatedByInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutCreatedByInput | TeamUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TeamCreateManyCreatedByInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutCreatedByInput | TeamUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutCreatedByInput | TeamUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutProductsInput = {
    create?: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductsInput
    connect?: UserWhereUniqueInput
  }

  export type InventoryCreateNestedOneWithoutProductInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput
    connect?: InventoryWhereUniqueInput
  }

  export type ProductViewCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductViewCreateWithoutProductInput, ProductViewUncheckedCreateWithoutProductInput> | ProductViewCreateWithoutProductInput[] | ProductViewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductViewCreateOrConnectWithoutProductInput | ProductViewCreateOrConnectWithoutProductInput[]
    createMany?: ProductViewCreateManyProductInputEnvelope
    connect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
  }

  export type CartItemCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutProductInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CommunityStoryCreateNestedManyWithoutProductInput = {
    create?: XOR<CommunityStoryCreateWithoutProductInput, CommunityStoryUncheckedCreateWithoutProductInput> | CommunityStoryCreateWithoutProductInput[] | CommunityStoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CommunityStoryCreateOrConnectWithoutProductInput | CommunityStoryCreateOrConnectWithoutProductInput[]
    createMany?: CommunityStoryCreateManyProductInputEnvelope
    connect?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
  }

  export type CounterfeitReportCreateNestedManyWithoutProductInput = {
    create?: XOR<CounterfeitReportCreateWithoutProductInput, CounterfeitReportUncheckedCreateWithoutProductInput> | CounterfeitReportCreateWithoutProductInput[] | CounterfeitReportUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CounterfeitReportCreateOrConnectWithoutProductInput | CounterfeitReportCreateOrConnectWithoutProductInput[]
    createMany?: CounterfeitReportCreateManyProductInputEnvelope
    connect?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
  }

  export type SponsoredPlacementCreateNestedManyWithoutProductInput = {
    create?: XOR<SponsoredPlacementCreateWithoutProductInput, SponsoredPlacementUncheckedCreateWithoutProductInput> | SponsoredPlacementCreateWithoutProductInput[] | SponsoredPlacementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SponsoredPlacementCreateOrConnectWithoutProductInput | SponsoredPlacementCreateOrConnectWithoutProductInput[]
    createMany?: SponsoredPlacementCreateManyProductInputEnvelope
    connect?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
  }

  export type WishlistItemCreateNestedManyWithoutProductInput = {
    create?: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput> | WishlistItemCreateWithoutProductInput[] | WishlistItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[]
    createMany?: WishlistItemCreateManyProductInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput
    connect?: InventoryWhereUniqueInput
  }

  export type ProductViewUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductViewCreateWithoutProductInput, ProductViewUncheckedCreateWithoutProductInput> | ProductViewCreateWithoutProductInput[] | ProductViewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductViewCreateOrConnectWithoutProductInput | ProductViewCreateOrConnectWithoutProductInput[]
    createMany?: ProductViewCreateManyProductInputEnvelope
    connect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CommunityStoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CommunityStoryCreateWithoutProductInput, CommunityStoryUncheckedCreateWithoutProductInput> | CommunityStoryCreateWithoutProductInput[] | CommunityStoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CommunityStoryCreateOrConnectWithoutProductInput | CommunityStoryCreateOrConnectWithoutProductInput[]
    createMany?: CommunityStoryCreateManyProductInputEnvelope
    connect?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
  }

  export type CounterfeitReportUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CounterfeitReportCreateWithoutProductInput, CounterfeitReportUncheckedCreateWithoutProductInput> | CounterfeitReportCreateWithoutProductInput[] | CounterfeitReportUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CounterfeitReportCreateOrConnectWithoutProductInput | CounterfeitReportCreateOrConnectWithoutProductInput[]
    createMany?: CounterfeitReportCreateManyProductInputEnvelope
    connect?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
  }

  export type SponsoredPlacementUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SponsoredPlacementCreateWithoutProductInput, SponsoredPlacementUncheckedCreateWithoutProductInput> | SponsoredPlacementCreateWithoutProductInput[] | SponsoredPlacementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SponsoredPlacementCreateOrConnectWithoutProductInput | SponsoredPlacementCreateOrConnectWithoutProductInput[]
    createMany?: SponsoredPlacementCreateManyProductInputEnvelope
    connect?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
  }

  export type WishlistItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput> | WishlistItemCreateWithoutProductInput[] | WishlistItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[]
    createMany?: WishlistItemCreateManyProductInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductsInput
    upsert?: UserUpsertWithoutProductsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductsInput, UserUpdateWithoutProductsInput>, UserUncheckedUpdateWithoutProductsInput>
  }

  export type InventoryUpdateOneWithoutProductNestedInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput
    upsert?: InventoryUpsertWithoutProductInput
    disconnect?: InventoryWhereInput | boolean
    delete?: InventoryWhereInput | boolean
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutProductInput, InventoryUpdateWithoutProductInput>, InventoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductViewUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductViewCreateWithoutProductInput, ProductViewUncheckedCreateWithoutProductInput> | ProductViewCreateWithoutProductInput[] | ProductViewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductViewCreateOrConnectWithoutProductInput | ProductViewCreateOrConnectWithoutProductInput[]
    upsert?: ProductViewUpsertWithWhereUniqueWithoutProductInput | ProductViewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductViewCreateManyProductInputEnvelope
    set?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    disconnect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    delete?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    connect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    update?: ProductViewUpdateWithWhereUniqueWithoutProductInput | ProductViewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductViewUpdateManyWithWhereWithoutProductInput | ProductViewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductViewScalarWhereInput | ProductViewScalarWhereInput[]
  }

  export type CartItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProductInput | ReviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProductInput | ReviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProductInput | ReviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CommunityStoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<CommunityStoryCreateWithoutProductInput, CommunityStoryUncheckedCreateWithoutProductInput> | CommunityStoryCreateWithoutProductInput[] | CommunityStoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CommunityStoryCreateOrConnectWithoutProductInput | CommunityStoryCreateOrConnectWithoutProductInput[]
    upsert?: CommunityStoryUpsertWithWhereUniqueWithoutProductInput | CommunityStoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CommunityStoryCreateManyProductInputEnvelope
    set?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
    disconnect?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
    delete?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
    connect?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
    update?: CommunityStoryUpdateWithWhereUniqueWithoutProductInput | CommunityStoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CommunityStoryUpdateManyWithWhereWithoutProductInput | CommunityStoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CommunityStoryScalarWhereInput | CommunityStoryScalarWhereInput[]
  }

  export type CounterfeitReportUpdateManyWithoutProductNestedInput = {
    create?: XOR<CounterfeitReportCreateWithoutProductInput, CounterfeitReportUncheckedCreateWithoutProductInput> | CounterfeitReportCreateWithoutProductInput[] | CounterfeitReportUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CounterfeitReportCreateOrConnectWithoutProductInput | CounterfeitReportCreateOrConnectWithoutProductInput[]
    upsert?: CounterfeitReportUpsertWithWhereUniqueWithoutProductInput | CounterfeitReportUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CounterfeitReportCreateManyProductInputEnvelope
    set?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
    disconnect?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
    delete?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
    connect?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
    update?: CounterfeitReportUpdateWithWhereUniqueWithoutProductInput | CounterfeitReportUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CounterfeitReportUpdateManyWithWhereWithoutProductInput | CounterfeitReportUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CounterfeitReportScalarWhereInput | CounterfeitReportScalarWhereInput[]
  }

  export type SponsoredPlacementUpdateManyWithoutProductNestedInput = {
    create?: XOR<SponsoredPlacementCreateWithoutProductInput, SponsoredPlacementUncheckedCreateWithoutProductInput> | SponsoredPlacementCreateWithoutProductInput[] | SponsoredPlacementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SponsoredPlacementCreateOrConnectWithoutProductInput | SponsoredPlacementCreateOrConnectWithoutProductInput[]
    upsert?: SponsoredPlacementUpsertWithWhereUniqueWithoutProductInput | SponsoredPlacementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SponsoredPlacementCreateManyProductInputEnvelope
    set?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
    disconnect?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
    delete?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
    connect?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
    update?: SponsoredPlacementUpdateWithWhereUniqueWithoutProductInput | SponsoredPlacementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SponsoredPlacementUpdateManyWithWhereWithoutProductInput | SponsoredPlacementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SponsoredPlacementScalarWhereInput | SponsoredPlacementScalarWhereInput[]
  }

  export type WishlistItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput> | WishlistItemCreateWithoutProductInput[] | WishlistItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutProductInput | WishlistItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WishlistItemCreateManyProductInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutProductInput | WishlistItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutProductInput | WishlistItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput
    upsert?: InventoryUpsertWithoutProductInput
    disconnect?: InventoryWhereInput | boolean
    delete?: InventoryWhereInput | boolean
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutProductInput, InventoryUpdateWithoutProductInput>, InventoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductViewUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductViewCreateWithoutProductInput, ProductViewUncheckedCreateWithoutProductInput> | ProductViewCreateWithoutProductInput[] | ProductViewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductViewCreateOrConnectWithoutProductInput | ProductViewCreateOrConnectWithoutProductInput[]
    upsert?: ProductViewUpsertWithWhereUniqueWithoutProductInput | ProductViewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductViewCreateManyProductInputEnvelope
    set?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    disconnect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    delete?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    connect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    update?: ProductViewUpdateWithWhereUniqueWithoutProductInput | ProductViewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductViewUpdateManyWithWhereWithoutProductInput | ProductViewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductViewScalarWhereInput | ProductViewScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProductInput | ReviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProductInput | ReviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProductInput | ReviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CommunityStoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CommunityStoryCreateWithoutProductInput, CommunityStoryUncheckedCreateWithoutProductInput> | CommunityStoryCreateWithoutProductInput[] | CommunityStoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CommunityStoryCreateOrConnectWithoutProductInput | CommunityStoryCreateOrConnectWithoutProductInput[]
    upsert?: CommunityStoryUpsertWithWhereUniqueWithoutProductInput | CommunityStoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CommunityStoryCreateManyProductInputEnvelope
    set?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
    disconnect?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
    delete?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
    connect?: CommunityStoryWhereUniqueInput | CommunityStoryWhereUniqueInput[]
    update?: CommunityStoryUpdateWithWhereUniqueWithoutProductInput | CommunityStoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CommunityStoryUpdateManyWithWhereWithoutProductInput | CommunityStoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CommunityStoryScalarWhereInput | CommunityStoryScalarWhereInput[]
  }

  export type CounterfeitReportUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CounterfeitReportCreateWithoutProductInput, CounterfeitReportUncheckedCreateWithoutProductInput> | CounterfeitReportCreateWithoutProductInput[] | CounterfeitReportUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CounterfeitReportCreateOrConnectWithoutProductInput | CounterfeitReportCreateOrConnectWithoutProductInput[]
    upsert?: CounterfeitReportUpsertWithWhereUniqueWithoutProductInput | CounterfeitReportUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CounterfeitReportCreateManyProductInputEnvelope
    set?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
    disconnect?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
    delete?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
    connect?: CounterfeitReportWhereUniqueInput | CounterfeitReportWhereUniqueInput[]
    update?: CounterfeitReportUpdateWithWhereUniqueWithoutProductInput | CounterfeitReportUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CounterfeitReportUpdateManyWithWhereWithoutProductInput | CounterfeitReportUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CounterfeitReportScalarWhereInput | CounterfeitReportScalarWhereInput[]
  }

  export type SponsoredPlacementUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SponsoredPlacementCreateWithoutProductInput, SponsoredPlacementUncheckedCreateWithoutProductInput> | SponsoredPlacementCreateWithoutProductInput[] | SponsoredPlacementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SponsoredPlacementCreateOrConnectWithoutProductInput | SponsoredPlacementCreateOrConnectWithoutProductInput[]
    upsert?: SponsoredPlacementUpsertWithWhereUniqueWithoutProductInput | SponsoredPlacementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SponsoredPlacementCreateManyProductInputEnvelope
    set?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
    disconnect?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
    delete?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
    connect?: SponsoredPlacementWhereUniqueInput | SponsoredPlacementWhereUniqueInput[]
    update?: SponsoredPlacementUpdateWithWhereUniqueWithoutProductInput | SponsoredPlacementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SponsoredPlacementUpdateManyWithWhereWithoutProductInput | SponsoredPlacementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SponsoredPlacementScalarWhereInput | SponsoredPlacementScalarWhereInput[]
  }

  export type WishlistItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput> | WishlistItemCreateWithoutProductInput[] | WishlistItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutProductInput | WishlistItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WishlistItemCreateManyProductInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutProductInput | WishlistItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutProductInput | WishlistItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutInventoryInput = {
    create?: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryInput
    upsert?: ProductUpsertWithoutInventoryInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInventoryInput, ProductUpdateWithoutInventoryInput>, ProductUncheckedUpdateWithoutInventoryInput>
  }

  export type UserCreateNestedOneWithoutCartsInput = {
    create?: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartsInput
    connect?: UserWhereUniqueInput
  }

  export type CartItemCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCartsNestedInput = {
    create?: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartsInput
    upsert?: UserUpsertWithoutCartsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCartsInput, UserUpdateWithoutCartsInput>, UserUncheckedUpdateWithoutCartsInput>
  }

  export type CartItemUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type CartCreateNestedOneWithoutItemsInput = {
    create?: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CartCreateOrConnectWithoutItemsInput
    connect?: CartWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCartItemsInput = {
    create?: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type CartUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CartCreateOrConnectWithoutItemsInput
    upsert?: CartUpsertWithoutItemsInput
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutItemsInput, CartUpdateWithoutItemsInput>, CartUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutCartItemsNestedInput = {
    create?: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemsInput
    upsert?: ProductUpsertWithoutCartItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCartItemsInput, ProductUpdateWithoutCartItemsInput>, ProductUncheckedUpdateWithoutCartItemsInput>
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type PaymentCreateNestedOneWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput
    connect?: PaymentWhereUniqueInput
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput
    connect?: PaymentWhereUniqueInput
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type PaymentUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput
    upsert?: PaymentUpsertWithoutOrderInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutOrderInput, PaymentUpdateWithoutOrderInput>, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput
    upsert?: PaymentUpsertWithoutOrderInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutOrderInput, PaymentUpdateWithoutOrderInput>, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type DisputeCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<DisputeCreateWithoutOrderItemInput, DisputeUncheckedCreateWithoutOrderItemInput> | DisputeCreateWithoutOrderItemInput[] | DisputeUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutOrderItemInput | DisputeCreateOrConnectWithoutOrderItemInput[]
    createMany?: DisputeCreateManyOrderItemInputEnvelope
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<ReviewCreateWithoutOrderItemInput, ReviewUncheckedCreateWithoutOrderItemInput> | ReviewCreateWithoutOrderItemInput[] | ReviewUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderItemInput | ReviewCreateOrConnectWithoutOrderItemInput[]
    createMany?: ReviewCreateManyOrderItemInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type DisputeUncheckedCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<DisputeCreateWithoutOrderItemInput, DisputeUncheckedCreateWithoutOrderItemInput> | DisputeCreateWithoutOrderItemInput[] | DisputeUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutOrderItemInput | DisputeCreateOrConnectWithoutOrderItemInput[]
    createMany?: DisputeCreateManyOrderItemInputEnvelope
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<ReviewCreateWithoutOrderItemInput, ReviewUncheckedCreateWithoutOrderItemInput> | ReviewCreateWithoutOrderItemInput[] | ReviewUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderItemInput | ReviewCreateOrConnectWithoutOrderItemInput[]
    createMany?: ReviewCreateManyOrderItemInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type EnumPayoutStatusFieldUpdateOperationsInput = {
    set?: $Enums.PayoutStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumFulfillmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.FulfillmentStatus
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type DisputeUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<DisputeCreateWithoutOrderItemInput, DisputeUncheckedCreateWithoutOrderItemInput> | DisputeCreateWithoutOrderItemInput[] | DisputeUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutOrderItemInput | DisputeCreateOrConnectWithoutOrderItemInput[]
    upsert?: DisputeUpsertWithWhereUniqueWithoutOrderItemInput | DisputeUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: DisputeCreateManyOrderItemInputEnvelope
    set?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    disconnect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    delete?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    update?: DisputeUpdateWithWhereUniqueWithoutOrderItemInput | DisputeUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: DisputeUpdateManyWithWhereWithoutOrderItemInput | DisputeUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: DisputeScalarWhereInput | DisputeScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<ReviewCreateWithoutOrderItemInput, ReviewUncheckedCreateWithoutOrderItemInput> | ReviewCreateWithoutOrderItemInput[] | ReviewUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderItemInput | ReviewCreateOrConnectWithoutOrderItemInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutOrderItemInput | ReviewUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: ReviewCreateManyOrderItemInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutOrderItemInput | ReviewUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutOrderItemInput | ReviewUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type DisputeUncheckedUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<DisputeCreateWithoutOrderItemInput, DisputeUncheckedCreateWithoutOrderItemInput> | DisputeCreateWithoutOrderItemInput[] | DisputeUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutOrderItemInput | DisputeCreateOrConnectWithoutOrderItemInput[]
    upsert?: DisputeUpsertWithWhereUniqueWithoutOrderItemInput | DisputeUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: DisputeCreateManyOrderItemInputEnvelope
    set?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    disconnect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    delete?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    update?: DisputeUpdateWithWhereUniqueWithoutOrderItemInput | DisputeUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: DisputeUpdateManyWithWhereWithoutOrderItemInput | DisputeUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: DisputeScalarWhereInput | DisputeScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<ReviewCreateWithoutOrderItemInput, ReviewUncheckedCreateWithoutOrderItemInput> | ReviewCreateWithoutOrderItemInput[] | ReviewUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderItemInput | ReviewCreateOrConnectWithoutOrderItemInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutOrderItemInput | ReviewUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: ReviewCreateManyOrderItemInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutOrderItemInput | ReviewUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutOrderItemInput | ReviewUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutPaymentInput = {
    create?: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentInput
    connect?: OrderWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type OrderUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentInput
    upsert?: OrderUpsertWithoutPaymentInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentInput, OrderUpdateWithoutPaymentInput>, OrderUncheckedUpdateWithoutPaymentInput>
  }

  export type UserCreateNestedOneWithoutFulfillmentSettingsInput = {
    create?: XOR<UserCreateWithoutFulfillmentSettingsInput, UserUncheckedCreateWithoutFulfillmentSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFulfillmentSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFulfillmentSettingsNestedInput = {
    create?: XOR<UserCreateWithoutFulfillmentSettingsInput, UserUncheckedCreateWithoutFulfillmentSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFulfillmentSettingsInput
    upsert?: UserUpsertWithoutFulfillmentSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFulfillmentSettingsInput, UserUpdateWithoutFulfillmentSettingsInput>, UserUncheckedUpdateWithoutFulfillmentSettingsInput>
  }

  export type UserCreateNestedOneWithoutKycDocumentsInput = {
    create?: XOR<UserCreateWithoutKycDocumentsInput, UserUncheckedCreateWithoutKycDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutKycDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumKYCStatusFieldUpdateOperationsInput = {
    set?: $Enums.KYCStatus
  }

  export type UserUpdateOneRequiredWithoutKycDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutKycDocumentsInput, UserUncheckedCreateWithoutKycDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutKycDocumentsInput
    upsert?: UserUpsertWithoutKycDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKycDocumentsInput, UserUpdateWithoutKycDocumentsInput>, UserUncheckedUpdateWithoutKycDocumentsInput>
  }

  export type UserCreateNestedOneWithoutTaxRegistrationsInput = {
    create?: XOR<UserCreateWithoutTaxRegistrationsInput, UserUncheckedCreateWithoutTaxRegistrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaxRegistrationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTaxStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaxStatus
  }

  export type UserUpdateOneRequiredWithoutTaxRegistrationsNestedInput = {
    create?: XOR<UserCreateWithoutTaxRegistrationsInput, UserUncheckedCreateWithoutTaxRegistrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaxRegistrationsInput
    upsert?: UserUpsertWithoutTaxRegistrationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaxRegistrationsInput, UserUpdateWithoutTaxRegistrationsInput>, UserUncheckedUpdateWithoutTaxRegistrationsInput>
  }

  export type UserCreateNestedOneWithoutReportedProductsInput = {
    create?: XOR<UserCreateWithoutReportedProductsInput, UserUncheckedCreateWithoutReportedProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedProductsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutReportedInInput = {
    create?: XOR<ProductCreateWithoutReportedInInput, ProductUncheckedCreateWithoutReportedInInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReportedInInput
    connect?: ProductWhereUniqueInput
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type UserUpdateOneRequiredWithoutReportedProductsNestedInput = {
    create?: XOR<UserCreateWithoutReportedProductsInput, UserUncheckedCreateWithoutReportedProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedProductsInput
    upsert?: UserUpsertWithoutReportedProductsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportedProductsInput, UserUpdateWithoutReportedProductsInput>, UserUncheckedUpdateWithoutReportedProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutReportedInNestedInput = {
    create?: XOR<ProductCreateWithoutReportedInInput, ProductUncheckedCreateWithoutReportedInInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReportedInInput
    upsert?: ProductUpsertWithoutReportedInInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutReportedInInput, ProductUpdateWithoutReportedInInput>, ProductUncheckedUpdateWithoutReportedInInput>
  }

  export type UserCreateNestedOneWithoutSellerApplicationsInput = {
    create?: XOR<UserCreateWithoutSellerApplicationsInput, UserUncheckedCreateWithoutSellerApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSellerApplicationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationStatus
  }

  export type UserUpdateOneRequiredWithoutSellerApplicationsNestedInput = {
    create?: XOR<UserCreateWithoutSellerApplicationsInput, UserUncheckedCreateWithoutSellerApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSellerApplicationsInput
    upsert?: UserUpsertWithoutSellerApplicationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSellerApplicationsInput, UserUpdateWithoutSellerApplicationsInput>, UserUncheckedUpdateWithoutSellerApplicationsInput>
  }

  export type OrderItemCreateNestedOneWithoutDisputesInput = {
    create?: XOR<OrderItemCreateWithoutDisputesInput, OrderItemUncheckedCreateWithoutDisputesInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutDisputesInput
    connect?: OrderItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDisputesInput = {
    create?: XOR<UserCreateWithoutDisputesInput, UserUncheckedCreateWithoutDisputesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDisputesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDisputeReasonFieldUpdateOperationsInput = {
    set?: $Enums.DisputeReason
  }

  export type EnumDisputeStatusFieldUpdateOperationsInput = {
    set?: $Enums.DisputeStatus
  }

  export type OrderItemUpdateOneRequiredWithoutDisputesNestedInput = {
    create?: XOR<OrderItemCreateWithoutDisputesInput, OrderItemUncheckedCreateWithoutDisputesInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutDisputesInput
    upsert?: OrderItemUpsertWithoutDisputesInput
    connect?: OrderItemWhereUniqueInput
    update?: XOR<XOR<OrderItemUpdateToOneWithWhereWithoutDisputesInput, OrderItemUpdateWithoutDisputesInput>, OrderItemUncheckedUpdateWithoutDisputesInput>
  }

  export type UserUpdateOneRequiredWithoutDisputesNestedInput = {
    create?: XOR<UserCreateWithoutDisputesInput, UserUncheckedCreateWithoutDisputesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDisputesInput
    upsert?: UserUpsertWithoutDisputesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDisputesInput, UserUpdateWithoutDisputesInput>, UserUncheckedUpdateWithoutDisputesInput>
  }

  export type OrderItemCreateNestedOneWithoutReviewsInput = {
    create?: XOR<OrderItemCreateWithoutReviewsInput, OrderItemUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutReviewsInput
    connect?: OrderItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSellerReviewsInput = {
    create?: XOR<UserCreateWithoutSellerReviewsInput, UserUncheckedCreateWithoutSellerReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSellerReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutProductReviewsInput = {
    create?: XOR<ProductCreateWithoutProductReviewsInput, ProductUncheckedCreateWithoutProductReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductReviewsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderItemUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<OrderItemCreateWithoutReviewsInput, OrderItemUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutReviewsInput
    upsert?: OrderItemUpsertWithoutReviewsInput
    connect?: OrderItemWhereUniqueInput
    update?: XOR<XOR<OrderItemUpdateToOneWithWhereWithoutReviewsInput, OrderItemUpdateWithoutReviewsInput>, OrderItemUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutSellerReviewsNestedInput = {
    create?: XOR<UserCreateWithoutSellerReviewsInput, UserUncheckedCreateWithoutSellerReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSellerReviewsInput
    upsert?: UserUpsertWithoutSellerReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSellerReviewsInput, UserUpdateWithoutSellerReviewsInput>, UserUncheckedUpdateWithoutSellerReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type ProductUpdateOneRequiredWithoutProductReviewsNestedInput = {
    create?: XOR<ProductCreateWithoutProductReviewsInput, ProductUncheckedCreateWithoutProductReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductReviewsInput
    upsert?: ProductUpsertWithoutProductReviewsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductReviewsInput, ProductUpdateWithoutProductReviewsInput>, ProductUncheckedUpdateWithoutProductReviewsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutStoriesInput = {
    create?: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoriesInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutStoriesInput = {
    create?: XOR<ProductCreateWithoutStoriesInput, ProductUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStoriesInput
    connect?: ProductWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStoriesNestedInput = {
    create?: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoriesInput
    upsert?: UserUpsertWithoutStoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStoriesInput, UserUpdateWithoutStoriesInput>, UserUncheckedUpdateWithoutStoriesInput>
  }

  export type ProductUpdateOneRequiredWithoutStoriesNestedInput = {
    create?: XOR<ProductCreateWithoutStoriesInput, ProductUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStoriesInput
    upsert?: ProductUpsertWithoutStoriesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStoriesInput, ProductUpdateWithoutStoriesInput>, ProductUncheckedUpdateWithoutStoriesInput>
  }

  export type UserCreateNestedOneWithoutProductViewsInput = {
    create?: XOR<UserCreateWithoutProductViewsInput, UserUncheckedCreateWithoutProductViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductViewsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutViewsInput = {
    create?: XOR<ProductCreateWithoutViewsInput, ProductUncheckedCreateWithoutViewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutViewsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProductViewsNestedInput = {
    create?: XOR<UserCreateWithoutProductViewsInput, UserUncheckedCreateWithoutProductViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductViewsInput
    upsert?: UserUpsertWithoutProductViewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductViewsInput, UserUpdateWithoutProductViewsInput>, UserUncheckedUpdateWithoutProductViewsInput>
  }

  export type ProductUpdateOneRequiredWithoutViewsNestedInput = {
    create?: XOR<ProductCreateWithoutViewsInput, ProductUncheckedCreateWithoutViewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutViewsInput
    upsert?: ProductUpsertWithoutViewsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutViewsInput, ProductUpdateWithoutViewsInput>, ProductUncheckedUpdateWithoutViewsInput>
  }

  export type UserCreateNestedOneWithoutSponsoredPlacementsInput = {
    create?: XOR<UserCreateWithoutSponsoredPlacementsInput, UserUncheckedCreateWithoutSponsoredPlacementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSponsoredPlacementsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSponsoredPlacementsInput = {
    create?: XOR<ProductCreateWithoutSponsoredPlacementsInput, ProductUncheckedCreateWithoutSponsoredPlacementsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSponsoredPlacementsInput
    connect?: ProductWhereUniqueInput
  }

  export type EnumSponsoredPlacementStatusFieldUpdateOperationsInput = {
    set?: $Enums.SponsoredPlacementStatus
  }

  export type UserUpdateOneRequiredWithoutSponsoredPlacementsNestedInput = {
    create?: XOR<UserCreateWithoutSponsoredPlacementsInput, UserUncheckedCreateWithoutSponsoredPlacementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSponsoredPlacementsInput
    upsert?: UserUpsertWithoutSponsoredPlacementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSponsoredPlacementsInput, UserUpdateWithoutSponsoredPlacementsInput>, UserUncheckedUpdateWithoutSponsoredPlacementsInput>
  }

  export type ProductUpdateOneRequiredWithoutSponsoredPlacementsNestedInput = {
    create?: XOR<ProductCreateWithoutSponsoredPlacementsInput, ProductUncheckedCreateWithoutSponsoredPlacementsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSponsoredPlacementsInput
    upsert?: ProductUpsertWithoutSponsoredPlacementsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSponsoredPlacementsInput, ProductUpdateWithoutSponsoredPlacementsInput>, ProductUncheckedUpdateWithoutSponsoredPlacementsInput>
  }

  export type UserCreateNestedOneWithoutSellerServicesInput = {
    create?: XOR<UserCreateWithoutSellerServicesInput, UserUncheckedCreateWithoutSellerServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSellerServicesInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceOrderCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceOrderCreateWithoutServiceInput, ServiceOrderUncheckedCreateWithoutServiceInput> | ServiceOrderCreateWithoutServiceInput[] | ServiceOrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutServiceInput | ServiceOrderCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceOrderCreateManyServiceInputEnvelope
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
  }

  export type ServiceOrderUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceOrderCreateWithoutServiceInput, ServiceOrderUncheckedCreateWithoutServiceInput> | ServiceOrderCreateWithoutServiceInput[] | ServiceOrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutServiceInput | ServiceOrderCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceOrderCreateManyServiceInputEnvelope
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSellerServicesNestedInput = {
    create?: XOR<UserCreateWithoutSellerServicesInput, UserUncheckedCreateWithoutSellerServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSellerServicesInput
    upsert?: UserUpsertWithoutSellerServicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSellerServicesInput, UserUpdateWithoutSellerServicesInput>, UserUncheckedUpdateWithoutSellerServicesInput>
  }

  export type ServiceOrderUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceOrderCreateWithoutServiceInput, ServiceOrderUncheckedCreateWithoutServiceInput> | ServiceOrderCreateWithoutServiceInput[] | ServiceOrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutServiceInput | ServiceOrderCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceOrderUpsertWithWhereUniqueWithoutServiceInput | ServiceOrderUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceOrderCreateManyServiceInputEnvelope
    set?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    disconnect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    delete?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    update?: ServiceOrderUpdateWithWhereUniqueWithoutServiceInput | ServiceOrderUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceOrderUpdateManyWithWhereWithoutServiceInput | ServiceOrderUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
  }

  export type ServiceOrderUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceOrderCreateWithoutServiceInput, ServiceOrderUncheckedCreateWithoutServiceInput> | ServiceOrderCreateWithoutServiceInput[] | ServiceOrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutServiceInput | ServiceOrderCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceOrderUpsertWithWhereUniqueWithoutServiceInput | ServiceOrderUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceOrderCreateManyServiceInputEnvelope
    set?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    disconnect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    delete?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    update?: ServiceOrderUpdateWithWhereUniqueWithoutServiceInput | ServiceOrderUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceOrderUpdateManyWithWhereWithoutServiceInput | ServiceOrderUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
  }

  export type SellerServiceCreateNestedOneWithoutOrdersInput = {
    create?: XOR<SellerServiceCreateWithoutOrdersInput, SellerServiceUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: SellerServiceCreateOrConnectWithoutOrdersInput
    connect?: SellerServiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutServiceOrdersAsBuyerInput = {
    create?: XOR<UserCreateWithoutServiceOrdersAsBuyerInput, UserUncheckedCreateWithoutServiceOrdersAsBuyerInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceOrdersAsBuyerInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutServiceOrdersAsSellerInput = {
    create?: XOR<UserCreateWithoutServiceOrdersAsSellerInput, UserUncheckedCreateWithoutServiceOrdersAsSellerInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceOrdersAsSellerInput
    connect?: UserWhereUniqueInput
  }

  export type EnumServiceOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.ServiceOrderStatus
  }

  export type SellerServiceUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<SellerServiceCreateWithoutOrdersInput, SellerServiceUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: SellerServiceCreateOrConnectWithoutOrdersInput
    upsert?: SellerServiceUpsertWithoutOrdersInput
    connect?: SellerServiceWhereUniqueInput
    update?: XOR<XOR<SellerServiceUpdateToOneWithWhereWithoutOrdersInput, SellerServiceUpdateWithoutOrdersInput>, SellerServiceUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateOneRequiredWithoutServiceOrdersAsBuyerNestedInput = {
    create?: XOR<UserCreateWithoutServiceOrdersAsBuyerInput, UserUncheckedCreateWithoutServiceOrdersAsBuyerInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceOrdersAsBuyerInput
    upsert?: UserUpsertWithoutServiceOrdersAsBuyerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServiceOrdersAsBuyerInput, UserUpdateWithoutServiceOrdersAsBuyerInput>, UserUncheckedUpdateWithoutServiceOrdersAsBuyerInput>
  }

  export type UserUpdateOneRequiredWithoutServiceOrdersAsSellerNestedInput = {
    create?: XOR<UserCreateWithoutServiceOrdersAsSellerInput, UserUncheckedCreateWithoutServiceOrdersAsSellerInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceOrdersAsSellerInput
    upsert?: UserUpsertWithoutServiceOrdersAsSellerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServiceOrdersAsSellerInput, UserUpdateWithoutServiceOrdersAsSellerInput>, UserUncheckedUpdateWithoutServiceOrdersAsSellerInput>
  }

  export type SubscriptionPlanCreatefeaturesInput = {
    set: string[]
  }

  export type UserSubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput> | UserSubscriptionCreateWithoutPlanInput[] | UserSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutPlanInput | UserSubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: UserSubscriptionCreateManyPlanInputEnvelope
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
  }

  export type UserSubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput> | UserSubscriptionCreateWithoutPlanInput[] | UserSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutPlanInput | UserSubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: UserSubscriptionCreateManyPlanInputEnvelope
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
  }

  export type SubscriptionPlanUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserSubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput> | UserSubscriptionCreateWithoutPlanInput[] | UserSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutPlanInput | UserSubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput | UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: UserSubscriptionCreateManyPlanInputEnvelope
    set?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    disconnect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    delete?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    update?: UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput | UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: UserSubscriptionUpdateManyWithWhereWithoutPlanInput | UserSubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
  }

  export type UserSubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput> | UserSubscriptionCreateWithoutPlanInput[] | UserSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutPlanInput | UserSubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput | UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: UserSubscriptionCreateManyPlanInputEnvelope
    set?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    disconnect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    delete?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    update?: UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput | UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: UserSubscriptionUpdateManyWithWhereWithoutPlanInput | UserSubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type UserUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionsInput, UserUpdateWithoutSubscriptionsInput>, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: SubscriptionPlanUpsertWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput, SubscriptionPlanUpdateWithoutSubscriptionsInput>, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type ApiPartnerCreatepermissionsInput = {
    set: string[]
  }

  export type EnumPartnerStatusFieldUpdateOperationsInput = {
    set?: $Enums.PartnerStatus
  }

  export type ApiPartnerUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserCreateNestedOneWithoutWishlistItemsInput = {
    create?: XOR<UserCreateWithoutWishlistItemsInput, UserUncheckedCreateWithoutWishlistItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWishlistItemsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutWishlistItemsInput = {
    create?: XOR<ProductCreateWithoutWishlistItemsInput, ProductUncheckedCreateWithoutWishlistItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWishlistItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWishlistItemsNestedInput = {
    create?: XOR<UserCreateWithoutWishlistItemsInput, UserUncheckedCreateWithoutWishlistItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWishlistItemsInput
    upsert?: UserUpsertWithoutWishlistItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWishlistItemsInput, UserUpdateWithoutWishlistItemsInput>, UserUncheckedUpdateWithoutWishlistItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutWishlistItemsNestedInput = {
    create?: XOR<ProductCreateWithoutWishlistItemsInput, ProductUncheckedCreateWithoutWishlistItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWishlistItemsInput
    upsert?: ProductUpsertWithoutWishlistItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutWishlistItemsInput, ProductUpdateWithoutWishlistItemsInput>, ProductUncheckedUpdateWithoutWishlistItemsInput>
  }

  export type UserCreateNestedOneWithoutCreatedTeamsInput = {
    create?: XOR<UserCreateWithoutCreatedTeamsInput, UserUncheckedCreateWithoutCreatedTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTeamsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedTeamsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTeamsInput, UserUncheckedCreateWithoutCreatedTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTeamsInput
    upsert?: UserUpsertWithoutCreatedTeamsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTeamsInput, UserUpdateWithoutCreatedTeamsInput>, UserUncheckedUpdateWithoutCreatedTeamsInput>
  }

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamMembershipsInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    upsert?: TeamUpsertWithoutMembersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutTeamMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    upsert?: UserUpsertWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamMembershipsInput, UserUpdateWithoutTeamMembershipsInput>, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPayoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusFilter<$PrismaModel> | $Enums.PayoutStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumFulfillmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FulfillmentStatus | EnumFulfillmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FulfillmentStatus[] | ListEnumFulfillmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FulfillmentStatus[] | ListEnumFulfillmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFulfillmentStatusFilter<$PrismaModel> | $Enums.FulfillmentStatus
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutStatusFilter<$PrismaModel>
    _max?: NestedEnumPayoutStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumFulfillmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FulfillmentStatus | EnumFulfillmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FulfillmentStatus[] | ListEnumFulfillmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FulfillmentStatus[] | ListEnumFulfillmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFulfillmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.FulfillmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFulfillmentStatusFilter<$PrismaModel>
    _max?: NestedEnumFulfillmentStatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumKYCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusFilter<$PrismaModel> | $Enums.KYCStatus
  }

  export type NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel> | $Enums.KYCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCStatusFilter<$PrismaModel>
    _max?: NestedEnumKYCStatusFilter<$PrismaModel>
  }

  export type NestedEnumTaxStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxStatus | EnumTaxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaxStatus[] | ListEnumTaxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxStatus[] | ListEnumTaxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxStatusFilter<$PrismaModel> | $Enums.TaxStatus
  }

  export type NestedEnumTaxStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxStatus | EnumTaxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaxStatus[] | ListEnumTaxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxStatus[] | ListEnumTaxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaxStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaxStatusFilter<$PrismaModel>
    _max?: NestedEnumTaxStatusFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type NestedEnumDisputeReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeReason | EnumDisputeReasonFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeReason[] | ListEnumDisputeReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeReason[] | ListEnumDisputeReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeReasonFilter<$PrismaModel> | $Enums.DisputeReason
  }

  export type NestedEnumDisputeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeStatus | EnumDisputeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeStatusFilter<$PrismaModel> | $Enums.DisputeStatus
  }

  export type NestedEnumDisputeReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeReason | EnumDisputeReasonFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeReason[] | ListEnumDisputeReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeReason[] | ListEnumDisputeReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeReasonWithAggregatesFilter<$PrismaModel> | $Enums.DisputeReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDisputeReasonFilter<$PrismaModel>
    _max?: NestedEnumDisputeReasonFilter<$PrismaModel>
  }

  export type NestedEnumDisputeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeStatus | EnumDisputeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeStatusWithAggregatesFilter<$PrismaModel> | $Enums.DisputeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDisputeStatusFilter<$PrismaModel>
    _max?: NestedEnumDisputeStatusFilter<$PrismaModel>
  }

  export type NestedEnumSponsoredPlacementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SponsoredPlacementStatus | EnumSponsoredPlacementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SponsoredPlacementStatus[] | ListEnumSponsoredPlacementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SponsoredPlacementStatus[] | ListEnumSponsoredPlacementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSponsoredPlacementStatusFilter<$PrismaModel> | $Enums.SponsoredPlacementStatus
  }

  export type NestedEnumSponsoredPlacementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SponsoredPlacementStatus | EnumSponsoredPlacementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SponsoredPlacementStatus[] | ListEnumSponsoredPlacementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SponsoredPlacementStatus[] | ListEnumSponsoredPlacementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSponsoredPlacementStatusWithAggregatesFilter<$PrismaModel> | $Enums.SponsoredPlacementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSponsoredPlacementStatusFilter<$PrismaModel>
    _max?: NestedEnumSponsoredPlacementStatusFilter<$PrismaModel>
  }

  export type NestedEnumServiceOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceOrderStatus | EnumServiceOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceOrderStatus[] | ListEnumServiceOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceOrderStatus[] | ListEnumServiceOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceOrderStatusFilter<$PrismaModel> | $Enums.ServiceOrderStatus
  }

  export type NestedEnumServiceOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceOrderStatus | EnumServiceOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceOrderStatus[] | ListEnumServiceOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceOrderStatus[] | ListEnumServiceOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumServiceOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumPartnerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerStatus | EnumPartnerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerStatusFilter<$PrismaModel> | $Enums.PartnerStatus
  }

  export type NestedEnumPartnerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerStatus | EnumPartnerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerStatus[] | ListEnumPartnerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerStatusWithAggregatesFilter<$PrismaModel> | $Enums.PartnerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartnerStatusFilter<$PrismaModel>
    _max?: NestedEnumPartnerStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CartCreateWithoutUserInput = {
    id?: string
    anonKey?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateWithoutUserInput = {
    id?: string
    anonKey?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartCreateOrConnectWithoutUserInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
  }

  export type CartCreateManyUserInputEnvelope = {
    data: CartCreateManyUserInput | CartCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRef?: string | null
    shippingAdr?: string | null
    buyerName?: string | null
    buyerPhone?: string | null
    buyerEmail?: string | null
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRef?: string | null
    shippingAdr?: string | null
    buyerName?: string | null
    buyerPhone?: string | null
    buyerEmail?: string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutSellerInput = {
    id?: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryCreateNestedOneWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productReviews?: ReviewCreateNestedManyWithoutProductInput
    stories?: CommunityStoryCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSellerInput = {
    id?: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportUncheckedCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSellerInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSellerInput, ProductUncheckedCreateWithoutSellerInput>
  }

  export type ProductCreateManySellerInputEnvelope = {
    data: ProductCreateManySellerInput | ProductCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutBuyerInput = {
    id?: string
    rating: number
    comment: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem: OrderItemCreateNestedOneWithoutReviewsInput
    seller: UserCreateNestedOneWithoutSellerReviewsInput
    product: ProductCreateNestedOneWithoutProductReviewsInput
  }

  export type ReviewUncheckedCreateWithoutBuyerInput = {
    id?: string
    orderItemId: string
    sellerId: string
    productId: string
    rating: number
    comment: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutBuyerInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutBuyerInput, ReviewUncheckedCreateWithoutBuyerInput>
  }

  export type ReviewCreateManyBuyerInputEnvelope = {
    data: ReviewCreateManyBuyerInput | ReviewCreateManyBuyerInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    body: string
    message: string
    type: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    body: string
    message: string
    type: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommunityStoryCreateWithoutUserInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutStoriesInput
  }

  export type CommunityStoryUncheckedCreateWithoutUserInput = {
    id?: string
    productId: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type CommunityStoryCreateOrConnectWithoutUserInput = {
    where: CommunityStoryWhereUniqueInput
    create: XOR<CommunityStoryCreateWithoutUserInput, CommunityStoryUncheckedCreateWithoutUserInput>
  }

  export type CommunityStoryCreateManyUserInputEnvelope = {
    data: CommunityStoryCreateManyUserInput | CommunityStoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutSellerInput = {
    id?: string
    rating: number
    comment: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem: OrderItemCreateNestedOneWithoutReviewsInput
    buyer: UserCreateNestedOneWithoutReviewsInput
    product: ProductCreateNestedOneWithoutProductReviewsInput
  }

  export type ReviewUncheckedCreateWithoutSellerInput = {
    id?: string
    orderItemId: string
    buyerId: string
    productId: string
    rating: number
    comment: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutSellerInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutSellerInput, ReviewUncheckedCreateWithoutSellerInput>
  }

  export type ReviewCreateManySellerInputEnvelope = {
    data: ReviewCreateManySellerInput | ReviewCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type CounterfeitReportCreateWithoutReporterInput = {
    id?: string
    reason: string
    evidenceUrl?: string | null
    status?: $Enums.ReportStatus
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutReportedInInput
  }

  export type CounterfeitReportUncheckedCreateWithoutReporterInput = {
    id?: string
    productId: string
    reason: string
    evidenceUrl?: string | null
    status?: $Enums.ReportStatus
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CounterfeitReportCreateOrConnectWithoutReporterInput = {
    where: CounterfeitReportWhereUniqueInput
    create: XOR<CounterfeitReportCreateWithoutReporterInput, CounterfeitReportUncheckedCreateWithoutReporterInput>
  }

  export type CounterfeitReportCreateManyReporterInputEnvelope = {
    data: CounterfeitReportCreateManyReporterInput | CounterfeitReportCreateManyReporterInput[]
    skipDuplicates?: boolean
  }

  export type SellerApplicationCreateWithoutUserInput = {
    id?: string
    businessName: string
    phone: string
    country: string
    city: string
    storefrontDesc: string
    bankName?: string | null
    accountNumber?: string | null
    accountName?: string | null
    bankCode?: string | null
    status?: $Enums.ApplicationStatus
    adminNote?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellerApplicationUncheckedCreateWithoutUserInput = {
    id?: string
    businessName: string
    phone: string
    country: string
    city: string
    storefrontDesc: string
    bankName?: string | null
    accountNumber?: string | null
    accountName?: string | null
    bankCode?: string | null
    status?: $Enums.ApplicationStatus
    adminNote?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellerApplicationCreateOrConnectWithoutUserInput = {
    where: SellerApplicationWhereUniqueInput
    create: XOR<SellerApplicationCreateWithoutUserInput, SellerApplicationUncheckedCreateWithoutUserInput>
  }

  export type SellerApplicationCreateManyUserInputEnvelope = {
    data: SellerApplicationCreateManyUserInput | SellerApplicationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DisputeCreateWithoutBuyerInput = {
    id?: string
    reasonCode: $Enums.DisputeReason
    description: string
    photoProofUrl?: string | null
    status?: $Enums.DisputeStatus
    resolutionNote?: string | null
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem: OrderItemCreateNestedOneWithoutDisputesInput
  }

  export type DisputeUncheckedCreateWithoutBuyerInput = {
    id?: string
    orderItemId: string
    reasonCode: $Enums.DisputeReason
    description: string
    photoProofUrl?: string | null
    status?: $Enums.DisputeStatus
    resolutionNote?: string | null
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisputeCreateOrConnectWithoutBuyerInput = {
    where: DisputeWhereUniqueInput
    create: XOR<DisputeCreateWithoutBuyerInput, DisputeUncheckedCreateWithoutBuyerInput>
  }

  export type DisputeCreateManyBuyerInputEnvelope = {
    data: DisputeCreateManyBuyerInput | DisputeCreateManyBuyerInput[]
    skipDuplicates?: boolean
  }

  export type FulfillmentSettingsCreateWithoutSellerInput = {
    id?: string
    usesMicroFulfillment?: boolean
    microFulfillmentPartnerId?: string | null
    microFulfillmentOptInDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FulfillmentSettingsUncheckedCreateWithoutSellerInput = {
    id?: string
    usesMicroFulfillment?: boolean
    microFulfillmentPartnerId?: string | null
    microFulfillmentOptInDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FulfillmentSettingsCreateOrConnectWithoutSellerInput = {
    where: FulfillmentSettingsWhereUniqueInput
    create: XOR<FulfillmentSettingsCreateWithoutSellerInput, FulfillmentSettingsUncheckedCreateWithoutSellerInput>
  }

  export type FulfillmentSettingsCreateManySellerInputEnvelope = {
    data: FulfillmentSettingsCreateManySellerInput | FulfillmentSettingsCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type KYCDocumentCreateWithoutSellerInput = {
    id?: string
    documentType: string
    documentNumber: string
    documentUrl: string
    country: string
    status?: $Enums.KYCStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KYCDocumentUncheckedCreateWithoutSellerInput = {
    id?: string
    documentType: string
    documentNumber: string
    documentUrl: string
    country: string
    status?: $Enums.KYCStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KYCDocumentCreateOrConnectWithoutSellerInput = {
    where: KYCDocumentWhereUniqueInput
    create: XOR<KYCDocumentCreateWithoutSellerInput, KYCDocumentUncheckedCreateWithoutSellerInput>
  }

  export type KYCDocumentCreateManySellerInputEnvelope = {
    data: KYCDocumentCreateManySellerInput | KYCDocumentCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type TaxRegistrationCreateWithoutSellerInput = {
    id?: string
    taxId: string
    country: string
    status?: $Enums.TaxStatus
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxRegistrationUncheckedCreateWithoutSellerInput = {
    id?: string
    taxId: string
    country: string
    status?: $Enums.TaxStatus
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxRegistrationCreateOrConnectWithoutSellerInput = {
    where: TaxRegistrationWhereUniqueInput
    create: XOR<TaxRegistrationCreateWithoutSellerInput, TaxRegistrationUncheckedCreateWithoutSellerInput>
  }

  export type TaxRegistrationCreateManySellerInputEnvelope = {
    data: TaxRegistrationCreateManySellerInput | TaxRegistrationCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type ProductViewCreateWithoutUserInput = {
    id?: string
    timestamp?: Date | string
    product: ProductCreateNestedOneWithoutViewsInput
  }

  export type ProductViewUncheckedCreateWithoutUserInput = {
    id?: string
    productId: string
    timestamp?: Date | string
  }

  export type ProductViewCreateOrConnectWithoutUserInput = {
    where: ProductViewWhereUniqueInput
    create: XOR<ProductViewCreateWithoutUserInput, ProductViewUncheckedCreateWithoutUserInput>
  }

  export type ProductViewCreateManyUserInputEnvelope = {
    data: ProductViewCreateManyUserInput | ProductViewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SponsoredPlacementCreateWithoutSellerInput = {
    id?: string
    categorySlug?: string | null
    searchTerm?: string | null
    bidAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SponsoredPlacementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutSponsoredPlacementsInput
  }

  export type SponsoredPlacementUncheckedCreateWithoutSellerInput = {
    id?: string
    productId: string
    categorySlug?: string | null
    searchTerm?: string | null
    bidAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SponsoredPlacementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SponsoredPlacementCreateOrConnectWithoutSellerInput = {
    where: SponsoredPlacementWhereUniqueInput
    create: XOR<SponsoredPlacementCreateWithoutSellerInput, SponsoredPlacementUncheckedCreateWithoutSellerInput>
  }

  export type SponsoredPlacementCreateManySellerInputEnvelope = {
    data: SponsoredPlacementCreateManySellerInput | SponsoredPlacementCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type ServiceOrderCreateWithoutBuyerInput = {
    id?: string
    message: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.ServiceOrderStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service: SellerServiceCreateNestedOneWithoutOrdersInput
    seller: UserCreateNestedOneWithoutServiceOrdersAsSellerInput
  }

  export type ServiceOrderUncheckedCreateWithoutBuyerInput = {
    id?: string
    serviceId: string
    sellerId: string
    message: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.ServiceOrderStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceOrderCreateOrConnectWithoutBuyerInput = {
    where: ServiceOrderWhereUniqueInput
    create: XOR<ServiceOrderCreateWithoutBuyerInput, ServiceOrderUncheckedCreateWithoutBuyerInput>
  }

  export type ServiceOrderCreateManyBuyerInputEnvelope = {
    data: ServiceOrderCreateManyBuyerInput | ServiceOrderCreateManyBuyerInput[]
    skipDuplicates?: boolean
  }

  export type ServiceOrderCreateWithoutSellerInput = {
    id?: string
    message: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.ServiceOrderStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service: SellerServiceCreateNestedOneWithoutOrdersInput
    buyer: UserCreateNestedOneWithoutServiceOrdersAsBuyerInput
  }

  export type ServiceOrderUncheckedCreateWithoutSellerInput = {
    id?: string
    serviceId: string
    buyerId: string
    message: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.ServiceOrderStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceOrderCreateOrConnectWithoutSellerInput = {
    where: ServiceOrderWhereUniqueInput
    create: XOR<ServiceOrderCreateWithoutSellerInput, ServiceOrderUncheckedCreateWithoutSellerInput>
  }

  export type ServiceOrderCreateManySellerInputEnvelope = {
    data: ServiceOrderCreateManySellerInput | ServiceOrderCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type SellerServiceCreateWithoutSellerInput = {
    id?: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    category: string
    deliveryTime: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: ServiceOrderCreateNestedManyWithoutServiceInput
  }

  export type SellerServiceUncheckedCreateWithoutSellerInput = {
    id?: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    category: string
    deliveryTime: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: ServiceOrderUncheckedCreateNestedManyWithoutServiceInput
  }

  export type SellerServiceCreateOrConnectWithoutSellerInput = {
    where: SellerServiceWhereUniqueInput
    create: XOR<SellerServiceCreateWithoutSellerInput, SellerServiceUncheckedCreateWithoutSellerInput>
  }

  export type SellerServiceCreateManySellerInputEnvelope = {
    data: SellerServiceCreateManySellerInput | SellerServiceCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type UserSubscriptionCreateWithoutUserInput = {
    id?: string
    planPrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    endDate: Date | string
    autoRenew?: boolean
    paymentMethod: string
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type UserSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    planId: string
    planPrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    endDate: Date | string
    autoRenew?: boolean
    paymentMethod: string
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSubscriptionCreateOrConnectWithoutUserInput = {
    where: UserSubscriptionWhereUniqueInput
    create: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type UserSubscriptionCreateManyUserInputEnvelope = {
    data: UserSubscriptionCreateManyUserInput | UserSubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WishlistItemCreateWithoutUserInput = {
    id?: string
    addedAt?: Date | string
    product: ProductCreateNestedOneWithoutWishlistItemsInput
  }

  export type WishlistItemUncheckedCreateWithoutUserInput = {
    id?: string
    productId: string
    addedAt?: Date | string
  }

  export type WishlistItemCreateOrConnectWithoutUserInput = {
    where: WishlistItemWhereUniqueInput
    create: XOR<WishlistItemCreateWithoutUserInput, WishlistItemUncheckedCreateWithoutUserInput>
  }

  export type WishlistItemCreateManyUserInputEnvelope = {
    data: WishlistItemCreateManyUserInput | WishlistItemCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutCreatedByInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutCreatedByInput, TeamUncheckedCreateWithoutCreatedByInput>
  }

  export type TeamCreateManyCreatedByInputEnvelope = {
    data: TeamCreateManyCreatedByInput | TeamCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type TeamMemberCreateWithoutUserInput = {
    id?: string
    role?: string
    invitedBy?: string | null
    joinedAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
  }

  export type TeamMemberUncheckedCreateWithoutUserInput = {
    id?: string
    teamId: string
    role?: string
    invitedBy?: string | null
    joinedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberCreateManyUserInputEnvelope = {
    data: TeamMemberCreateManyUserInput | TeamMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CartUpsertWithWhereUniqueWithoutUserInput = {
    where: CartWhereUniqueInput
    update: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>
    create: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
  }

  export type CartUpdateWithWhereUniqueWithoutUserInput = {
    where: CartWhereUniqueInput
    data: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>
  }

  export type CartUpdateManyWithWhereWithoutUserInput = {
    where: CartScalarWhereInput
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyWithoutUserInput>
  }

  export type CartScalarWhereInput = {
    AND?: CartScalarWhereInput | CartScalarWhereInput[]
    OR?: CartScalarWhereInput[]
    NOT?: CartScalarWhereInput | CartScalarWhereInput[]
    id?: StringFilter<"Cart"> | string
    userId?: StringNullableFilter<"Cart"> | string | null
    anonKey?: StringNullableFilter<"Cart"> | string | null
    version?: IntFilter<"Cart"> | number
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    total?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    paymentRef?: StringNullableFilter<"Order"> | string | null
    shippingAdr?: StringNullableFilter<"Order"> | string | null
    buyerName?: StringNullableFilter<"Order"> | string | null
    buyerPhone?: StringNullableFilter<"Order"> | string | null
    buyerEmail?: StringNullableFilter<"Order"> | string | null
  }

  export type ProductUpsertWithWhereUniqueWithoutSellerInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutSellerInput, ProductUncheckedUpdateWithoutSellerInput>
    create: XOR<ProductCreateWithoutSellerInput, ProductUncheckedCreateWithoutSellerInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutSellerInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutSellerInput, ProductUncheckedUpdateWithoutSellerInput>
  }

  export type ProductUpdateManyWithWhereWithoutSellerInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutSellerInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    sellerId?: StringFilter<"Product"> | string
    title?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Product"> | string
    imageUrl?: StringNullableFilter<"Product"> | string | null
    category?: StringNullableFilter<"Product"> | string | null
    ratingAvg?: FloatNullableFilter<"Product"> | number | null
    ratingCount?: IntNullableFilter<"Product"> | number | null
    viewCount?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type ReviewUpsertWithWhereUniqueWithoutBuyerInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutBuyerInput, ReviewUncheckedUpdateWithoutBuyerInput>
    create: XOR<ReviewCreateWithoutBuyerInput, ReviewUncheckedCreateWithoutBuyerInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutBuyerInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutBuyerInput, ReviewUncheckedUpdateWithoutBuyerInput>
  }

  export type ReviewUpdateManyWithWhereWithoutBuyerInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutBuyerInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    orderItemId?: StringFilter<"Review"> | string
    sellerId?: StringFilter<"Review"> | string
    buyerId?: StringFilter<"Review"> | string
    productId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringFilter<"Review"> | string
    isVisible?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type CommunityStoryUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityStoryWhereUniqueInput
    update: XOR<CommunityStoryUpdateWithoutUserInput, CommunityStoryUncheckedUpdateWithoutUserInput>
    create: XOR<CommunityStoryCreateWithoutUserInput, CommunityStoryUncheckedCreateWithoutUserInput>
  }

  export type CommunityStoryUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityStoryWhereUniqueInput
    data: XOR<CommunityStoryUpdateWithoutUserInput, CommunityStoryUncheckedUpdateWithoutUserInput>
  }

  export type CommunityStoryUpdateManyWithWhereWithoutUserInput = {
    where: CommunityStoryScalarWhereInput
    data: XOR<CommunityStoryUpdateManyMutationInput, CommunityStoryUncheckedUpdateManyWithoutUserInput>
  }

  export type CommunityStoryScalarWhereInput = {
    AND?: CommunityStoryScalarWhereInput | CommunityStoryScalarWhereInput[]
    OR?: CommunityStoryScalarWhereInput[]
    NOT?: CommunityStoryScalarWhereInput | CommunityStoryScalarWhereInput[]
    id?: StringFilter<"CommunityStory"> | string
    userId?: StringFilter<"CommunityStory"> | string
    productId?: StringFilter<"CommunityStory"> | string
    content?: StringFilter<"CommunityStory"> | string
    imageUrl?: StringNullableFilter<"CommunityStory"> | string | null
    createdAt?: DateTimeFilter<"CommunityStory"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutSellerInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutSellerInput, ReviewUncheckedUpdateWithoutSellerInput>
    create: XOR<ReviewCreateWithoutSellerInput, ReviewUncheckedCreateWithoutSellerInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutSellerInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutSellerInput, ReviewUncheckedUpdateWithoutSellerInput>
  }

  export type ReviewUpdateManyWithWhereWithoutSellerInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutSellerInput>
  }

  export type CounterfeitReportUpsertWithWhereUniqueWithoutReporterInput = {
    where: CounterfeitReportWhereUniqueInput
    update: XOR<CounterfeitReportUpdateWithoutReporterInput, CounterfeitReportUncheckedUpdateWithoutReporterInput>
    create: XOR<CounterfeitReportCreateWithoutReporterInput, CounterfeitReportUncheckedCreateWithoutReporterInput>
  }

  export type CounterfeitReportUpdateWithWhereUniqueWithoutReporterInput = {
    where: CounterfeitReportWhereUniqueInput
    data: XOR<CounterfeitReportUpdateWithoutReporterInput, CounterfeitReportUncheckedUpdateWithoutReporterInput>
  }

  export type CounterfeitReportUpdateManyWithWhereWithoutReporterInput = {
    where: CounterfeitReportScalarWhereInput
    data: XOR<CounterfeitReportUpdateManyMutationInput, CounterfeitReportUncheckedUpdateManyWithoutReporterInput>
  }

  export type CounterfeitReportScalarWhereInput = {
    AND?: CounterfeitReportScalarWhereInput | CounterfeitReportScalarWhereInput[]
    OR?: CounterfeitReportScalarWhereInput[]
    NOT?: CounterfeitReportScalarWhereInput | CounterfeitReportScalarWhereInput[]
    id?: StringFilter<"CounterfeitReport"> | string
    reporterId?: StringFilter<"CounterfeitReport"> | string
    productId?: StringFilter<"CounterfeitReport"> | string
    reason?: StringFilter<"CounterfeitReport"> | string
    evidenceUrl?: StringNullableFilter<"CounterfeitReport"> | string | null
    status?: EnumReportStatusFilter<"CounterfeitReport"> | $Enums.ReportStatus
    resolution?: StringNullableFilter<"CounterfeitReport"> | string | null
    createdAt?: DateTimeFilter<"CounterfeitReport"> | Date | string
    updatedAt?: DateTimeFilter<"CounterfeitReport"> | Date | string
  }

  export type SellerApplicationUpsertWithWhereUniqueWithoutUserInput = {
    where: SellerApplicationWhereUniqueInput
    update: XOR<SellerApplicationUpdateWithoutUserInput, SellerApplicationUncheckedUpdateWithoutUserInput>
    create: XOR<SellerApplicationCreateWithoutUserInput, SellerApplicationUncheckedCreateWithoutUserInput>
  }

  export type SellerApplicationUpdateWithWhereUniqueWithoutUserInput = {
    where: SellerApplicationWhereUniqueInput
    data: XOR<SellerApplicationUpdateWithoutUserInput, SellerApplicationUncheckedUpdateWithoutUserInput>
  }

  export type SellerApplicationUpdateManyWithWhereWithoutUserInput = {
    where: SellerApplicationScalarWhereInput
    data: XOR<SellerApplicationUpdateManyMutationInput, SellerApplicationUncheckedUpdateManyWithoutUserInput>
  }

  export type SellerApplicationScalarWhereInput = {
    AND?: SellerApplicationScalarWhereInput | SellerApplicationScalarWhereInput[]
    OR?: SellerApplicationScalarWhereInput[]
    NOT?: SellerApplicationScalarWhereInput | SellerApplicationScalarWhereInput[]
    id?: StringFilter<"SellerApplication"> | string
    userId?: StringFilter<"SellerApplication"> | string
    businessName?: StringFilter<"SellerApplication"> | string
    phone?: StringFilter<"SellerApplication"> | string
    country?: StringFilter<"SellerApplication"> | string
    city?: StringFilter<"SellerApplication"> | string
    storefrontDesc?: StringFilter<"SellerApplication"> | string
    bankName?: StringNullableFilter<"SellerApplication"> | string | null
    accountNumber?: StringNullableFilter<"SellerApplication"> | string | null
    accountName?: StringNullableFilter<"SellerApplication"> | string | null
    bankCode?: StringNullableFilter<"SellerApplication"> | string | null
    status?: EnumApplicationStatusFilter<"SellerApplication"> | $Enums.ApplicationStatus
    adminNote?: StringNullableFilter<"SellerApplication"> | string | null
    reviewedAt?: DateTimeNullableFilter<"SellerApplication"> | Date | string | null
    createdAt?: DateTimeFilter<"SellerApplication"> | Date | string
    updatedAt?: DateTimeFilter<"SellerApplication"> | Date | string
  }

  export type DisputeUpsertWithWhereUniqueWithoutBuyerInput = {
    where: DisputeWhereUniqueInput
    update: XOR<DisputeUpdateWithoutBuyerInput, DisputeUncheckedUpdateWithoutBuyerInput>
    create: XOR<DisputeCreateWithoutBuyerInput, DisputeUncheckedCreateWithoutBuyerInput>
  }

  export type DisputeUpdateWithWhereUniqueWithoutBuyerInput = {
    where: DisputeWhereUniqueInput
    data: XOR<DisputeUpdateWithoutBuyerInput, DisputeUncheckedUpdateWithoutBuyerInput>
  }

  export type DisputeUpdateManyWithWhereWithoutBuyerInput = {
    where: DisputeScalarWhereInput
    data: XOR<DisputeUpdateManyMutationInput, DisputeUncheckedUpdateManyWithoutBuyerInput>
  }

  export type DisputeScalarWhereInput = {
    AND?: DisputeScalarWhereInput | DisputeScalarWhereInput[]
    OR?: DisputeScalarWhereInput[]
    NOT?: DisputeScalarWhereInput | DisputeScalarWhereInput[]
    id?: StringFilter<"Dispute"> | string
    orderItemId?: StringFilter<"Dispute"> | string
    buyerId?: StringFilter<"Dispute"> | string
    reasonCode?: EnumDisputeReasonFilter<"Dispute"> | $Enums.DisputeReason
    description?: StringFilter<"Dispute"> | string
    photoProofUrl?: StringNullableFilter<"Dispute"> | string | null
    status?: EnumDisputeStatusFilter<"Dispute"> | $Enums.DisputeStatus
    resolutionNote?: StringNullableFilter<"Dispute"> | string | null
    resolvedById?: StringNullableFilter<"Dispute"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Dispute"> | Date | string | null
    createdAt?: DateTimeFilter<"Dispute"> | Date | string
    updatedAt?: DateTimeFilter<"Dispute"> | Date | string
  }

  export type FulfillmentSettingsUpsertWithWhereUniqueWithoutSellerInput = {
    where: FulfillmentSettingsWhereUniqueInput
    update: XOR<FulfillmentSettingsUpdateWithoutSellerInput, FulfillmentSettingsUncheckedUpdateWithoutSellerInput>
    create: XOR<FulfillmentSettingsCreateWithoutSellerInput, FulfillmentSettingsUncheckedCreateWithoutSellerInput>
  }

  export type FulfillmentSettingsUpdateWithWhereUniqueWithoutSellerInput = {
    where: FulfillmentSettingsWhereUniqueInput
    data: XOR<FulfillmentSettingsUpdateWithoutSellerInput, FulfillmentSettingsUncheckedUpdateWithoutSellerInput>
  }

  export type FulfillmentSettingsUpdateManyWithWhereWithoutSellerInput = {
    where: FulfillmentSettingsScalarWhereInput
    data: XOR<FulfillmentSettingsUpdateManyMutationInput, FulfillmentSettingsUncheckedUpdateManyWithoutSellerInput>
  }

  export type FulfillmentSettingsScalarWhereInput = {
    AND?: FulfillmentSettingsScalarWhereInput | FulfillmentSettingsScalarWhereInput[]
    OR?: FulfillmentSettingsScalarWhereInput[]
    NOT?: FulfillmentSettingsScalarWhereInput | FulfillmentSettingsScalarWhereInput[]
    id?: StringFilter<"FulfillmentSettings"> | string
    sellerId?: StringFilter<"FulfillmentSettings"> | string
    usesMicroFulfillment?: BoolFilter<"FulfillmentSettings"> | boolean
    microFulfillmentPartnerId?: StringNullableFilter<"FulfillmentSettings"> | string | null
    microFulfillmentOptInDate?: DateTimeNullableFilter<"FulfillmentSettings"> | Date | string | null
    createdAt?: DateTimeFilter<"FulfillmentSettings"> | Date | string
    updatedAt?: DateTimeFilter<"FulfillmentSettings"> | Date | string
  }

  export type KYCDocumentUpsertWithWhereUniqueWithoutSellerInput = {
    where: KYCDocumentWhereUniqueInput
    update: XOR<KYCDocumentUpdateWithoutSellerInput, KYCDocumentUncheckedUpdateWithoutSellerInput>
    create: XOR<KYCDocumentCreateWithoutSellerInput, KYCDocumentUncheckedCreateWithoutSellerInput>
  }

  export type KYCDocumentUpdateWithWhereUniqueWithoutSellerInput = {
    where: KYCDocumentWhereUniqueInput
    data: XOR<KYCDocumentUpdateWithoutSellerInput, KYCDocumentUncheckedUpdateWithoutSellerInput>
  }

  export type KYCDocumentUpdateManyWithWhereWithoutSellerInput = {
    where: KYCDocumentScalarWhereInput
    data: XOR<KYCDocumentUpdateManyMutationInput, KYCDocumentUncheckedUpdateManyWithoutSellerInput>
  }

  export type KYCDocumentScalarWhereInput = {
    AND?: KYCDocumentScalarWhereInput | KYCDocumentScalarWhereInput[]
    OR?: KYCDocumentScalarWhereInput[]
    NOT?: KYCDocumentScalarWhereInput | KYCDocumentScalarWhereInput[]
    id?: StringFilter<"KYCDocument"> | string
    sellerId?: StringFilter<"KYCDocument"> | string
    documentType?: StringFilter<"KYCDocument"> | string
    documentNumber?: StringFilter<"KYCDocument"> | string
    documentUrl?: StringFilter<"KYCDocument"> | string
    country?: StringFilter<"KYCDocument"> | string
    status?: EnumKYCStatusFilter<"KYCDocument"> | $Enums.KYCStatus
    notes?: StringNullableFilter<"KYCDocument"> | string | null
    createdAt?: DateTimeFilter<"KYCDocument"> | Date | string
    updatedAt?: DateTimeFilter<"KYCDocument"> | Date | string
  }

  export type TaxRegistrationUpsertWithWhereUniqueWithoutSellerInput = {
    where: TaxRegistrationWhereUniqueInput
    update: XOR<TaxRegistrationUpdateWithoutSellerInput, TaxRegistrationUncheckedUpdateWithoutSellerInput>
    create: XOR<TaxRegistrationCreateWithoutSellerInput, TaxRegistrationUncheckedCreateWithoutSellerInput>
  }

  export type TaxRegistrationUpdateWithWhereUniqueWithoutSellerInput = {
    where: TaxRegistrationWhereUniqueInput
    data: XOR<TaxRegistrationUpdateWithoutSellerInput, TaxRegistrationUncheckedUpdateWithoutSellerInput>
  }

  export type TaxRegistrationUpdateManyWithWhereWithoutSellerInput = {
    where: TaxRegistrationScalarWhereInput
    data: XOR<TaxRegistrationUpdateManyMutationInput, TaxRegistrationUncheckedUpdateManyWithoutSellerInput>
  }

  export type TaxRegistrationScalarWhereInput = {
    AND?: TaxRegistrationScalarWhereInput | TaxRegistrationScalarWhereInput[]
    OR?: TaxRegistrationScalarWhereInput[]
    NOT?: TaxRegistrationScalarWhereInput | TaxRegistrationScalarWhereInput[]
    id?: StringFilter<"TaxRegistration"> | string
    sellerId?: StringFilter<"TaxRegistration"> | string
    taxId?: StringFilter<"TaxRegistration"> | string
    country?: StringFilter<"TaxRegistration"> | string
    status?: EnumTaxStatusFilter<"TaxRegistration"> | $Enums.TaxStatus
    expiryDate?: DateTimeNullableFilter<"TaxRegistration"> | Date | string | null
    createdAt?: DateTimeFilter<"TaxRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"TaxRegistration"> | Date | string
  }

  export type ProductViewUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductViewWhereUniqueInput
    update: XOR<ProductViewUpdateWithoutUserInput, ProductViewUncheckedUpdateWithoutUserInput>
    create: XOR<ProductViewCreateWithoutUserInput, ProductViewUncheckedCreateWithoutUserInput>
  }

  export type ProductViewUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductViewWhereUniqueInput
    data: XOR<ProductViewUpdateWithoutUserInput, ProductViewUncheckedUpdateWithoutUserInput>
  }

  export type ProductViewUpdateManyWithWhereWithoutUserInput = {
    where: ProductViewScalarWhereInput
    data: XOR<ProductViewUpdateManyMutationInput, ProductViewUncheckedUpdateManyWithoutUserInput>
  }

  export type ProductViewScalarWhereInput = {
    AND?: ProductViewScalarWhereInput | ProductViewScalarWhereInput[]
    OR?: ProductViewScalarWhereInput[]
    NOT?: ProductViewScalarWhereInput | ProductViewScalarWhereInput[]
    id?: StringFilter<"ProductView"> | string
    userId?: StringFilter<"ProductView"> | string
    productId?: StringFilter<"ProductView"> | string
    timestamp?: DateTimeFilter<"ProductView"> | Date | string
  }

  export type SponsoredPlacementUpsertWithWhereUniqueWithoutSellerInput = {
    where: SponsoredPlacementWhereUniqueInput
    update: XOR<SponsoredPlacementUpdateWithoutSellerInput, SponsoredPlacementUncheckedUpdateWithoutSellerInput>
    create: XOR<SponsoredPlacementCreateWithoutSellerInput, SponsoredPlacementUncheckedCreateWithoutSellerInput>
  }

  export type SponsoredPlacementUpdateWithWhereUniqueWithoutSellerInput = {
    where: SponsoredPlacementWhereUniqueInput
    data: XOR<SponsoredPlacementUpdateWithoutSellerInput, SponsoredPlacementUncheckedUpdateWithoutSellerInput>
  }

  export type SponsoredPlacementUpdateManyWithWhereWithoutSellerInput = {
    where: SponsoredPlacementScalarWhereInput
    data: XOR<SponsoredPlacementUpdateManyMutationInput, SponsoredPlacementUncheckedUpdateManyWithoutSellerInput>
  }

  export type SponsoredPlacementScalarWhereInput = {
    AND?: SponsoredPlacementScalarWhereInput | SponsoredPlacementScalarWhereInput[]
    OR?: SponsoredPlacementScalarWhereInput[]
    NOT?: SponsoredPlacementScalarWhereInput | SponsoredPlacementScalarWhereInput[]
    id?: StringFilter<"SponsoredPlacement"> | string
    sellerId?: StringFilter<"SponsoredPlacement"> | string
    productId?: StringFilter<"SponsoredPlacement"> | string
    categorySlug?: StringNullableFilter<"SponsoredPlacement"> | string | null
    searchTerm?: StringNullableFilter<"SponsoredPlacement"> | string | null
    bidAmount?: DecimalFilter<"SponsoredPlacement"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFilter<"SponsoredPlacement"> | Date | string
    endDate?: DateTimeFilter<"SponsoredPlacement"> | Date | string
    status?: EnumSponsoredPlacementStatusFilter<"SponsoredPlacement"> | $Enums.SponsoredPlacementStatus
    createdAt?: DateTimeFilter<"SponsoredPlacement"> | Date | string
    updatedAt?: DateTimeFilter<"SponsoredPlacement"> | Date | string
  }

  export type ServiceOrderUpsertWithWhereUniqueWithoutBuyerInput = {
    where: ServiceOrderWhereUniqueInput
    update: XOR<ServiceOrderUpdateWithoutBuyerInput, ServiceOrderUncheckedUpdateWithoutBuyerInput>
    create: XOR<ServiceOrderCreateWithoutBuyerInput, ServiceOrderUncheckedCreateWithoutBuyerInput>
  }

  export type ServiceOrderUpdateWithWhereUniqueWithoutBuyerInput = {
    where: ServiceOrderWhereUniqueInput
    data: XOR<ServiceOrderUpdateWithoutBuyerInput, ServiceOrderUncheckedUpdateWithoutBuyerInput>
  }

  export type ServiceOrderUpdateManyWithWhereWithoutBuyerInput = {
    where: ServiceOrderScalarWhereInput
    data: XOR<ServiceOrderUpdateManyMutationInput, ServiceOrderUncheckedUpdateManyWithoutBuyerInput>
  }

  export type ServiceOrderScalarWhereInput = {
    AND?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
    OR?: ServiceOrderScalarWhereInput[]
    NOT?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
    id?: StringFilter<"ServiceOrder"> | string
    serviceId?: StringFilter<"ServiceOrder"> | string
    buyerId?: StringFilter<"ServiceOrder"> | string
    sellerId?: StringFilter<"ServiceOrder"> | string
    message?: StringFilter<"ServiceOrder"> | string
    price?: DecimalFilter<"ServiceOrder"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"ServiceOrder"> | string
    status?: EnumServiceOrderStatusFilter<"ServiceOrder"> | $Enums.ServiceOrderStatus
    note?: StringNullableFilter<"ServiceOrder"> | string | null
    createdAt?: DateTimeFilter<"ServiceOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceOrder"> | Date | string
  }

  export type ServiceOrderUpsertWithWhereUniqueWithoutSellerInput = {
    where: ServiceOrderWhereUniqueInput
    update: XOR<ServiceOrderUpdateWithoutSellerInput, ServiceOrderUncheckedUpdateWithoutSellerInput>
    create: XOR<ServiceOrderCreateWithoutSellerInput, ServiceOrderUncheckedCreateWithoutSellerInput>
  }

  export type ServiceOrderUpdateWithWhereUniqueWithoutSellerInput = {
    where: ServiceOrderWhereUniqueInput
    data: XOR<ServiceOrderUpdateWithoutSellerInput, ServiceOrderUncheckedUpdateWithoutSellerInput>
  }

  export type ServiceOrderUpdateManyWithWhereWithoutSellerInput = {
    where: ServiceOrderScalarWhereInput
    data: XOR<ServiceOrderUpdateManyMutationInput, ServiceOrderUncheckedUpdateManyWithoutSellerInput>
  }

  export type SellerServiceUpsertWithWhereUniqueWithoutSellerInput = {
    where: SellerServiceWhereUniqueInput
    update: XOR<SellerServiceUpdateWithoutSellerInput, SellerServiceUncheckedUpdateWithoutSellerInput>
    create: XOR<SellerServiceCreateWithoutSellerInput, SellerServiceUncheckedCreateWithoutSellerInput>
  }

  export type SellerServiceUpdateWithWhereUniqueWithoutSellerInput = {
    where: SellerServiceWhereUniqueInput
    data: XOR<SellerServiceUpdateWithoutSellerInput, SellerServiceUncheckedUpdateWithoutSellerInput>
  }

  export type SellerServiceUpdateManyWithWhereWithoutSellerInput = {
    where: SellerServiceScalarWhereInput
    data: XOR<SellerServiceUpdateManyMutationInput, SellerServiceUncheckedUpdateManyWithoutSellerInput>
  }

  export type SellerServiceScalarWhereInput = {
    AND?: SellerServiceScalarWhereInput | SellerServiceScalarWhereInput[]
    OR?: SellerServiceScalarWhereInput[]
    NOT?: SellerServiceScalarWhereInput | SellerServiceScalarWhereInput[]
    id?: StringFilter<"SellerService"> | string
    sellerId?: StringFilter<"SellerService"> | string
    title?: StringFilter<"SellerService"> | string
    description?: StringFilter<"SellerService"> | string
    price?: DecimalFilter<"SellerService"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SellerService"> | string
    category?: StringFilter<"SellerService"> | string
    deliveryTime?: IntFilter<"SellerService"> | number
    active?: BoolFilter<"SellerService"> | boolean
    createdAt?: DateTimeFilter<"SellerService"> | Date | string
    updatedAt?: DateTimeFilter<"SellerService"> | Date | string
  }

  export type UserSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSubscriptionWhereUniqueInput
    update: XOR<UserSubscriptionUpdateWithoutUserInput, UserSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type UserSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSubscriptionWhereUniqueInput
    data: XOR<UserSubscriptionUpdateWithoutUserInput, UserSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type UserSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: UserSubscriptionScalarWhereInput
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSubscriptionScalarWhereInput = {
    AND?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
    OR?: UserSubscriptionScalarWhereInput[]
    NOT?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
    id?: StringFilter<"UserSubscription"> | string
    userId?: StringFilter<"UserSubscription"> | string
    planId?: StringFilter<"UserSubscription"> | string
    planPrice?: DecimalFilter<"UserSubscription"> | Decimal | DecimalJsLike | number | string
    status?: EnumSubscriptionStatusFilter<"UserSubscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeFilter<"UserSubscription"> | Date | string
    autoRenew?: BoolFilter<"UserSubscription"> | boolean
    paymentMethod?: StringFilter<"UserSubscription"> | string
    cancelledAt?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    createdAt?: DateTimeFilter<"UserSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"UserSubscription"> | Date | string
  }

  export type WishlistItemUpsertWithWhereUniqueWithoutUserInput = {
    where: WishlistItemWhereUniqueInput
    update: XOR<WishlistItemUpdateWithoutUserInput, WishlistItemUncheckedUpdateWithoutUserInput>
    create: XOR<WishlistItemCreateWithoutUserInput, WishlistItemUncheckedCreateWithoutUserInput>
  }

  export type WishlistItemUpdateWithWhereUniqueWithoutUserInput = {
    where: WishlistItemWhereUniqueInput
    data: XOR<WishlistItemUpdateWithoutUserInput, WishlistItemUncheckedUpdateWithoutUserInput>
  }

  export type WishlistItemUpdateManyWithWhereWithoutUserInput = {
    where: WishlistItemScalarWhereInput
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyWithoutUserInput>
  }

  export type WishlistItemScalarWhereInput = {
    AND?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
    OR?: WishlistItemScalarWhereInput[]
    NOT?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
    id?: StringFilter<"WishlistItem"> | string
    userId?: StringFilter<"WishlistItem"> | string
    productId?: StringFilter<"WishlistItem"> | string
    addedAt?: DateTimeFilter<"WishlistItem"> | Date | string
  }

  export type TeamUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutCreatedByInput, TeamUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TeamCreateWithoutCreatedByInput, TeamUncheckedCreateWithoutCreatedByInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutCreatedByInput, TeamUncheckedUpdateWithoutCreatedByInput>
  }

  export type TeamUpdateManyWithWhereWithoutCreatedByInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    createdById?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    OR?: TeamMemberScalarWhereInput[]
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    role?: StringFilter<"TeamMember"> | string
    invitedBy?: StringNullableFilter<"TeamMember"> | string | null
    joinedAt?: DateTimeFilter<"TeamMember"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProductsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
  }

  export type InventoryCreateWithoutProductInput = {
    id?: string
    quantity: number
    updatedAt?: Date | string
  }

  export type InventoryUncheckedCreateWithoutProductInput = {
    id?: string
    quantity: number
    updatedAt?: Date | string
  }

  export type InventoryCreateOrConnectWithoutProductInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
  }

  export type ProductViewCreateWithoutProductInput = {
    id?: string
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutProductViewsInput
  }

  export type ProductViewUncheckedCreateWithoutProductInput = {
    id?: string
    userId: string
    timestamp?: Date | string
  }

  export type ProductViewCreateOrConnectWithoutProductInput = {
    where: ProductViewWhereUniqueInput
    create: XOR<ProductViewCreateWithoutProductInput, ProductViewUncheckedCreateWithoutProductInput>
  }

  export type ProductViewCreateManyProductInputEnvelope = {
    data: ProductViewCreateManyProductInput | ProductViewCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CartItemCreateWithoutProductInput = {
    id?: string
    qty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cart: CartCreateNestedOneWithoutItemsInput
  }

  export type CartItemUncheckedCreateWithoutProductInput = {
    id?: string
    cartId: string
    qty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemCreateOrConnectWithoutProductInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemCreateManyProductInputEnvelope = {
    data: CartItemCreateManyProductInput | CartItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutProductInput = {
    id?: string
    qty: number
    price: Decimal | DecimalJsLike | number | string
    sellerId: string
    grossAmount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutStatus?: $Enums.PayoutStatus
    payoutBatchId?: string | null
    paidAt?: Date | string | null
    currency?: string
    fulfillmentStatus?: $Enums.FulfillmentStatus
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    trackingCode?: string | null
    carrier?: string | null
    deliveryProofUrl?: string | null
    notes?: string | null
    exceptionNotified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    disputes?: DisputeCreateNestedManyWithoutOrderItemInput
    reviews?: ReviewCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    orderId: string
    qty: number
    price: Decimal | DecimalJsLike | number | string
    sellerId: string
    grossAmount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutStatus?: $Enums.PayoutStatus
    payoutBatchId?: string | null
    paidAt?: Date | string | null
    currency?: string
    fulfillmentStatus?: $Enums.FulfillmentStatus
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    trackingCode?: string | null
    carrier?: string | null
    deliveryProofUrl?: string | null
    notes?: string | null
    exceptionNotified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disputes?: DisputeUncheckedCreateNestedManyWithoutOrderItemInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutProductInput = {
    id?: string
    rating: number
    comment: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem: OrderItemCreateNestedOneWithoutReviewsInput
    seller: UserCreateNestedOneWithoutSellerReviewsInput
    buyer: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutProductInput = {
    id?: string
    orderItemId: string
    sellerId: string
    buyerId: string
    rating: number
    comment: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutProductInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
  }

  export type ReviewCreateManyProductInputEnvelope = {
    data: ReviewCreateManyProductInput | ReviewCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CommunityStoryCreateWithoutProductInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStoriesInput
  }

  export type CommunityStoryUncheckedCreateWithoutProductInput = {
    id?: string
    userId: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type CommunityStoryCreateOrConnectWithoutProductInput = {
    where: CommunityStoryWhereUniqueInput
    create: XOR<CommunityStoryCreateWithoutProductInput, CommunityStoryUncheckedCreateWithoutProductInput>
  }

  export type CommunityStoryCreateManyProductInputEnvelope = {
    data: CommunityStoryCreateManyProductInput | CommunityStoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CounterfeitReportCreateWithoutProductInput = {
    id?: string
    reason: string
    evidenceUrl?: string | null
    status?: $Enums.ReportStatus
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportedProductsInput
  }

  export type CounterfeitReportUncheckedCreateWithoutProductInput = {
    id?: string
    reporterId: string
    reason: string
    evidenceUrl?: string | null
    status?: $Enums.ReportStatus
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CounterfeitReportCreateOrConnectWithoutProductInput = {
    where: CounterfeitReportWhereUniqueInput
    create: XOR<CounterfeitReportCreateWithoutProductInput, CounterfeitReportUncheckedCreateWithoutProductInput>
  }

  export type CounterfeitReportCreateManyProductInputEnvelope = {
    data: CounterfeitReportCreateManyProductInput | CounterfeitReportCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SponsoredPlacementCreateWithoutProductInput = {
    id?: string
    categorySlug?: string | null
    searchTerm?: string | null
    bidAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SponsoredPlacementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutSponsoredPlacementsInput
  }

  export type SponsoredPlacementUncheckedCreateWithoutProductInput = {
    id?: string
    sellerId: string
    categorySlug?: string | null
    searchTerm?: string | null
    bidAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SponsoredPlacementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SponsoredPlacementCreateOrConnectWithoutProductInput = {
    where: SponsoredPlacementWhereUniqueInput
    create: XOR<SponsoredPlacementCreateWithoutProductInput, SponsoredPlacementUncheckedCreateWithoutProductInput>
  }

  export type SponsoredPlacementCreateManyProductInputEnvelope = {
    data: SponsoredPlacementCreateManyProductInput | SponsoredPlacementCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type WishlistItemCreateWithoutProductInput = {
    id?: string
    addedAt?: Date | string
    user: UserCreateNestedOneWithoutWishlistItemsInput
  }

  export type WishlistItemUncheckedCreateWithoutProductInput = {
    id?: string
    userId: string
    addedAt?: Date | string
  }

  export type WishlistItemCreateOrConnectWithoutProductInput = {
    where: WishlistItemWhereUniqueInput
    create: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput>
  }

  export type WishlistItemCreateManyProductInputEnvelope = {
    data: WishlistItemCreateManyProductInput | WishlistItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProductsInput = {
    update: XOR<UserUpdateWithoutProductsInput, UserUncheckedUpdateWithoutProductsInput>
    create: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductsInput, UserUncheckedUpdateWithoutProductsInput>
  }

  export type UserUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InventoryUpsertWithoutProductInput = {
    update: XOR<InventoryUpdateWithoutProductInput, InventoryUncheckedUpdateWithoutProductInput>
    create: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutProductInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutProductInput, InventoryUncheckedUpdateWithoutProductInput>
  }

  export type InventoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductViewUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductViewWhereUniqueInput
    update: XOR<ProductViewUpdateWithoutProductInput, ProductViewUncheckedUpdateWithoutProductInput>
    create: XOR<ProductViewCreateWithoutProductInput, ProductViewUncheckedCreateWithoutProductInput>
  }

  export type ProductViewUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductViewWhereUniqueInput
    data: XOR<ProductViewUpdateWithoutProductInput, ProductViewUncheckedUpdateWithoutProductInput>
  }

  export type ProductViewUpdateManyWithWhereWithoutProductInput = {
    where: ProductViewScalarWhereInput
    data: XOR<ProductViewUpdateManyMutationInput, ProductViewUncheckedUpdateManyWithoutProductInput>
  }

  export type CartItemUpsertWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
  }

  export type CartItemUpdateManyWithWhereWithoutProductInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutProductInput>
  }

  export type CartItemScalarWhereInput = {
    AND?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    OR?: CartItemScalarWhereInput[]
    NOT?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    qty?: IntFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    qty?: IntFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    sellerId?: StringFilter<"OrderItem"> | string
    grossAmount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    payoutStatus?: EnumPayoutStatusFilter<"OrderItem"> | $Enums.PayoutStatus
    payoutBatchId?: StringNullableFilter<"OrderItem"> | string | null
    paidAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    currency?: StringFilter<"OrderItem"> | string
    fulfillmentStatus?: EnumFulfillmentStatusFilter<"OrderItem"> | $Enums.FulfillmentStatus
    shippedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    trackingCode?: StringNullableFilter<"OrderItem"> | string | null
    carrier?: StringNullableFilter<"OrderItem"> | string | null
    deliveryProofUrl?: StringNullableFilter<"OrderItem"> | string | null
    notes?: StringNullableFilter<"OrderItem"> | string | null
    exceptionNotified?: BoolNullableFilter<"OrderItem"> | boolean | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>
  }

  export type ReviewUpdateManyWithWhereWithoutProductInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutProductInput>
  }

  export type CommunityStoryUpsertWithWhereUniqueWithoutProductInput = {
    where: CommunityStoryWhereUniqueInput
    update: XOR<CommunityStoryUpdateWithoutProductInput, CommunityStoryUncheckedUpdateWithoutProductInput>
    create: XOR<CommunityStoryCreateWithoutProductInput, CommunityStoryUncheckedCreateWithoutProductInput>
  }

  export type CommunityStoryUpdateWithWhereUniqueWithoutProductInput = {
    where: CommunityStoryWhereUniqueInput
    data: XOR<CommunityStoryUpdateWithoutProductInput, CommunityStoryUncheckedUpdateWithoutProductInput>
  }

  export type CommunityStoryUpdateManyWithWhereWithoutProductInput = {
    where: CommunityStoryScalarWhereInput
    data: XOR<CommunityStoryUpdateManyMutationInput, CommunityStoryUncheckedUpdateManyWithoutProductInput>
  }

  export type CounterfeitReportUpsertWithWhereUniqueWithoutProductInput = {
    where: CounterfeitReportWhereUniqueInput
    update: XOR<CounterfeitReportUpdateWithoutProductInput, CounterfeitReportUncheckedUpdateWithoutProductInput>
    create: XOR<CounterfeitReportCreateWithoutProductInput, CounterfeitReportUncheckedCreateWithoutProductInput>
  }

  export type CounterfeitReportUpdateWithWhereUniqueWithoutProductInput = {
    where: CounterfeitReportWhereUniqueInput
    data: XOR<CounterfeitReportUpdateWithoutProductInput, CounterfeitReportUncheckedUpdateWithoutProductInput>
  }

  export type CounterfeitReportUpdateManyWithWhereWithoutProductInput = {
    where: CounterfeitReportScalarWhereInput
    data: XOR<CounterfeitReportUpdateManyMutationInput, CounterfeitReportUncheckedUpdateManyWithoutProductInput>
  }

  export type SponsoredPlacementUpsertWithWhereUniqueWithoutProductInput = {
    where: SponsoredPlacementWhereUniqueInput
    update: XOR<SponsoredPlacementUpdateWithoutProductInput, SponsoredPlacementUncheckedUpdateWithoutProductInput>
    create: XOR<SponsoredPlacementCreateWithoutProductInput, SponsoredPlacementUncheckedCreateWithoutProductInput>
  }

  export type SponsoredPlacementUpdateWithWhereUniqueWithoutProductInput = {
    where: SponsoredPlacementWhereUniqueInput
    data: XOR<SponsoredPlacementUpdateWithoutProductInput, SponsoredPlacementUncheckedUpdateWithoutProductInput>
  }

  export type SponsoredPlacementUpdateManyWithWhereWithoutProductInput = {
    where: SponsoredPlacementScalarWhereInput
    data: XOR<SponsoredPlacementUpdateManyMutationInput, SponsoredPlacementUncheckedUpdateManyWithoutProductInput>
  }

  export type WishlistItemUpsertWithWhereUniqueWithoutProductInput = {
    where: WishlistItemWhereUniqueInput
    update: XOR<WishlistItemUpdateWithoutProductInput, WishlistItemUncheckedUpdateWithoutProductInput>
    create: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput>
  }

  export type WishlistItemUpdateWithWhereUniqueWithoutProductInput = {
    where: WishlistItemWhereUniqueInput
    data: XOR<WishlistItemUpdateWithoutProductInput, WishlistItemUncheckedUpdateWithoutProductInput>
  }

  export type WishlistItemUpdateManyWithWhereWithoutProductInput = {
    where: WishlistItemScalarWhereInput
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductCreateWithoutInventoryInput = {
    id?: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutProductsInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productReviews?: ReviewCreateNestedManyWithoutProductInput
    stories?: CommunityStoryCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInventoryInput = {
    id?: string
    sellerId: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportUncheckedCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInventoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
  }

  export type ProductUpsertWithoutInventoryInput = {
    update: XOR<ProductUpdateWithoutInventoryInput, ProductUncheckedUpdateWithoutInventoryInput>
    create: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInventoryInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInventoryInput, ProductUncheckedUpdateWithoutInventoryInput>
  }

  export type ProductUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutProductsNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUncheckedUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutCartsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCartsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCartsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
  }

  export type CartItemCreateWithoutCartInput = {
    id?: string
    qty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemUncheckedCreateWithoutCartInput = {
    id?: string
    productId: string
    qty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemCreateOrConnectWithoutCartInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemCreateManyCartInputEnvelope = {
    data: CartItemCreateManyCartInput | CartItemCreateManyCartInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCartsInput = {
    update: XOR<UserUpdateWithoutCartsInput, UserUncheckedUpdateWithoutCartsInput>
    create: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCartsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCartsInput, UserUncheckedUpdateWithoutCartsInput>
  }

  export type UserUpdateWithoutCartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CartItemUpsertWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
  }

  export type CartItemUpdateManyWithWhereWithoutCartInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutCartInput>
  }

  export type CartCreateWithoutItemsInput = {
    id?: string
    anonKey?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCartsInput
  }

  export type CartUncheckedCreateWithoutItemsInput = {
    id?: string
    userId?: string | null
    anonKey?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartCreateOrConnectWithoutItemsInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutCartItemsInput = {
    id?: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutProductsInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productReviews?: ReviewCreateNestedManyWithoutProductInput
    stories?: CommunityStoryCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCartItemsInput = {
    id?: string
    sellerId: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportUncheckedCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCartItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
  }

  export type CartUpsertWithoutItemsInput = {
    update: XOR<CartUpdateWithoutItemsInput, CartUncheckedUpdateWithoutItemsInput>
    create: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    where?: CartWhereInput
  }

  export type CartUpdateToOneWithWhereWithoutItemsInput = {
    where?: CartWhereInput
    data: XOR<CartUpdateWithoutItemsInput, CartUncheckedUpdateWithoutItemsInput>
  }

  export type CartUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonKey?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCartsNestedInput
  }

  export type CartUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonKey?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutCartItemsInput = {
    update: XOR<ProductUpdateWithoutCartItemsInput, ProductUncheckedUpdateWithoutCartItemsInput>
    create: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCartItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCartItemsInput, ProductUncheckedUpdateWithoutCartItemsInput>
  }

  export type ProductUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutProductsNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUncheckedUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    qty: number
    price: Decimal | DecimalJsLike | number | string
    sellerId: string
    grossAmount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutStatus?: $Enums.PayoutStatus
    payoutBatchId?: string | null
    paidAt?: Date | string | null
    currency?: string
    fulfillmentStatus?: $Enums.FulfillmentStatus
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    trackingCode?: string | null
    carrier?: string | null
    deliveryProofUrl?: string | null
    notes?: string | null
    exceptionNotified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutOrderItemsInput
    disputes?: DisputeCreateNestedManyWithoutOrderItemInput
    reviews?: ReviewCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    productId: string
    qty: number
    price: Decimal | DecimalJsLike | number | string
    sellerId: string
    grossAmount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutStatus?: $Enums.PayoutStatus
    payoutBatchId?: string | null
    paidAt?: Date | string | null
    currency?: string
    fulfillmentStatus?: $Enums.FulfillmentStatus
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    trackingCode?: string | null
    carrier?: string | null
    deliveryProofUrl?: string | null
    notes?: string | null
    exceptionNotified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disputes?: DisputeUncheckedCreateNestedManyWithoutOrderItemInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutOrderInput = {
    id?: string
    provider: string
    externalRef?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: string
    provider: string
    externalRef?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type PaymentUpsertWithoutOrderInput = {
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutOrderInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRef?: string | null
    shippingAdr?: string | null
    buyerName?: string | null
    buyerPhone?: string | null
    buyerEmail?: string | null
    user: UserCreateNestedOneWithoutOrdersInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    userId: string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRef?: string | null
    shippingAdr?: string | null
    buyerName?: string | null
    buyerPhone?: string | null
    buyerEmail?: string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    id?: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutProductsInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    productReviews?: ReviewCreateNestedManyWithoutProductInput
    stories?: CommunityStoryCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    sellerId: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportUncheckedCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type DisputeCreateWithoutOrderItemInput = {
    id?: string
    reasonCode: $Enums.DisputeReason
    description: string
    photoProofUrl?: string | null
    status?: $Enums.DisputeStatus
    resolutionNote?: string | null
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    buyer: UserCreateNestedOneWithoutDisputesInput
  }

  export type DisputeUncheckedCreateWithoutOrderItemInput = {
    id?: string
    buyerId: string
    reasonCode: $Enums.DisputeReason
    description: string
    photoProofUrl?: string | null
    status?: $Enums.DisputeStatus
    resolutionNote?: string | null
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisputeCreateOrConnectWithoutOrderItemInput = {
    where: DisputeWhereUniqueInput
    create: XOR<DisputeCreateWithoutOrderItemInput, DisputeUncheckedCreateWithoutOrderItemInput>
  }

  export type DisputeCreateManyOrderItemInputEnvelope = {
    data: DisputeCreateManyOrderItemInput | DisputeCreateManyOrderItemInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutOrderItemInput = {
    id?: string
    rating: number
    comment: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutSellerReviewsInput
    buyer: UserCreateNestedOneWithoutReviewsInput
    product: ProductCreateNestedOneWithoutProductReviewsInput
  }

  export type ReviewUncheckedCreateWithoutOrderItemInput = {
    id?: string
    sellerId: string
    buyerId: string
    productId: string
    rating: number
    comment: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutOrderItemInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutOrderItemInput, ReviewUncheckedCreateWithoutOrderItemInput>
  }

  export type ReviewCreateManyOrderItemInputEnvelope = {
    data: ReviewCreateManyOrderItemInput | ReviewCreateManyOrderItemInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAdr?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    buyerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    buyerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAdr?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    buyerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    buyerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutProductsNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUncheckedUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type DisputeUpsertWithWhereUniqueWithoutOrderItemInput = {
    where: DisputeWhereUniqueInput
    update: XOR<DisputeUpdateWithoutOrderItemInput, DisputeUncheckedUpdateWithoutOrderItemInput>
    create: XOR<DisputeCreateWithoutOrderItemInput, DisputeUncheckedCreateWithoutOrderItemInput>
  }

  export type DisputeUpdateWithWhereUniqueWithoutOrderItemInput = {
    where: DisputeWhereUniqueInput
    data: XOR<DisputeUpdateWithoutOrderItemInput, DisputeUncheckedUpdateWithoutOrderItemInput>
  }

  export type DisputeUpdateManyWithWhereWithoutOrderItemInput = {
    where: DisputeScalarWhereInput
    data: XOR<DisputeUpdateManyMutationInput, DisputeUncheckedUpdateManyWithoutOrderItemInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutOrderItemInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutOrderItemInput, ReviewUncheckedUpdateWithoutOrderItemInput>
    create: XOR<ReviewCreateWithoutOrderItemInput, ReviewUncheckedCreateWithoutOrderItemInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutOrderItemInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutOrderItemInput, ReviewUncheckedUpdateWithoutOrderItemInput>
  }

  export type ReviewUpdateManyWithWhereWithoutOrderItemInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutOrderItemInput>
  }

  export type OrderCreateWithoutPaymentInput = {
    id?: string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRef?: string | null
    shippingAdr?: string | null
    buyerName?: string | null
    buyerPhone?: string | null
    buyerEmail?: string | null
    user: UserCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPaymentInput = {
    id?: string
    userId: string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRef?: string | null
    shippingAdr?: string | null
    buyerName?: string | null
    buyerPhone?: string | null
    buyerEmail?: string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPaymentInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
  }

  export type OrderUpsertWithoutPaymentInput = {
    update: XOR<OrderUpdateWithoutPaymentInput, OrderUncheckedUpdateWithoutPaymentInput>
    create: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentInput, OrderUncheckedUpdateWithoutPaymentInput>
  }

  export type OrderUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAdr?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    buyerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    buyerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAdr?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    buyerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    buyerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserCreateWithoutFulfillmentSettingsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFulfillmentSettingsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFulfillmentSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFulfillmentSettingsInput, UserUncheckedCreateWithoutFulfillmentSettingsInput>
  }

  export type UserUpsertWithoutFulfillmentSettingsInput = {
    update: XOR<UserUpdateWithoutFulfillmentSettingsInput, UserUncheckedUpdateWithoutFulfillmentSettingsInput>
    create: XOR<UserCreateWithoutFulfillmentSettingsInput, UserUncheckedCreateWithoutFulfillmentSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFulfillmentSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFulfillmentSettingsInput, UserUncheckedUpdateWithoutFulfillmentSettingsInput>
  }

  export type UserUpdateWithoutFulfillmentSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFulfillmentSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutKycDocumentsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutKycDocumentsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutKycDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKycDocumentsInput, UserUncheckedCreateWithoutKycDocumentsInput>
  }

  export type UserUpsertWithoutKycDocumentsInput = {
    update: XOR<UserUpdateWithoutKycDocumentsInput, UserUncheckedUpdateWithoutKycDocumentsInput>
    create: XOR<UserCreateWithoutKycDocumentsInput, UserUncheckedCreateWithoutKycDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKycDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKycDocumentsInput, UserUncheckedUpdateWithoutKycDocumentsInput>
  }

  export type UserUpdateWithoutKycDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutKycDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTaxRegistrationsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTaxRegistrationsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTaxRegistrationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaxRegistrationsInput, UserUncheckedCreateWithoutTaxRegistrationsInput>
  }

  export type UserUpsertWithoutTaxRegistrationsInput = {
    update: XOR<UserUpdateWithoutTaxRegistrationsInput, UserUncheckedUpdateWithoutTaxRegistrationsInput>
    create: XOR<UserCreateWithoutTaxRegistrationsInput, UserUncheckedCreateWithoutTaxRegistrationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaxRegistrationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaxRegistrationsInput, UserUncheckedUpdateWithoutTaxRegistrationsInput>
  }

  export type UserUpdateWithoutTaxRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTaxRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutReportedProductsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportedProductsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportedProductsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportedProductsInput, UserUncheckedCreateWithoutReportedProductsInput>
  }

  export type ProductCreateWithoutReportedInInput = {
    id?: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutProductsInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productReviews?: ReviewCreateNestedManyWithoutProductInput
    stories?: CommunityStoryCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutReportedInInput = {
    id?: string
    sellerId: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutReportedInInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutReportedInInput, ProductUncheckedCreateWithoutReportedInInput>
  }

  export type UserUpsertWithoutReportedProductsInput = {
    update: XOR<UserUpdateWithoutReportedProductsInput, UserUncheckedUpdateWithoutReportedProductsInput>
    create: XOR<UserCreateWithoutReportedProductsInput, UserUncheckedCreateWithoutReportedProductsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportedProductsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportedProductsInput, UserUncheckedUpdateWithoutReportedProductsInput>
  }

  export type UserUpdateWithoutReportedProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportedProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductUpsertWithoutReportedInInput = {
    update: XOR<ProductUpdateWithoutReportedInInput, ProductUncheckedUpdateWithoutReportedInInput>
    create: XOR<ProductCreateWithoutReportedInInput, ProductUncheckedCreateWithoutReportedInInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutReportedInInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutReportedInInput, ProductUncheckedUpdateWithoutReportedInInput>
  }

  export type ProductUpdateWithoutReportedInInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutProductsNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutReportedInInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutSellerApplicationsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSellerApplicationsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSellerApplicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSellerApplicationsInput, UserUncheckedCreateWithoutSellerApplicationsInput>
  }

  export type UserUpsertWithoutSellerApplicationsInput = {
    update: XOR<UserUpdateWithoutSellerApplicationsInput, UserUncheckedUpdateWithoutSellerApplicationsInput>
    create: XOR<UserCreateWithoutSellerApplicationsInput, UserUncheckedCreateWithoutSellerApplicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSellerApplicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSellerApplicationsInput, UserUncheckedUpdateWithoutSellerApplicationsInput>
  }

  export type UserUpdateWithoutSellerApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSellerApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderItemCreateWithoutDisputesInput = {
    id?: string
    qty: number
    price: Decimal | DecimalJsLike | number | string
    sellerId: string
    grossAmount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutStatus?: $Enums.PayoutStatus
    payoutBatchId?: string | null
    paidAt?: Date | string | null
    currency?: string
    fulfillmentStatus?: $Enums.FulfillmentStatus
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    trackingCode?: string | null
    carrier?: string | null
    deliveryProofUrl?: string | null
    notes?: string | null
    exceptionNotified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
    reviews?: ReviewCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutDisputesInput = {
    id?: string
    orderId: string
    productId: string
    qty: number
    price: Decimal | DecimalJsLike | number | string
    sellerId: string
    grossAmount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutStatus?: $Enums.PayoutStatus
    payoutBatchId?: string | null
    paidAt?: Date | string | null
    currency?: string
    fulfillmentStatus?: $Enums.FulfillmentStatus
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    trackingCode?: string | null
    carrier?: string | null
    deliveryProofUrl?: string | null
    notes?: string | null
    exceptionNotified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutDisputesInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutDisputesInput, OrderItemUncheckedCreateWithoutDisputesInput>
  }

  export type UserCreateWithoutDisputesInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDisputesInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDisputesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDisputesInput, UserUncheckedCreateWithoutDisputesInput>
  }

  export type OrderItemUpsertWithoutDisputesInput = {
    update: XOR<OrderItemUpdateWithoutDisputesInput, OrderItemUncheckedUpdateWithoutDisputesInput>
    create: XOR<OrderItemCreateWithoutDisputesInput, OrderItemUncheckedCreateWithoutDisputesInput>
    where?: OrderItemWhereInput
  }

  export type OrderItemUpdateToOneWithWhereWithoutDisputesInput = {
    where?: OrderItemWhereInput
    data: XOR<OrderItemUpdateWithoutDisputesInput, OrderItemUncheckedUpdateWithoutDisputesInput>
  }

  export type OrderItemUpdateWithoutDisputesInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerId?: StringFieldUpdateOperationsInput | string
    grossAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutStatus?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fulfillmentStatus?: EnumFulfillmentStatusFieldUpdateOperationsInput | $Enums.FulfillmentStatus
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
    reviews?: ReviewUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutDisputesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerId?: StringFieldUpdateOperationsInput | string
    grossAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutStatus?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fulfillmentStatus?: EnumFulfillmentStatusFieldUpdateOperationsInput | $Enums.FulfillmentStatus
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type UserUpsertWithoutDisputesInput = {
    update: XOR<UserUpdateWithoutDisputesInput, UserUncheckedUpdateWithoutDisputesInput>
    create: XOR<UserCreateWithoutDisputesInput, UserUncheckedCreateWithoutDisputesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDisputesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDisputesInput, UserUncheckedUpdateWithoutDisputesInput>
  }

  export type UserUpdateWithoutDisputesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDisputesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderItemCreateWithoutReviewsInput = {
    id?: string
    qty: number
    price: Decimal | DecimalJsLike | number | string
    sellerId: string
    grossAmount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutStatus?: $Enums.PayoutStatus
    payoutBatchId?: string | null
    paidAt?: Date | string | null
    currency?: string
    fulfillmentStatus?: $Enums.FulfillmentStatus
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    trackingCode?: string | null
    carrier?: string | null
    deliveryProofUrl?: string | null
    notes?: string | null
    exceptionNotified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
    disputes?: DisputeCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutReviewsInput = {
    id?: string
    orderId: string
    productId: string
    qty: number
    price: Decimal | DecimalJsLike | number | string
    sellerId: string
    grossAmount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutStatus?: $Enums.PayoutStatus
    payoutBatchId?: string | null
    paidAt?: Date | string | null
    currency?: string
    fulfillmentStatus?: $Enums.FulfillmentStatus
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    trackingCode?: string | null
    carrier?: string | null
    deliveryProofUrl?: string | null
    notes?: string | null
    exceptionNotified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disputes?: DisputeUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutReviewsInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutReviewsInput, OrderItemUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutSellerReviewsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSellerReviewsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSellerReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSellerReviewsInput, UserUncheckedCreateWithoutSellerReviewsInput>
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type ProductCreateWithoutProductReviewsInput = {
    id?: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutProductsInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    stories?: CommunityStoryCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductReviewsInput = {
    id?: string
    sellerId: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportUncheckedCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductReviewsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductReviewsInput, ProductUncheckedCreateWithoutProductReviewsInput>
  }

  export type OrderItemUpsertWithoutReviewsInput = {
    update: XOR<OrderItemUpdateWithoutReviewsInput, OrderItemUncheckedUpdateWithoutReviewsInput>
    create: XOR<OrderItemCreateWithoutReviewsInput, OrderItemUncheckedCreateWithoutReviewsInput>
    where?: OrderItemWhereInput
  }

  export type OrderItemUpdateToOneWithWhereWithoutReviewsInput = {
    where?: OrderItemWhereInput
    data: XOR<OrderItemUpdateWithoutReviewsInput, OrderItemUncheckedUpdateWithoutReviewsInput>
  }

  export type OrderItemUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerId?: StringFieldUpdateOperationsInput | string
    grossAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutStatus?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fulfillmentStatus?: EnumFulfillmentStatusFieldUpdateOperationsInput | $Enums.FulfillmentStatus
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
    disputes?: DisputeUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerId?: StringFieldUpdateOperationsInput | string
    grossAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutStatus?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fulfillmentStatus?: EnumFulfillmentStatusFieldUpdateOperationsInput | $Enums.FulfillmentStatus
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disputes?: DisputeUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type UserUpsertWithoutSellerReviewsInput = {
    update: XOR<UserUpdateWithoutSellerReviewsInput, UserUncheckedUpdateWithoutSellerReviewsInput>
    create: XOR<UserCreateWithoutSellerReviewsInput, UserUncheckedCreateWithoutSellerReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSellerReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSellerReviewsInput, UserUncheckedUpdateWithoutSellerReviewsInput>
  }

  export type UserUpdateWithoutSellerReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSellerReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductUpsertWithoutProductReviewsInput = {
    update: XOR<ProductUpdateWithoutProductReviewsInput, ProductUncheckedUpdateWithoutProductReviewsInput>
    create: XOR<ProductCreateWithoutProductReviewsInput, ProductUncheckedCreateWithoutProductReviewsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductReviewsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductReviewsInput, ProductUncheckedUpdateWithoutProductReviewsInput>
  }

  export type ProductUpdateWithoutProductReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutProductsNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUncheckedUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutStoriesInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStoriesInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
  }

  export type ProductCreateWithoutStoriesInput = {
    id?: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutProductsInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productReviews?: ReviewCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStoriesInput = {
    id?: string
    sellerId: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportUncheckedCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStoriesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStoriesInput, ProductUncheckedCreateWithoutStoriesInput>
  }

  export type UserUpsertWithoutStoriesInput = {
    update: XOR<UserUpdateWithoutStoriesInput, UserUncheckedUpdateWithoutStoriesInput>
    create: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStoriesInput, UserUncheckedUpdateWithoutStoriesInput>
  }

  export type UserUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductUpsertWithoutStoriesInput = {
    update: XOR<ProductUpdateWithoutStoriesInput, ProductUncheckedUpdateWithoutStoriesInput>
    create: XOR<ProductCreateWithoutStoriesInput, ProductUncheckedCreateWithoutStoriesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStoriesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStoriesInput, ProductUncheckedUpdateWithoutStoriesInput>
  }

  export type ProductUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutProductsNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUncheckedUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutProductViewsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductViewsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductViewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductViewsInput, UserUncheckedCreateWithoutProductViewsInput>
  }

  export type ProductCreateWithoutViewsInput = {
    id?: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutProductsInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productReviews?: ReviewCreateNestedManyWithoutProductInput
    stories?: CommunityStoryCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutViewsInput = {
    id?: string
    sellerId: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportUncheckedCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutViewsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutViewsInput, ProductUncheckedCreateWithoutViewsInput>
  }

  export type UserUpsertWithoutProductViewsInput = {
    update: XOR<UserUpdateWithoutProductViewsInput, UserUncheckedUpdateWithoutProductViewsInput>
    create: XOR<UserCreateWithoutProductViewsInput, UserUncheckedCreateWithoutProductViewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductViewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductViewsInput, UserUncheckedUpdateWithoutProductViewsInput>
  }

  export type UserUpdateWithoutProductViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductUpsertWithoutViewsInput = {
    update: XOR<ProductUpdateWithoutViewsInput, ProductUncheckedUpdateWithoutViewsInput>
    create: XOR<ProductCreateWithoutViewsInput, ProductUncheckedCreateWithoutViewsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutViewsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutViewsInput, ProductUncheckedUpdateWithoutViewsInput>
  }

  export type ProductUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutProductsNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUncheckedUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutSponsoredPlacementsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSponsoredPlacementsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSponsoredPlacementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSponsoredPlacementsInput, UserUncheckedCreateWithoutSponsoredPlacementsInput>
  }

  export type ProductCreateWithoutSponsoredPlacementsInput = {
    id?: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutProductsInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productReviews?: ReviewCreateNestedManyWithoutProductInput
    stories?: CommunityStoryCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSponsoredPlacementsInput = {
    id?: string
    sellerId: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSponsoredPlacementsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSponsoredPlacementsInput, ProductUncheckedCreateWithoutSponsoredPlacementsInput>
  }

  export type UserUpsertWithoutSponsoredPlacementsInput = {
    update: XOR<UserUpdateWithoutSponsoredPlacementsInput, UserUncheckedUpdateWithoutSponsoredPlacementsInput>
    create: XOR<UserCreateWithoutSponsoredPlacementsInput, UserUncheckedCreateWithoutSponsoredPlacementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSponsoredPlacementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSponsoredPlacementsInput, UserUncheckedUpdateWithoutSponsoredPlacementsInput>
  }

  export type UserUpdateWithoutSponsoredPlacementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSponsoredPlacementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductUpsertWithoutSponsoredPlacementsInput = {
    update: XOR<ProductUpdateWithoutSponsoredPlacementsInput, ProductUncheckedUpdateWithoutSponsoredPlacementsInput>
    create: XOR<ProductCreateWithoutSponsoredPlacementsInput, ProductUncheckedCreateWithoutSponsoredPlacementsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSponsoredPlacementsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSponsoredPlacementsInput, ProductUncheckedUpdateWithoutSponsoredPlacementsInput>
  }

  export type ProductUpdateWithoutSponsoredPlacementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutProductsNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSponsoredPlacementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutSellerServicesInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSellerServicesInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSellerServicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSellerServicesInput, UserUncheckedCreateWithoutSellerServicesInput>
  }

  export type ServiceOrderCreateWithoutServiceInput = {
    id?: string
    message: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.ServiceOrderStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    buyer: UserCreateNestedOneWithoutServiceOrdersAsBuyerInput
    seller: UserCreateNestedOneWithoutServiceOrdersAsSellerInput
  }

  export type ServiceOrderUncheckedCreateWithoutServiceInput = {
    id?: string
    buyerId: string
    sellerId: string
    message: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.ServiceOrderStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceOrderCreateOrConnectWithoutServiceInput = {
    where: ServiceOrderWhereUniqueInput
    create: XOR<ServiceOrderCreateWithoutServiceInput, ServiceOrderUncheckedCreateWithoutServiceInput>
  }

  export type ServiceOrderCreateManyServiceInputEnvelope = {
    data: ServiceOrderCreateManyServiceInput | ServiceOrderCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSellerServicesInput = {
    update: XOR<UserUpdateWithoutSellerServicesInput, UserUncheckedUpdateWithoutSellerServicesInput>
    create: XOR<UserCreateWithoutSellerServicesInput, UserUncheckedCreateWithoutSellerServicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSellerServicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSellerServicesInput, UserUncheckedUpdateWithoutSellerServicesInput>
  }

  export type UserUpdateWithoutSellerServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSellerServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceOrderUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceOrderWhereUniqueInput
    update: XOR<ServiceOrderUpdateWithoutServiceInput, ServiceOrderUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceOrderCreateWithoutServiceInput, ServiceOrderUncheckedCreateWithoutServiceInput>
  }

  export type ServiceOrderUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceOrderWhereUniqueInput
    data: XOR<ServiceOrderUpdateWithoutServiceInput, ServiceOrderUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceOrderUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceOrderScalarWhereInput
    data: XOR<ServiceOrderUpdateManyMutationInput, ServiceOrderUncheckedUpdateManyWithoutServiceInput>
  }

  export type SellerServiceCreateWithoutOrdersInput = {
    id?: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    category: string
    deliveryTime: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutSellerServicesInput
  }

  export type SellerServiceUncheckedCreateWithoutOrdersInput = {
    id?: string
    sellerId: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    category: string
    deliveryTime: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellerServiceCreateOrConnectWithoutOrdersInput = {
    where: SellerServiceWhereUniqueInput
    create: XOR<SellerServiceCreateWithoutOrdersInput, SellerServiceUncheckedCreateWithoutOrdersInput>
  }

  export type UserCreateWithoutServiceOrdersAsBuyerInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutServiceOrdersAsBuyerInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutServiceOrdersAsBuyerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServiceOrdersAsBuyerInput, UserUncheckedCreateWithoutServiceOrdersAsBuyerInput>
  }

  export type UserCreateWithoutServiceOrdersAsSellerInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutServiceOrdersAsSellerInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutServiceOrdersAsSellerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServiceOrdersAsSellerInput, UserUncheckedCreateWithoutServiceOrdersAsSellerInput>
  }

  export type SellerServiceUpsertWithoutOrdersInput = {
    update: XOR<SellerServiceUpdateWithoutOrdersInput, SellerServiceUncheckedUpdateWithoutOrdersInput>
    create: XOR<SellerServiceCreateWithoutOrdersInput, SellerServiceUncheckedCreateWithoutOrdersInput>
    where?: SellerServiceWhereInput
  }

  export type SellerServiceUpdateToOneWithWhereWithoutOrdersInput = {
    where?: SellerServiceWhereInput
    data: XOR<SellerServiceUpdateWithoutOrdersInput, SellerServiceUncheckedUpdateWithoutOrdersInput>
  }

  export type SellerServiceUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutSellerServicesNestedInput
  }

  export type SellerServiceUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutServiceOrdersAsBuyerInput = {
    update: XOR<UserUpdateWithoutServiceOrdersAsBuyerInput, UserUncheckedUpdateWithoutServiceOrdersAsBuyerInput>
    create: XOR<UserCreateWithoutServiceOrdersAsBuyerInput, UserUncheckedCreateWithoutServiceOrdersAsBuyerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServiceOrdersAsBuyerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServiceOrdersAsBuyerInput, UserUncheckedUpdateWithoutServiceOrdersAsBuyerInput>
  }

  export type UserUpdateWithoutServiceOrdersAsBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutServiceOrdersAsBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutServiceOrdersAsSellerInput = {
    update: XOR<UserUpdateWithoutServiceOrdersAsSellerInput, UserUncheckedUpdateWithoutServiceOrdersAsSellerInput>
    create: XOR<UserCreateWithoutServiceOrdersAsSellerInput, UserUncheckedCreateWithoutServiceOrdersAsSellerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServiceOrdersAsSellerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServiceOrdersAsSellerInput, UserUncheckedUpdateWithoutServiceOrdersAsSellerInput>
  }

  export type UserUpdateWithoutServiceOrdersAsSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutServiceOrdersAsSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserSubscriptionCreateWithoutPlanInput = {
    id?: string
    planPrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    endDate: Date | string
    autoRenew?: boolean
    paymentMethod: string
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
  }

  export type UserSubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    userId: string
    planPrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    endDate: Date | string
    autoRenew?: boolean
    paymentMethod: string
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSubscriptionCreateOrConnectWithoutPlanInput = {
    where: UserSubscriptionWhereUniqueInput
    create: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type UserSubscriptionCreateManyPlanInputEnvelope = {
    data: UserSubscriptionCreateManyPlanInput | UserSubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: UserSubscriptionWhereUniqueInput
    update: XOR<UserSubscriptionUpdateWithoutPlanInput, UserSubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: UserSubscriptionWhereUniqueInput
    data: XOR<UserSubscriptionUpdateWithoutPlanInput, UserSubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type UserSubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: UserSubscriptionScalarWhereInput
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type UserCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    features?: SubscriptionPlanCreatefeaturesInput | string[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    features?: SubscriptionPlanCreatefeaturesInput | string[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type UserUpsertWithoutSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubscriptionPlanUpsertWithoutSubscriptionsInput = {
    update: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    where?: SubscriptionPlanWhereInput
  }

  export type SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: SubscriptionPlanWhereInput
    data: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    features?: SubscriptionPlanUpdatefeaturesInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    features?: SubscriptionPlanUpdatefeaturesInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutWishlistItemsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWishlistItemsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWishlistItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWishlistItemsInput, UserUncheckedCreateWithoutWishlistItemsInput>
  }

  export type ProductCreateWithoutWishlistItemsInput = {
    id?: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: UserCreateNestedOneWithoutProductsInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productReviews?: ReviewCreateNestedManyWithoutProductInput
    stories?: CommunityStoryCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutWishlistItemsInput = {
    id?: string
    sellerId: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutProductInput
    reportedIn?: CounterfeitReportUncheckedCreateNestedManyWithoutProductInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutWishlistItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutWishlistItemsInput, ProductUncheckedCreateWithoutWishlistItemsInput>
  }

  export type UserUpsertWithoutWishlistItemsInput = {
    update: XOR<UserUpdateWithoutWishlistItemsInput, UserUncheckedUpdateWithoutWishlistItemsInput>
    create: XOR<UserCreateWithoutWishlistItemsInput, UserUncheckedCreateWithoutWishlistItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWishlistItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWishlistItemsInput, UserUncheckedUpdateWithoutWishlistItemsInput>
  }

  export type UserUpdateWithoutWishlistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWishlistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductUpsertWithoutWishlistItemsInput = {
    update: XOR<ProductUpdateWithoutWishlistItemsInput, ProductUncheckedUpdateWithoutWishlistItemsInput>
    create: XOR<ProductCreateWithoutWishlistItemsInput, ProductUncheckedCreateWithoutWishlistItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutWishlistItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutWishlistItemsInput, ProductUncheckedUpdateWithoutWishlistItemsInput>
  }

  export type ProductUpdateWithoutWishlistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutProductsNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutWishlistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUncheckedUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutCreatedTeamsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedTeamsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedTeamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTeamsInput, UserUncheckedCreateWithoutCreatedTeamsInput>
  }

  export type TeamMemberCreateWithoutTeamInput = {
    id?: string
    role?: string
    invitedBy?: string | null
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    id?: string
    userId: string
    role?: string
    invitedBy?: string | null
    joinedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: TeamMemberCreateManyTeamInput | TeamMemberCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedTeamsInput = {
    update: XOR<UserUpdateWithoutCreatedTeamsInput, UserUncheckedUpdateWithoutCreatedTeamsInput>
    create: XOR<UserCreateWithoutCreatedTeamsInput, UserUncheckedCreateWithoutCreatedTeamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTeamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTeamsInput, UserUncheckedUpdateWithoutCreatedTeamsInput>
  }

  export type UserUpdateWithoutCreatedTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutTeamMembershipsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamMembershipsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTeamMembershipsInput = {
    update: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type UserUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSellerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutBuyerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    stories?: CommunityStoryCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationCreateNestedManyWithoutUserInput
    disputes?: DisputeCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationCreateNestedManyWithoutSellerInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: string
    city?: string | null
    country?: string | null
    phone?: string | null
    sellerHandle?: string | null
    shopName?: string | null
    shopLogoUrl?: string | null
    shopBannerUrl?: string | null
    shopBio?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    bio?: string | null
    notifyEmail?: boolean
    notifySms?: boolean
    notifyPush?: boolean
    timezone?: string | null
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSellerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBuyerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    stories?: CommunityStoryUncheckedCreateNestedManyWithoutUserInput
    sellerReviews?: ReviewUncheckedCreateNestedManyWithoutSellerInput
    reportedProducts?: CounterfeitReportUncheckedCreateNestedManyWithoutReporterInput
    sellerApplications?: SellerApplicationUncheckedCreateNestedManyWithoutUserInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBuyerInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedCreateNestedManyWithoutSellerInput
    kycDocuments?: KYCDocumentUncheckedCreateNestedManyWithoutSellerInput
    taxRegistrations?: TaxRegistrationUncheckedCreateNestedManyWithoutSellerInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    sponsoredPlacements?: SponsoredPlacementUncheckedCreateNestedManyWithoutSellerInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedCreateNestedManyWithoutBuyerInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedCreateNestedManyWithoutSellerInput
    sellerServices?: SellerServiceUncheckedCreateNestedManyWithoutSellerInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSellerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUpdateManyWithoutUserNestedInput
    disputes?: DisputeUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    sellerHandle?: NullableStringFieldUpdateOperationsInput | string | null
    shopName?: NullableStringFieldUpdateOperationsInput | string | null
    shopLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopBio?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBuyerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutUserNestedInput
    sellerReviews?: ReviewUncheckedUpdateManyWithoutSellerNestedInput
    reportedProducts?: CounterfeitReportUncheckedUpdateManyWithoutReporterNestedInput
    sellerApplications?: SellerApplicationUncheckedUpdateManyWithoutUserNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBuyerNestedInput
    fulfillmentSettings?: FulfillmentSettingsUncheckedUpdateManyWithoutSellerNestedInput
    kycDocuments?: KYCDocumentUncheckedUpdateManyWithoutSellerNestedInput
    taxRegistrations?: TaxRegistrationUncheckedUpdateManyWithoutSellerNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutSellerNestedInput
    serviceOrdersAsBuyer?: ServiceOrderUncheckedUpdateManyWithoutBuyerNestedInput
    serviceOrdersAsSeller?: ServiceOrderUncheckedUpdateManyWithoutSellerNestedInput
    sellerServices?: SellerServiceUncheckedUpdateManyWithoutSellerNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CartCreateManyUserInput = {
    id?: string
    anonKey?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyUserInput = {
    id?: string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRef?: string | null
    shippingAdr?: string | null
    buyerName?: string | null
    buyerPhone?: string | null
    buyerEmail?: string | null
  }

  export type ProductCreateManySellerInput = {
    id?: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    imageUrl?: string | null
    category?: string | null
    ratingAvg?: number | null
    ratingCount?: number | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type ReviewCreateManyBuyerInput = {
    id?: string
    orderItemId: string
    sellerId: string
    productId: string
    rating: number
    comment: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    body: string
    message: string
    type: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityStoryCreateManyUserInput = {
    id?: string
    productId: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type ReviewCreateManySellerInput = {
    id?: string
    orderItemId: string
    buyerId: string
    productId: string
    rating: number
    comment: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CounterfeitReportCreateManyReporterInput = {
    id?: string
    productId: string
    reason: string
    evidenceUrl?: string | null
    status?: $Enums.ReportStatus
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellerApplicationCreateManyUserInput = {
    id?: string
    businessName: string
    phone: string
    country: string
    city: string
    storefrontDesc: string
    bankName?: string | null
    accountNumber?: string | null
    accountName?: string | null
    bankCode?: string | null
    status?: $Enums.ApplicationStatus
    adminNote?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisputeCreateManyBuyerInput = {
    id?: string
    orderItemId: string
    reasonCode: $Enums.DisputeReason
    description: string
    photoProofUrl?: string | null
    status?: $Enums.DisputeStatus
    resolutionNote?: string | null
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FulfillmentSettingsCreateManySellerInput = {
    id?: string
    usesMicroFulfillment?: boolean
    microFulfillmentPartnerId?: string | null
    microFulfillmentOptInDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KYCDocumentCreateManySellerInput = {
    id?: string
    documentType: string
    documentNumber: string
    documentUrl: string
    country: string
    status?: $Enums.KYCStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxRegistrationCreateManySellerInput = {
    id?: string
    taxId: string
    country: string
    status?: $Enums.TaxStatus
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductViewCreateManyUserInput = {
    id?: string
    productId: string
    timestamp?: Date | string
  }

  export type SponsoredPlacementCreateManySellerInput = {
    id?: string
    productId: string
    categorySlug?: string | null
    searchTerm?: string | null
    bidAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SponsoredPlacementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceOrderCreateManyBuyerInput = {
    id?: string
    serviceId: string
    sellerId: string
    message: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.ServiceOrderStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceOrderCreateManySellerInput = {
    id?: string
    serviceId: string
    buyerId: string
    message: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.ServiceOrderStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellerServiceCreateManySellerInput = {
    id?: string
    title: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    category: string
    deliveryTime: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSubscriptionCreateManyUserInput = {
    id?: string
    planId: string
    planPrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    endDate: Date | string
    autoRenew?: boolean
    paymentMethod: string
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistItemCreateManyUserInput = {
    id?: string
    productId: string
    addedAt?: Date | string
  }

  export type TeamCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberCreateManyUserInput = {
    id?: string
    teamId: string
    role?: string
    invitedBy?: string | null
    joinedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type CartUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonKey?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonKey?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonKey?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAdr?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    buyerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    buyerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAdr?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    buyerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    buyerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAdr?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    buyerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    buyerEmail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    stories?: CommunityStoryUncheckedUpdateManyWithoutProductNestedInput
    reportedIn?: CounterfeitReportUncheckedUpdateManyWithoutProductNestedInput
    sponsoredPlacements?: SponsoredPlacementUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    ratingAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    ratingCount?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewUpdateWithoutBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUpdateOneRequiredWithoutReviewsNestedInput
    seller?: UserUpdateOneRequiredWithoutSellerReviewsNestedInput
    product?: ProductUpdateOneRequiredWithoutProductReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityStoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStoriesNestedInput
  }

  export type CommunityStoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityStoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUpdateOneRequiredWithoutReviewsNestedInput
    buyer?: UserUpdateOneRequiredWithoutReviewsNestedInput
    product?: ProductUpdateOneRequiredWithoutProductReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CounterfeitReportUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutReportedInNestedInput
  }

  export type CounterfeitReportUncheckedUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CounterfeitReportUncheckedUpdateManyWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerApplicationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    storefrontDesc?: StringFieldUpdateOperationsInput | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerApplicationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    storefrontDesc?: StringFieldUpdateOperationsInput | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerApplicationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    storefrontDesc?: StringFieldUpdateOperationsInput | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeUpdateWithoutBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumDisputeReasonFieldUpdateOperationsInput | $Enums.DisputeReason
    description?: StringFieldUpdateOperationsInput | string
    photoProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUpdateOneRequiredWithoutDisputesNestedInput
  }

  export type DisputeUncheckedUpdateWithoutBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumDisputeReasonFieldUpdateOperationsInput | $Enums.DisputeReason
    description?: StringFieldUpdateOperationsInput | string
    photoProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeUncheckedUpdateManyWithoutBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumDisputeReasonFieldUpdateOperationsInput | $Enums.DisputeReason
    description?: StringFieldUpdateOperationsInput | string
    photoProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FulfillmentSettingsUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    usesMicroFulfillment?: BoolFieldUpdateOperationsInput | boolean
    microFulfillmentPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    microFulfillmentOptInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FulfillmentSettingsUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    usesMicroFulfillment?: BoolFieldUpdateOperationsInput | boolean
    microFulfillmentPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    microFulfillmentOptInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FulfillmentSettingsUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    usesMicroFulfillment?: BoolFieldUpdateOperationsInput | boolean
    microFulfillmentPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    microFulfillmentOptInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCDocumentUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCDocumentUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCDocumentUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRegistrationUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxId?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: EnumTaxStatusFieldUpdateOperationsInput | $Enums.TaxStatus
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRegistrationUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxId?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: EnumTaxStatusFieldUpdateOperationsInput | $Enums.TaxStatus
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRegistrationUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxId?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    status?: EnumTaxStatusFieldUpdateOperationsInput | $Enums.TaxStatus
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductViewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutViewsNestedInput
  }

  export type ProductViewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductViewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SponsoredPlacementUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    categorySlug?: NullableStringFieldUpdateOperationsInput | string | null
    searchTerm?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSponsoredPlacementStatusFieldUpdateOperationsInput | $Enums.SponsoredPlacementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSponsoredPlacementsNestedInput
  }

  export type SponsoredPlacementUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    categorySlug?: NullableStringFieldUpdateOperationsInput | string | null
    searchTerm?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSponsoredPlacementStatusFieldUpdateOperationsInput | $Enums.SponsoredPlacementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SponsoredPlacementUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    categorySlug?: NullableStringFieldUpdateOperationsInput | string | null
    searchTerm?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSponsoredPlacementStatusFieldUpdateOperationsInput | $Enums.SponsoredPlacementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceOrderUpdateWithoutBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceOrderStatusFieldUpdateOperationsInput | $Enums.ServiceOrderStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: SellerServiceUpdateOneRequiredWithoutOrdersNestedInput
    seller?: UserUpdateOneRequiredWithoutServiceOrdersAsSellerNestedInput
  }

  export type ServiceOrderUncheckedUpdateWithoutBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceOrderStatusFieldUpdateOperationsInput | $Enums.ServiceOrderStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceOrderUncheckedUpdateManyWithoutBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceOrderStatusFieldUpdateOperationsInput | $Enums.ServiceOrderStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceOrderUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceOrderStatusFieldUpdateOperationsInput | $Enums.ServiceOrderStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: SellerServiceUpdateOneRequiredWithoutOrdersNestedInput
    buyer?: UserUpdateOneRequiredWithoutServiceOrdersAsBuyerNestedInput
  }

  export type ServiceOrderUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceOrderStatusFieldUpdateOperationsInput | $Enums.ServiceOrderStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceOrderUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceOrderStatusFieldUpdateOperationsInput | $Enums.ServiceOrderStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerServiceUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: ServiceOrderUpdateManyWithoutServiceNestedInput
  }

  export type SellerServiceUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: ServiceOrderUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type SellerServiceUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type UserSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    planPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    planPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutWishlistItemsNestedInput
  }

  export type WishlistItemUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductViewCreateManyProductInput = {
    id?: string
    userId: string
    timestamp?: Date | string
  }

  export type CartItemCreateManyProductInput = {
    id?: string
    cartId: string
    qty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemCreateManyProductInput = {
    id?: string
    orderId: string
    qty: number
    price: Decimal | DecimalJsLike | number | string
    sellerId: string
    grossAmount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutStatus?: $Enums.PayoutStatus
    payoutBatchId?: string | null
    paidAt?: Date | string | null
    currency?: string
    fulfillmentStatus?: $Enums.FulfillmentStatus
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    trackingCode?: string | null
    carrier?: string | null
    deliveryProofUrl?: string | null
    notes?: string | null
    exceptionNotified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyProductInput = {
    id?: string
    orderItemId: string
    sellerId: string
    buyerId: string
    rating: number
    comment: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityStoryCreateManyProductInput = {
    id?: string
    userId: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type CounterfeitReportCreateManyProductInput = {
    id?: string
    reporterId: string
    reason: string
    evidenceUrl?: string | null
    status?: $Enums.ReportStatus
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SponsoredPlacementCreateManyProductInput = {
    id?: string
    sellerId: string
    categorySlug?: string | null
    searchTerm?: string | null
    bidAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SponsoredPlacementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistItemCreateManyProductInput = {
    id?: string
    userId: string
    addedAt?: Date | string
  }

  export type ProductViewUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProductViewsNestedInput
  }

  export type ProductViewUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductViewUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput
  }

  export type CartItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerId?: StringFieldUpdateOperationsInput | string
    grossAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutStatus?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fulfillmentStatus?: EnumFulfillmentStatusFieldUpdateOperationsInput | $Enums.FulfillmentStatus
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    disputes?: DisputeUpdateManyWithoutOrderItemNestedInput
    reviews?: ReviewUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerId?: StringFieldUpdateOperationsInput | string
    grossAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutStatus?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fulfillmentStatus?: EnumFulfillmentStatusFieldUpdateOperationsInput | $Enums.FulfillmentStatus
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disputes?: DisputeUncheckedUpdateManyWithoutOrderItemNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerId?: StringFieldUpdateOperationsInput | string
    grossAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutStatus?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fulfillmentStatus?: EnumFulfillmentStatusFieldUpdateOperationsInput | $Enums.FulfillmentStatus
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUpdateOneRequiredWithoutReviewsNestedInput
    seller?: UserUpdateOneRequiredWithoutSellerReviewsNestedInput
    buyer?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityStoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStoriesNestedInput
  }

  export type CommunityStoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityStoryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CounterfeitReportUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportedProductsNestedInput
  }

  export type CounterfeitReportUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CounterfeitReportUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SponsoredPlacementUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    categorySlug?: NullableStringFieldUpdateOperationsInput | string | null
    searchTerm?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSponsoredPlacementStatusFieldUpdateOperationsInput | $Enums.SponsoredPlacementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutSponsoredPlacementsNestedInput
  }

  export type SponsoredPlacementUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    categorySlug?: NullableStringFieldUpdateOperationsInput | string | null
    searchTerm?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSponsoredPlacementStatusFieldUpdateOperationsInput | $Enums.SponsoredPlacementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SponsoredPlacementUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    categorySlug?: NullableStringFieldUpdateOperationsInput | string | null
    searchTerm?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSponsoredPlacementStatusFieldUpdateOperationsInput | $Enums.SponsoredPlacementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWishlistItemsNestedInput
  }

  export type WishlistItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateManyCartInput = {
    id?: string
    productId: string
    qty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutCartItemsNestedInput
  }

  export type CartItemUncheckedUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    productId: string
    qty: number
    price: Decimal | DecimalJsLike | number | string
    sellerId: string
    grossAmount: Decimal | DecimalJsLike | number | string
    feeAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutStatus?: $Enums.PayoutStatus
    payoutBatchId?: string | null
    paidAt?: Date | string | null
    currency?: string
    fulfillmentStatus?: $Enums.FulfillmentStatus
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    trackingCode?: string | null
    carrier?: string | null
    deliveryProofUrl?: string | null
    notes?: string | null
    exceptionNotified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerId?: StringFieldUpdateOperationsInput | string
    grossAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutStatus?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fulfillmentStatus?: EnumFulfillmentStatusFieldUpdateOperationsInput | $Enums.FulfillmentStatus
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
    disputes?: DisputeUpdateManyWithoutOrderItemNestedInput
    reviews?: ReviewUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerId?: StringFieldUpdateOperationsInput | string
    grossAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutStatus?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fulfillmentStatus?: EnumFulfillmentStatusFieldUpdateOperationsInput | $Enums.FulfillmentStatus
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disputes?: DisputeUncheckedUpdateManyWithoutOrderItemNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellerId?: StringFieldUpdateOperationsInput | string
    grossAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutStatus?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    payoutBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fulfillmentStatus?: EnumFulfillmentStatusFieldUpdateOperationsInput | $Enums.FulfillmentStatus
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    exceptionNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeCreateManyOrderItemInput = {
    id?: string
    buyerId: string
    reasonCode: $Enums.DisputeReason
    description: string
    photoProofUrl?: string | null
    status?: $Enums.DisputeStatus
    resolutionNote?: string | null
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyOrderItemInput = {
    id?: string
    sellerId: string
    buyerId: string
    productId: string
    rating: number
    comment: string
    isVisible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisputeUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumDisputeReasonFieldUpdateOperationsInput | $Enums.DisputeReason
    description?: StringFieldUpdateOperationsInput | string
    photoProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyer?: UserUpdateOneRequiredWithoutDisputesNestedInput
  }

  export type DisputeUncheckedUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumDisputeReasonFieldUpdateOperationsInput | $Enums.DisputeReason
    description?: StringFieldUpdateOperationsInput | string
    photoProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeUncheckedUpdateManyWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumDisputeReasonFieldUpdateOperationsInput | $Enums.DisputeReason
    description?: StringFieldUpdateOperationsInput | string
    photoProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutSellerReviewsNestedInput
    buyer?: UserUpdateOneRequiredWithoutReviewsNestedInput
    product?: ProductUpdateOneRequiredWithoutProductReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceOrderCreateManyServiceInput = {
    id?: string
    buyerId: string
    sellerId: string
    message: string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.ServiceOrderStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceOrderUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceOrderStatusFieldUpdateOperationsInput | $Enums.ServiceOrderStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyer?: UserUpdateOneRequiredWithoutServiceOrdersAsBuyerNestedInput
    seller?: UserUpdateOneRequiredWithoutServiceOrdersAsSellerNestedInput
  }

  export type ServiceOrderUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceOrderStatusFieldUpdateOperationsInput | $Enums.ServiceOrderStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceOrderUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceOrderStatusFieldUpdateOperationsInput | $Enums.ServiceOrderStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionCreateManyPlanInput = {
    id?: string
    userId: string
    planPrice: Decimal | DecimalJsLike | number | string
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    endDate: Date | string
    autoRenew?: boolean
    paymentMethod: string
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    planPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type UserSubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: StringFieldUpdateOperationsInput | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyTeamInput = {
    id?: string
    userId: string
    role?: string
    invitedBy?: string | null
    joinedAt?: Date | string
  }

  export type TeamMemberUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}